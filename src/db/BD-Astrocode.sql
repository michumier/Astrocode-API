CREATE DATABASE  IF NOT EXISTS `astrocodebd` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `astrocodebd`;
-- MySQL dump 10.13  Distrib 8.0.42, for Win64 (x86_64)
--
-- Host: localhost    Database: astrocodebd
-- ------------------------------------------------------
-- Server version	8.0.42

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `categorias`
--

DROP TABLE IF EXISTS `categorias`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `categorias` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nombre` varchar(255) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `nombre` (`nombre`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `categorias`
--

LOCK TABLES `categorias` WRITE;
/*!40000 ALTER TABLE `categorias` DISABLE KEYS */;
INSERT INTO `categorias` VALUES (11,'Algoritmos Avanzados'),(15,'Algoritmos de Búsqueda'),(8,'Algoritmos de Ordenamiento'),(6,'Arrays y Listas'),(4,'Bucles'),(3,'Estructuras Condicionales'),(10,'Estructuras de Datos'),(5,'Funciones'),(13,'Grafos y Árboles'),(7,'Objetos y Clases'),(2,'Operadores'),(14,'Optimización'),(12,'Programación Dinámica'),(9,'Recursión'),(1,'Variables y Tipos');
/*!40000 ALTER TABLE `categorias` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `insignias`
--

DROP TABLE IF EXISTS `insignias`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `insignias` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nombre` varchar(255) NOT NULL,
  `descripcion` text,
  `url_imagen` varchar(512) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `nombre` (`nombre`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `insignias`
--

LOCK TABLES `insignias` WRITE;
/*!40000 ALTER TABLE `insignias` DISABLE KEYS */;
INSERT INTO `insignias` VALUES (1,'Primer Despegue','Completó su primer ejercicio en la plataforma.','https://img.icons8.com/color/96/rocket--v1.png'),(2,'Explorador Constante','Ha completado 5 ejercicios de nivel Fácil.','https://img.icons8.com/color/96/planet.png'),(3,'Desafío Superado','Ha completado un ejercicio de nivel Difícil.','https://img.icons8.com/color/96/medal2--v1.png'),(4,'Velocidad de la Luz','Completó un ejercicio en menos de 30 segundos.','https://img.icons8.com/color/96/flash-on--v1.png'),(5,'Maestro de la Misión','Completó todos los ejercicios de una categoría.','https://img.icons8.com/color/96/galaxy.png'),(6,'Reto Diario','Completó un reto diario en el mismo día.','https://img.icons8.com/color/96/calendar-3.png'),(7,'Beta Tester','Formó parte del equipo de pruebas inicial.','https://img.icons8.com/color/96/test-account.png');
/*!40000 ALTER TABLE `insignias` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `insignias_usuarios`
--

DROP TABLE IF EXISTS `insignias_usuarios`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `insignias_usuarios` (
  `usuario_id` bigint NOT NULL,
  `insignia_id` bigint NOT NULL,
  `ganado_el` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`usuario_id`,`insignia_id`),
  KEY `insignia_id` (`insignia_id`),
  CONSTRAINT `insignias_usuarios_ibfk_1` FOREIGN KEY (`usuario_id`) REFERENCES `usuarios` (`id`),
  CONSTRAINT `insignias_usuarios_ibfk_2` FOREIGN KEY (`insignia_id`) REFERENCES `insignias` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `insignias_usuarios`
--

LOCK TABLES `insignias_usuarios` WRITE;
/*!40000 ALTER TABLE `insignias_usuarios` DISABLE KEYS */;
/*!40000 ALTER TABLE `insignias_usuarios` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `niveles`
--

DROP TABLE IF EXISTS `niveles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `niveles` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nombre` varchar(255) NOT NULL,
  `puntos` int NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `nombre` (`nombre`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `niveles`
--

LOCK TABLES `niveles` WRITE;
/*!40000 ALTER TABLE `niveles` DISABLE KEYS */;
INSERT INTO `niveles` VALUES (1,'Fácil',50),(2,'Intermedio',200),(3,'Difícil',500);
/*!40000 ALTER TABLE `niveles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tareas`
--

DROP TABLE IF EXISTS `tareas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tareas` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `categoria_id` bigint NOT NULL,
  `nivel_id` bigint NOT NULL,
  `descripcion` text NOT NULL,
  `fecha_vencimiento` date DEFAULT NULL,
  `prioridad` int DEFAULT NULL,
  `completado` tinyint(1) DEFAULT '0',
  `tiempo_finalizacion_id` bigint DEFAULT NULL,
  `puntos_base` int DEFAULT NULL,
  `puntos_bonus` int DEFAULT '0',
  `codigo_base` text COMMENT 'Código base/plantilla para el ejercicio',
  `resultado_esperado` text COMMENT 'Resultado esperado que debe mostrar el código al ejecutarse',
  `titulo` varchar(255) NOT NULL DEFAULT '' COMMENT 'Título descriptivo del ejercicio',
  PRIMARY KEY (`id`),
  KEY `categoria_id` (`categoria_id`),
  KEY `nivel_id` (`nivel_id`),
  KEY `tiempo_finalizacion_id` (`tiempo_finalizacion_id`),
  CONSTRAINT `tareas_ibfk_1` FOREIGN KEY (`categoria_id`) REFERENCES `categorias` (`id`),
  CONSTRAINT `tareas_ibfk_2` FOREIGN KEY (`nivel_id`) REFERENCES `niveles` (`id`),
  CONSTRAINT `tareas_ibfk_3` FOREIGN KEY (`tiempo_finalizacion_id`) REFERENCES `tiempos_finalizacion` (`id`),
  CONSTRAINT `tareas_chk_1` CHECK ((`prioridad` between 1 and 5))
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tareas`
--

LOCK TABLES `tareas` WRITE;
/*!40000 ALTER TABLE `tareas` DISABLE KEYS */;
INSERT INTO `tareas` VALUES (1,1,1,'? **Misión: Configuración de Nave Espacial**\n\nComo nuevo cadete de AstroCode, tu primera misión es configurar los sistemas básicos de tu nave espacial. Debes declarar una variable para almacenar la edad del comandante.\n\n**Contexto de la misión:**\nEstás a bordo de la estación espacial AstroCode-1, preparándote para tu primer viaje intergaláctico. El sistema de navegación requiere que registres la edad del comandante para calcular los parámetros de vuelo.\n\n**Objetivos:**\n- Declara una variable llamada \"edad\" de tipo entero\n- Asígnale el valor 25\n- Imprime su valor en la consola con un mensaje espacial\n\n¡Completa esta configuración para poder despegar hacia las estrellas! ?',NULL,3,0,1,50,0,'print(\"? === REGISTRO DE COMANDANTE ESPACIAL ===\")\n\n# TODO: Declara la variable edad y asígnale el valor 25\n\n# TODO: Imprime el valor con un mensaje\nprint(f\"Edad del comandante: {edad} años terrestres\")\nprint(\"✅ Comandante registrado - Listo para el despegue!\")','? === REGISTRO DE COMANDANTE ESPACIAL ===\nEdad del comandante: 25 años terrestres\n✅ Comandante registrado - Listo para el despegue!','Variables Espaciales Básicas'),(2,1,2,'?️ **Misión: Sistema de Telemetría Avanzada**\n\nComo ingeniero de sistemas de la estación AstroCode, debes crear un programa de telemetría que maneje diferentes tipos de datos de la nave y realice conversiones entre ellos.\n\n**Contexto de la misión:**\nLos sensores de la nave envían datos en diferentes formatos. Tu sistema debe procesar y convertir estos datos para que sean compatibles con el ordenador central.\n\n**Objetivos:**\n- Declara variables de diferentes tipos (entero, flotante, string, booleano)\n- Realiza conversiones entre tipos\n- Muestra los resultados de cada conversión\n\n**Datos de sensores:**\n- Velocidad: \"2500\" (string) → convertir a número\n- Temperatura: 98.6 (float) → convertir a entero\n- Coordenada X: 42 (int) → convertir a string\n- Sistema activo: 1 (int) → convertir a booleano\n\n? ¡La precisión de los datos es crucial para la navegación!',NULL,3,0,2,200,0,'print(\"? === LABORATORIO DE TIPOS CUÁNTICOS ===\")\n\n# Sistema de detección automática de tipos\nclass DetectorTipos:\n    # TODO: Implementar detección automática de tipos\n    @staticmethod\n    def detectar_tipo(muestra):\n        # Implementar lógica de detección\n        pass\n    \n    # TODO: Implementar conversiones seguras\n    @staticmethod\n    def convertir_seguro(valor, tipo_destino):\n        # Implementar conversiones con validación\n        pass\n    \n    # TODO: Implementar operaciones entre tipos\n    @staticmethod\n    def operar_tipos(valor1, valor2, operacion):\n        # Implementar operaciones seguras\n        pass\n\n# Muestras de prueba\nmuestras = [42, \"Helio-3\", 3.14159, True, None, {\"elemento\": \"Hidrógeno\"}]\n\nprint(\"? Analizando muestras extraterrestres:\")\nfor index, muestra in enumerate(muestras):\n    # TODO: Usar DetectorTipos para analizar cada muestra\n    print(f\"Muestra {index + 1}: {muestra} -> Tipo: [IMPLEMENTAR]\")\n\nprint(\"\n? Pruebas de conversión segura:\")\n# TODO: Implementar pruebas de conversión\n\nprint(\"\n⚗️ Análisis completado\")','?️ === SISTEMA DE TELEMETRÍA ESPACIAL ===\n? Datos originales:\nVelocidad (string): 2500\nTemperatura (float): 98.6\nCoordenada X (int): 42\nSistema activo (int): 1\n\n? Datos convertidos:\nVelocidad (number): 2500 km/h\nTemperatura (int): 98°C\nCoordenada X (string): \"42\"\nSistema activo (boolean): true\n\n✅ Telemetría procesada correctamente!','Sistema de Tipos Avanzado Espacial'),(3,1,3,'? LABORATORIO DE TIPOS CUÁNTICOS ESPACIALES ?\n\nComo científico jefe de la estación AstroCode, debes crear un sistema avanzado de tipos dinámicos que pueda detectar automáticamente el tipo de datos de muestras extraterrestres y realizar operaciones seguras entre diferentes tipos de materia cósmica. El sistema debe manejar conversiones entre elementos conocidos (hidrógeno, helio) y elementos desconocidos, manteniendo la integridad de los datos durante las transformaciones cuánticas.',NULL,4,0,4,500,0,'print(\"? === CONSTANTES UNIVERSALES ===\")\n\n# TODO: Define las constantes físicas fundamentales\nVELOCIDAD_LUZ = None  # 299792458 m/s\nCONSTANTE_GRAVITACIONAL = None  # 6.67430e-11 m³/kg⋅s²\nCONSTANTE_PLANCK = None  # 6.62607015e-34 J⋅s\n\n# TODO: Calcula la energía de una partícula\ndef calcular_energia_particula(masa):\n    # E = mc²\n    pass\n\n# TODO: Calcula la fuerza gravitacional\ndef calcular_fuerza_gravitacional(m1, m2, distancia):\n    # F = G * m1 * m2 / r²\n    pass\n\n# Pruebas\nmasa_electron = 9.10938356e-31  # kg\nmasa_tierra = 5.972e24  # kg\nmasa_luna = 7.342e22  # kg\ndistancia_tierra_luna = 384400000  # m\n\nprint(f\"⚡ Energía del electrón: {calcular_energia_particula(masa_electron)} J\")\nprint(f\"? Fuerza Tierra-Luna: {calcular_fuerza_gravitacional(masa_tierra, masa_luna, distancia_tierra_luna)} N\")\nprint(\"\n? Cálculos universales completados\")','? === LABORATORIO DE TIPOS CUÁNTICOS ===\n\n? Analizando muestras extraterrestres:\nMuestra 1: 42 -> Tipo: number\nMuestra 2: Helio-3 -> Tipo: string\nMuestra 3: 3.14159 -> Tipo: number\nMuestra 4: true -> Tipo: boolean\nMuestra 5: null -> Tipo: null\nMuestra 6: [object Object] -> Tipo: object\n\n? Pruebas de conversión segura:\n✅ Conversión 42 -> string: \"42\"\n✅ Conversión \"3.14\" -> number: 3.14\n⚠️ Conversión \"Helio-3\" -> number: NaN (conversión insegura)\n✅ Operación segura: 42 + 3.14 = 45.14\n\n⚗️ Análisis completado','Sistema de Tipos Genéricos Universales'),(4,2,1,'? **Misión: Calculadora de Combustible Espacial**\n\nComo técnico de combustible en la estación AstroCode, debes crear un programa que calcule el consumo de combustible para diferentes maniobras espaciales.\n\n**Contexto de la misión:**\nLa nave necesita realizar cálculos precisos de combustible antes de cada maniobra. Tu calculadora debe usar operadores aritméticos para determinar el combustible necesario.\n\n**Objetivos:**\n- Usa operadores aritméticos (+, -, *, /, %) \n- Calcula combustible para aceleración, frenado y maniobras\n- Muestra los resultados de cada operación\n\n**Datos de entrada:**\n- Combustible inicial: 1000 litros\n- Consumo por aceleración: 150 litros\n- Consumo por frenado: 75 litros\n\n⛽ ¡Cada gota de combustible cuenta en el espacio!',NULL,3,0,1,75,0,'print(\"? === INTÉRPRETE DE COMANDOS GALÁCTICOS ===\")\n\n# Intérprete de expresiones espaciales\nclass InterpreteGalactico:\n    def __init__(self):\n        self.operadores = {}\n        self.funciones = {}\n        self.inicializar_operadores()\n    \n    # TODO: Inicializar operadores personalizados\n    def inicializar_operadores(self):\n        # Implementar operadores espaciales\n        pass\n    \n    # TODO: Registrar función personalizada\n    def registrar_funcion(self, nombre, funcion):\n        # Implementar registro de funciones\n        pass\n    \n    # TODO: Evaluar expresión completa\n    def evaluar(self, expresion):\n        # Implementar evaluación con precedencia\n        pass\n    \n    # TODO: Parsear tokens\n    def parsear(self, expresion):\n        # Implementar parser de expresiones\n        pass\n\n# Crear intérprete\ninterprete = InterpreteGalactico()\n\n# TODO: Registrar funciones espaciales\ndef distancia_estelar(x1, y1, x2, y2):\n    # Implementar cálculo de distancia\n    pass\n\ninterprete.registrar_funcion(\"distancia_estelar\", distancia_estelar)\n\n# Expresiones de prueba\nexpresiones = [\n    \"2 + 3 * 4\",\n    \"distancia_estelar(0, 0, 3, 4)\",\n    \"(velocidad_warp(5) + 2) * factor_tiempo(0.8)\"\n]\n\nprint(\"? Evaluando comandos de navegación:\")\nfor expr in expresiones:\n    # TODO: Evaluar cada expresión\n    print(f\"{expr} = [IMPLEMENTAR]\")\n\nprint(\"\n? Sistema de navegación listo\")','? === CALCULADORA DE COMBUSTIBLE ESPACIAL ===\n⛽ Combustible inicial: 1000 litros\n? Consumo por aceleración: 150 litros\n? Consumo por frenado: 75 litros\n? Número de maniobras: 3\n\n? Resultados de cálculos:\nConsumo por maniobra: 225 litros\nConsumo total misión: 675 litros\nCombustible restante: 325 litros\nPorcentaje restante: 32.5%\nCombustible extra: 25 litros','Operaciones Matemáticas Galácticas'),(5,2,2,'? **Misión: Calculadora de Navegación Avanzada**\n\nComo ingeniero de sistemas de AstroCode, debes crear una calculadora avanzada que maneje operadores lógicos y de comparación para evaluar condiciones de vuelo complejas.\n\n**Contexto de la misión:**\nLa nave necesita evaluar múltiples condiciones simultáneamente para determinar si es seguro realizar maniobras complejas. Tu calculadora debe procesar expresiones con paréntesis y operadores múltiples.\n\n**Objetivos:**\n- Implementa evaluación de expresiones con paréntesis\n- Usa operadores lógicos (&&, ||, !) y de comparación\n- Evalúa condiciones de seguridad de vuelo\n- Maneja precedencia de operadores\n\n**Condiciones a evaluar:**\n- Combustible > 500 && Escudos == true\n- (Velocidad < 1000 || Emergencia == false) && Tripulacion >= 3\n\n? ¡La precisión en los cálculos puede salvar vidas!',NULL,3,0,3,250,0,'print(\"⭐ === COMPARADOR ESTELAR AVANZADO ===\")\n\n# Datos de estrellas\nestrellas = [\n    {\"nombre\": \"Sol\", \"masa\": 1.989e30, \"radio\": 696340, \"temperatura\": 5778},\n    {\"nombre\": \"Sirius\", \"masa\": 4.02e30, \"radio\": 1711000, \"temperatura\": 9940},\n    {\"nombre\": \"Betelgeuse\", \"masa\": 2.188e31, \"radio\": 548000000, \"temperatura\": 3500}\n]\n\n# TODO: Implementar comparaciones múltiples\ndef comparar_estrellas(estrella1, estrella2):\n    # Comparar masa, radio, temperatura\n    # Retornar diccionario con resultados\n    pass\n\n# TODO: Encontrar la estrella más brillante\ndef calcular_luminosidad(estrella):\n    # L = 4π * R² * σ * T⁴ (Ley de Stefan-Boltzmann)\n    # σ = 5.67e-8 W⋅m⁻²⋅K⁻⁴\n    pass\n\n# TODO: Clasificar por tipo espectral\ndef clasificar_tipo_espectral(temperatura):\n    # O: > 30000K, B: 10000-30000K, A: 7500-10000K\n    # F: 6000-7500K, G: 5200-6000K, K: 3700-5200K, M: < 3700K\n    pass\n\nprint(\"? Análisis comparativo de estrellas:\")\nfor i, estrella in enumerate(estrellas):\n    luminosidad = calcular_luminosidad(estrella)\n    tipo = clasificar_tipo_espectral(estrella[\"temperatura\"])\n    print(f\"{i+1}. {estrella[nombre]}: Tipo {tipo}, L = {luminosidad:.2e} W\")\n\nprint(\"\n⭐ Análisis estelar completado\")','? === CALCULADORA DE NAVEGACIÓN AVANZADA ===\n? Estado actual de la nave:\n⛽ Combustible: 750 litros\n?️ Escudos: Activados\n? Velocidad: 850 km/h\n? Emergencia: NO\n? Tripulación: 4 personas\n\n? Evaluación de condiciones:\nCondición 1 (Combustible y Escudos): ✅ CUMPLE\nCondición 2 (Velocidad y Tripulación): ✅ CUMPLE\n\n? Resultado final: ✅ MANIOBRAS AUTORIZADAS','Calculadora Científica Galáctica'),(6,2,3,'? INTÉRPRETE DE COMANDOS GALÁCTICOS ?\n\nDesarrolla un intérprete avanzado de expresiones matemáticas para el sistema de navegación de la nave AstroCode. El intérprete debe evaluar operadores personalizados para cálculos de trayectorias espaciales y funciones definidas por el usuario para maniobras complejas. Incluye operadores como distancia_estelar(), velocidad_warp() y coordenadas_galácticas().',NULL,4,0,5,600,0,'print(\"? === SISTEMA DE LÓGICA CUÁNTICA ===\")\n\n# TODO: Implementar operadores lógicos cuánticos\nclass LogicaCuantica:\n    @staticmethod\n    def y_cuantico(a, b, probabilidad=0.5):\n        # Implementar AND cuántico con probabilidad\n        pass\n    \n    @staticmethod\n    def o_cuantico(a, b, probabilidad=0.5):\n        # Implementar OR cuántico con probabilidad\n        pass\n    \n    @staticmethod\n    def no_cuantico(a, probabilidad=0.5):\n        # Implementar NOT cuántico con probabilidad\n        pass\n    \n    @staticmethod\n    def superposicion(estados):\n        # Crear superposición de estados\n        pass\n\n# Estados cuánticos de sensores\nsensores = {\n    \"escudo\": True,\n    \"motor\": False,\n    \"comunicaciones\": True,\n    \"navegacion\": False\n}\n\n# TODO: Evaluar estado de la nave\ndef evaluar_estado_nave(sensores):\n    # Usar lógica cuántica para determinar estado general\n    # Considerar redundancias y probabilidades\n    pass\n\n# TODO: Simular fallos de sistema\ndef simular_fallo(sistema, probabilidad_fallo):\n    # Simular fallo con probabilidad dada\n    pass\n\nprint(\"? Estado actual de sistemas:\")\nfor sistema, estado in sensores.items():\n    print(f\"  {sistema}: {? ACTIVO if estado else ? INACTIVO}\")\n\nprint(\"\n? Evaluación cuántica:\")\nestado_general = evaluar_estado_nave(sensores)\nprint(f\"Estado general: {estado_general}\")\n\nprint(\"\n? Análisis lógico completado\")','? === INTÉRPRETE DE COMANDOS GALÁCTICOS ===\n\n? Evaluando comandos de navegación:\n2 + 3 * 4 = 14\ndistancia_estelar(0, 0, 3, 4) = 5\n(velocidad_warp(5) + 2) * factor_tiempo(0.8) = 5.6\n\n? Sistema de navegación listo','Sobrecarga de Operadores Cuánticos'),(7,3,1,'?️ **Misión: Monitor de Temperatura Espacial**\n\nComo especialista en sistemas ambientales de AstroCode, debes crear un programa que monitoree la temperatura de la nave y determine si está en rangos seguros.\n\n**Contexto de la misión:**\nLa temperatura en el espacio puede ser extrema. Tu sistema debe analizar las lecturas de temperatura y clasificarlas para mantener la seguridad de la tripulación.\n\n**Objetivos:**\n- Determina si una temperatura es positiva, negativa o cero\n- Usa estructuras if-else para la clasificación\n- Proporciona mensajes de estado apropiados\n\n**Rangos de temperatura:**\n- Positiva: Zona habitable\n- Cero: Punto de congelación\n- Negativa: Zona peligrosa\n\n?️ ¡La vida de la tripulación depende de estos sistemas!',NULL,3,0,1,100,0,'print(\"? === BANCO GALÁCTICO ASTROCODE ===\")\n\n# Sistema de evaluación de préstamos\nclass EvaluadorPrestamos:\n    # TODO: Implementar evaluación completa\n    @staticmethod\n    def evaluar_solicitud(solicitante):\n        puntuacion = 0\n        factores = []\n        \n        # TODO: Evaluar ingresos (peso: 30%)\n        if False:  # condición ingresos altos\n            # Implementar lógica\n            pass\n        \n        # TODO: Evaluar historial de misiones (peso: 25%)\n        if False:  # condición historial excelente\n            # Implementar lógica\n            pass\n        \n        # TODO: Evaluar planeta de origen (peso: 20%)\n        if False:  # condición planeta seguro\n            # Implementar lógica\n            pass\n        \n        # TODO: Evaluar experiencia espacial (peso: 15%)\n        if False:  # condición experiencia alta\n            # Implementar lógica\n            pass\n        \n        # TODO: Evaluar riesgo destino (peso: 10%)\n        if False:  # condición destino seguro\n            # Implementar lógica\n            pass\n        \n        return {\"puntuacion\": puntuacion, \"factores\": factores, \"aprobado\": puntuacion >= 70}\n\n# Casos de prueba\nsolicitantes = [\n    {\n        \"nombre\": \"Comandante Zara\",\n        \"ingresos\": 85000,\n        \"historial_misiones\": \"excelente\",\n        \"planeta_origen\": \"Terra Nova\",\n        \"experiencia_espacial\": 15,\n        \"destino_colonia\": \"Kepler-442b\"\n    },\n    {\n        \"nombre\": \"Piloto Kai\",\n        \"ingresos\": 45000,\n        \"historial_misiones\": \"bueno\",\n        \"planeta_origen\": \"Marte\",\n        \"experiencia_espacial\": 5,\n        \"destino_colonia\": \"Proxima-b\"\n    }\n]\n\nprint(\"? Evaluando solicitudes de préstamo:\")\nfor solicitante in solicitantes:\n    # TODO: Evaluar cada solicitante\n    resultado = EvaluadorPrestamos.evaluar_solicitud(solicitante)\n    print(f\"\n? {solicitante[nombre]}:\")\n    print(f\"? Puntuación: {resultado[puntuacion]}/100\")\n    print(f\"{✅ APROBADO if resultado[aprobado] else ❌ RECHAZADO}\")\n\nprint(\"\n? Evaluación completada\")','?️ === MONITOR DE TEMPERATURA ESPACIAL ===\n? Temperatura detectada: -15°C\n❌ Estado: ZONA PELIGROSA\n? ALERTA: Temperatura crítica detectada\n\n?️ Monitoreo completado','Decisiones de Navegación Espacial'),(8,3,2,'? **Misión: Sistema de Calificación de Planetas**\n\nComo científico planetario de AstroCode, debes crear un sistema que evalúe la habitabilidad de planetas descubiertos y les asigne una calificación basada en múltiples factores.\n\n**Contexto de la misión:**\nTu equipo ha descubierto varios exoplanetas. Necesitas un sistema automatizado que evalúe su potencial para albergar vida basándose en temperatura, atmósfera, agua y distancia a su estrella.\n\n**Objetivos:**\n- Implementa un sistema de calificación con múltiples criterios\n- Usa estructuras if-else anidadas o switch-case\n- Asigna calificaciones: A (Excelente), B (Bueno), C (Regular), D (Pobre), F (Inhabitable)\n- Proporciona recomendaciones específicas\n\n**Criterios de evaluación:**\n- Temperatura: 0-50°C (Óptima), -50-0°C o 50-100°C (Aceptable), otros (Extrema)\n- Agua: Abundante, Moderada, Escasa, Ninguna\n- Atmósfera: Respirable, Tóxica, Ninguna\n\n? ¡Cada planeta evaluado nos acerca a encontrar un nuevo hogar!',NULL,3,0,2,300,0,'print(\"? === SISTEMA DE ALERTA DE ASTEROIDES ===\")\n\n# TODO: Implementar detector de colisiones\nclass DetectorAsteroides:\n    def __init__(self, radio_alerta=1000):\n        self.radio_alerta = radio_alerta\n        self.asteroides_detectados = []\n    \n    # TODO: Detectar asteroides cercanos\n    def detectar_asteroides(self, posicion_nave, asteroides):\n        # Calcular distancias y filtrar por radio de alerta\n        pass\n    \n    # TODO: Calcular nivel de peligro\n    def calcular_peligro(self, asteroide, posicion_nave):\n        # Considerar tamaño, velocidad y distancia\n        pass\n    \n    # TODO: Generar alerta\n    def generar_alerta(self, nivel_peligro):\n        # Retornar tipo de alerta según nivel\n        pass\n\n# Datos de asteroides\nasteroides = [\n    {\"id\": \"AST-001\", \"x\": 500, \"y\": 300, \"tamaño\": 50, \"velocidad\": 25},\n    {\"id\": \"AST-002\", \"x\": 1200, \"y\": 800, \"tamaño\": 120, \"velocidad\": 40},\n    {\"id\": \"AST-003\", \"x\": 200, \"y\": 150, \"tamaño\": 30, \"velocidad\": 15}\n]\n\nposicion_nave = {\"x\": 400, \"y\": 250}\n\n# TODO: Crear detector y analizar amenazas\ndetector = DetectorAsteroides()\nasteroides_cercanos = detector.detectar_asteroides(posicion_nave, asteroides)\n\nprint(f\"? Posición de la nave: ({posicion_nave[x]}, {posicion_nave[y]})\")\nprint(f\"? Asteroides detectados: {len(asteroides_cercanos)}\")\n\nfor asteroide in asteroides_cercanos:\n    peligro = detector.calcular_peligro(asteroide, posicion_nave)\n    alerta = detector.generar_alerta(peligro)\n    print(f\"⚠️ {asteroide[id]}: {alerta}\")\n\nprint(\"\n? Sistema de alerta activo\")','? === SISTEMA DE CALIFICACIÓN DE PLANETAS ===\n? Evaluando planeta: Kepler-442b\n?️ Temperatura: 22°C\n? Agua: Moderada\n?️ Atmósfera: Respirable\n⭐ Distancia a estrella: 1.2 UA\n✅ Temperatura: Óptima (+30 puntos)\n⚠️ Agua: Moderada (+15 puntos)\n✅ Atmósfera: Respirable (+35 puntos)\n\n? Puntuación total: 80/100\n? Calificación: A\n? Recomendación: ? EXCELENTE - Candidato prioritario para colonización','Sistema de Navegación Inteligente'),(9,3,3,'? SISTEMA DE PRÉSTAMOS INTERPLANETARIOS ?\n\nCrea un sistema avanzado de evaluación de préstamos para el Banco Galáctico AstroCode. El sistema debe evaluar múltiples condiciones anidadas para determinar la elegibilidad de préstamos para colonos espaciales, considerando factores como: ingresos en créditos galácticos, historial de misiones, planeta de origen, experiencia espacial, y riesgo de la colonia destino.',NULL,4,0,4,700,0,'print(\"? === CLASIFICADOR DE PLANETAS GALÁCTICOS ===\")\n\n# TODO: Implementar sistema de clasificación\nclass ClasificadorPlanetas:\n    @staticmethod\n    def clasificar_por_tamaño(radio):\n        # Clasificar: enano, terrestre, gigante, supergigante\n        pass\n    \n    @staticmethod\n    def clasificar_por_composicion(densidad, atmosfera):\n        # Clasificar: rocoso, gaseoso, helado\n        pass\n    \n    @staticmethod\n    def evaluar_habitabilidad(temperatura, atmosfera, agua):\n        # Evaluar potencial para vida\n        pass\n    \n    @staticmethod\n    def clasificar_completo(planeta):\n        # Clasificación completa del planeta\n        pass\n\n# Base de datos de planetas\nplanetas = [\n    {\"nombre\": \"Kepler-442b\", \"radio\": 1.34, \"densidad\": 5.2, \"temperatura\": 233, \"atmosfera\": \"densa\", \"agua\": True},\n    {\"nombre\": \"HD 40307g\", \"radio\": 1.8, \"densidad\": 4.1, \"temperatura\": 198, \"atmosfera\": \"moderada\", \"agua\": False},\n    {\"nombre\": \"Gliese 667Cc\", \"radio\": 1.5, \"densidad\": 6.8, \"temperatura\": 277, \"atmosfera\": \"espesa\", \"agua\": True}\n]\n\nprint(\"? Analizando planetas candidatos:\")\nfor planeta in planetas:\n    clasificacion = ClasificadorPlanetas.clasificar_completo(planeta)\n    print(f\"\n? {planeta[nombre]}:\")\n    print(f\"  ? Tamaño: {clasificacion.get(tamaño, N/A)}\")\n    print(f\"  ? Composición: {clasificacion.get(composicion, N/A)}\")\n    print(f\"  ? Habitabilidad: {clasificacion.get(habitabilidad, N/A)}\")\n\nprint(\"\n? Clasificación planetaria completada\")','? === BANCO GALÁCTICO ASTROCODE ===\n\n? Evaluando solicitudes de préstamo:\n\n? Comandante Zara:\n? Puntuación: 95/100\n✅ APROBADO\n\n? Piloto Kai:\n? Puntuación: 65/100\n❌ RECHAZADO\n\n? Evaluación completada','IA de Decisiones Espaciales'),(10,4,1,'? **Misión: Secuencia de Lanzamiento**\n\nComo controlador de lanzamiento en AstroCode, debes programar la secuencia de cuenta regresiva para el despegue de la nave espacial.\n\n**Contexto de la misión:**\nCada lanzamiento requiere una secuencia precisa de verificaciones. Tu programa debe generar la secuencia numérica y identificar los sistemas críticos (números pares).\n\n**Objetivos:**\n- Usa un bucle for para imprimir números del 1 al 10\n- Modifica el programa para mostrar solo números pares\n- Agrega mensajes de verificación de sistemas\n\n**Secuencia de verificación:**\n- Números 1-10: Verificación general\n- Números pares: Sistemas críticos\n\n? ¡Cada verificación es crucial para un lanzamiento exitoso!',NULL,3,0,1,125,0,'print(\"? === SECUENCIA DE LANZAMIENTO ESPACIAL ===\")\nimport time\n\n# TODO: Implementar sistema de cuenta regresiva\nclass ControladorLanzamiento:\n    def __init__(self):\n        self.sistemas_verificados = False\n        self.combustible_cargado = False\n        self.tripulacion_lista = False\n    \n    # TODO: Verificar sistemas\n    def verificar_sistemas(self):\n        # Simular verificación de sistemas\n        pass\n    \n    # TODO: Cargar combustible\n    def cargar_combustible(self):\n        # Simular carga de combustible\n        pass\n    \n    # TODO: Preparar tripulación\n    def preparar_tripulacion(self):\n        # Verificar estado de tripulación\n        pass\n    \n    # TODO: Ejecutar cuenta regresiva\n    def cuenta_regresiva(self, segundos=10):\n        # Implementar cuenta regresiva con verificaciones\n        for i in range(segundos, 0, -1):\n            # TODO: Verificar sistemas en cada paso\n            print(f\"⏰ T-{i} segundos...\")\n            # time.sleep(1)  # Descomenta para tiempo real\n        \n        # TODO: Verificar condiciones de lanzamiento\n        if self.verificar_lanzamiento():\n            print(\"? ¡DESPEGUE!\")\n            return True\n        else:\n            print(\"❌ LANZAMIENTO ABORTADO\")\n            return False\n    \n    def verificar_lanzamiento(self):\n        return self.sistemas_verificados and self.combustible_cargado and self.tripulacion_lista\n\n# Secuencia de lanzamiento\ncontrolador = ControladorLanzamiento()\n\nprint(\"? Iniciando secuencia de pre-lanzamiento:\")\nprint(\"? Verificando sistemas...\")\ncontrolador.verificar_sistemas()\n\nprint(\"⛽ Cargando combustible...\")\ncontrolador.cargar_combustible()\n\nprint(\"?‍? Preparando tripulación...\")\ncontrolador.preparar_tripulacion()\n\nprint(\"\n? Iniciando cuenta regresiva:\")\nexito = controlador.cuenta_regresiva(10)\n\nif exito:\n    print(\"✅ Misión iniciada con éxito\")\nelse:\n    print(\"❌ Misión abortada - Revisar sistemas\")','? === SECUENCIA DE LANZAMIENTO ASTROCODE ===\n\n? Verificación general de sistemas:\nSistema 1: ✅ Verificado\nSistema 2: ✅ Verificado\nSistema 3: ✅ Verificado\nSistema 4: ✅ Verificado\nSistema 5: ✅ Verificado\nSistema 6: ✅ Verificado\nSistema 7: ✅ Verificado\nSistema 8: ✅ Verificado\nSistema 9: ✅ Verificado\nSistema 10: ✅ Verificado\n\n? Verificación de sistemas críticos (números pares):\n? Sistema crítico 2: ✅ OPERATIVO\n? Sistema crítico 4: ✅ OPERATIVO\n? Sistema crítico 6: ✅ OPERATIVO\n? Sistema crítico 8: ✅ OPERATIVO\n? Sistema crítico 10: ✅ OPERATIVO\n\n? Secuencia de lanzamiento completada\n✅ Todos los sistemas verificados - LISTO PARA DESPEGUE!','Cuenta Regresiva de Lanzamiento'),(11,4,2,'? **Misión: Generador de Secuencia Fibonacci Galáctica**\n\nComo matemático espacial de AstroCode, debes crear un generador de la secuencia de Fibonacci que simule los patrones de crecimiento de cristales energéticos encontrados en diferentes galaxias.\n\n**Contexto de la misión:**\nLos cristales energéticos descubiertos en la galaxia Andrómeda siguen un patrón de crecimiento basado en la secuencia de Fibonacci. Necesitas generar esta secuencia usando diferentes tipos de bucles para estudiar su comportamiento.\n\n**Objetivos:**\n- Implementa la secuencia de Fibonacci usando bucle for\n- Crea una versión con bucle while\n- Compara el rendimiento de ambas implementaciones\n- Genera los primeros 15 términos de la secuencia\n\n**Datos de los cristales:**\n- Secuencia inicial: 0, 1\n- Patrón: cada término = suma de los dos anteriores\n- Términos a generar: 15\n\n? ¡Estos cristales podrían ser la clave para viajes intergalácticos!',NULL,3,0,3,350,0,'print(\"? === SIMULADOR DE ÓRBITAS PLANETARIAS ===\")\nimport math\n\n# TODO: Implementar cálculos orbitales\nclass SimuladorOrbital:\n    def __init__(self):\n        self.G = 6.67430e-11  # Constante gravitacional\n    \n    # TODO: Calcular velocidad orbital\n    def calcular_velocidad_orbital(self, masa_central, radio_orbital):\n        # v = sqrt(GM/r)\n        pass\n    \n    # TODO: Calcular período orbital\n    def calcular_periodo_orbital(self, masa_central, radio_orbital):\n        # T = 2π * sqrt(r³/GM)\n        pass\n    \n    # TODO: Simular posición en órbita\n    def calcular_posicion(self, radio, angulo):\n        # Convertir coordenadas polares a cartesianas\n        pass\n    \n    # TODO: Simular múltiples órbitas\n    def simular_sistema(self, planetas, tiempo_simulacion):\n        # Simular movimiento de múltiples planetas\n        pass\n\n# Datos del sistema solar simplificado\nplanetas = [\n    {\"nombre\": \"Mercurio\", \"radio_orbital\": 5.79e10, \"masa_central\": 1.989e30},\n    {\"nombre\": \"Venus\", \"radio_orbital\": 1.082e11, \"masa_central\": 1.989e30},\n    {\"nombre\": \"Tierra\", \"radio_orbital\": 1.496e11, \"masa_central\": 1.989e30},\n    {\"nombre\": \"Marte\", \"radio_orbital\": 2.279e11, \"masa_central\": 1.989e30}\n]\n\nsimulador = SimuladorOrbital()\n\nprint(\"? Calculando parámetros orbitales:\")\nfor planeta in planetas:\n    velocidad = simulador.calcular_velocidad_orbital(\n        planeta[\"masa_central\"], planeta[\"radio_orbital\"]\n    )\n    periodo = simulador.calcular_periodo_orbital(\n        planeta[\"masa_central\"], planeta[\"radio_orbital\"]\n    )\n    \n    print(f\"\n? {planeta[nombre]}:\")\n    print(f\"  ? Velocidad orbital: {velocidad/1000:.2f} km/s\")\n    print(f\"  ⏰ Período orbital: {periodo/(24*3600):.1f} días\")\n\nprint(\"\n? Simulando órbitas...\")\n# TODO: Ejecutar simulación temporal\nresultado = simulador.simular_sistema(planetas, 365)\n\nprint(\"\n? Simulación orbital completada\")','? === GENERADOR DE SECUENCIA FIBONACCI GALÁCTICA ===\n? Generando 15 términos de cristales energéticos\n\n? Método 1: Bucle FOR\nCristal 0: 0 unidades\nCristal 1: 1 unidades\nCristal 2: 1 unidades\nCristal 3: 2 unidades\nCristal 4: 3 unidades\nCristal 5: 5 unidades\nCristal 6: 8 unidades\nCristal 7: 13 unidades\nCristal 8: 21 unidades\nCristal 9: 34 unidades\nCristal 10: 55 unidades\nCristal 11: 89 unidades\nCristal 12: 144 unidades\nCristal 13: 233 unidades\nCristal 14: 377 unidades\n\n? Método 2: Bucle WHILE\nCristal 0: 0 unidades\nCristal 1: 1 unidades\nCristal 2: 1 unidades\nCristal 3: 2 unidades\nCristal 4: 3 unidades\nCristal 5: 5 unidades\nCristal 6: 8 unidades\nCristal 7: 13 unidades\nCristal 8: 21 unidades\nCristal 9: 34 unidades\nCristal 10: 55 unidades\nCristal 11: 89 unidades\nCristal 12: 144 unidades\nCristal 13: 233 unidades\nCristal 14: 377 unidades\n\n? Análisis de cristales:\n? Secuencia FOR: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n? Secuencia WHILE: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n✅ Secuencias idénticas: true\n\n? Cristal más grande: 377 unidades de energía','Simulador de Órbitas Complejas'),(12,4,3,'? OPTIMIZADOR DE RUTAS COMERCIALES GALÁCTICAS ?\n\nImplementa un algoritmo de optimización que use bucles anidados para resolver el problema del viajante comercial espacial. El sistema debe encontrar la ruta más eficiente para visitar todas las estaciones comerciales de la galaxia, minimizando el consumo de combustible cuántico y el tiempo de viaje entre planetas.',NULL,5,0,5,800,0,'print(\"? === EXPLORADOR DE GALAXIAS INFINITAS ===\")\n\n# TODO: Implementar exploración sistemática\nclass ExploradorGalactico:\n    def __init__(self, radio_exploracion=1000):\n        self.radio_exploracion = radio_exploracion\n        self.sectores_explorados = set()\n        self.descubrimientos = []\n    \n    # TODO: Generar coordenadas de exploración\n    def generar_coordenadas_exploracion(self, centro, num_sectores):\n        # Generar coordenadas en espiral o patrón sistemático\n        pass\n    \n    # TODO: Explorar sector\n    def explorar_sector(self, coordenadas):\n        # Simular exploración y posibles descubrimientos\n        pass\n    \n    # TODO: Analizar descubrimiento\n    def analizar_descubrimiento(self, tipo_objeto):\n        # Clasificar y evaluar importancia del descubrimiento\n        pass\n    \n    # TODO: Optimizar ruta de exploración\n    def optimizar_ruta(self, sectores_objetivo):\n        # Calcular ruta más eficiente\n        pass\n\n# Configuración de la misión\ncentro_galaxia = {\"x\": 0, \"y\": 0, \"z\": 0}\nnum_sectores_explorar = 50\n\nexplorador = ExploradorGalactico()\n\nprint(\"? Iniciando misión de exploración galáctica:\")\nprint(f\"? Centro de exploración: {centro_galaxia}\")\nprint(f\"? Sectores objetivo: {num_sectores_explorar}\")\n\n# TODO: Generar plan de exploración\ncoordenadas = explorador.generar_coordenadas_exploracion(centro_galaxia, num_sectores_explorar)\nruta_optimizada = explorador.optimizar_ruta(coordenadas)\n\nprint(\"\n? Ejecutando exploración:\")\nfor i, sector in enumerate(ruta_optimizada[:10]):  # Primeros 10 sectores\n    resultado = explorador.explorar_sector(sector)\n    if resultado:\n        analisis = explorador.analizar_descubrimiento(resultado[\"tipo\"])\n        print(f\"✨ Sector {i+1}: {resultado[tipo]} - {analisis[importancia]}\")\n    else:\n        print(f\"? Sector {i+1}: Espacio vacío\")\n\nprint(f\"\n? Resumen de exploración:\")\nprint(f\"? Sectores explorados: {len(explorador.sectores_explorados)}\")\nprint(f\"✨ Descubrimientos: {len(explorador.descubrimientos)}\")\nprint(\"\n? Exploración galáctica en progreso\")','? === OPTIMIZADOR DE RUTAS GALÁCTICAS ===\n\n?️ Estaciones comerciales registradas:\n1. Terra Nova (0, 0)\n2. Marte Central (3, 4)\n3. Europa Station (6, 1)\n4. Titan Base (2, 7)\n5. Kepler Hub (8, 3)\n\n? Calculando ruta óptima...\n\n? Ruta óptima encontrada:\n? Distancia total: 23.85 años luz\n? Optimización completada','Simulación de N-Cuerpos Gravitacionales'),(13,5,1,'? **Misión: Calculadora de Área Planetaria**\n\nComo cartógrafo espacial de AstroCode, debes crear una función para calcular el área de planetas circulares que descubra tu nave durante la exploración.\n\n**Contexto de la misión:**\nTu nave ha descubierto un nuevo planeta con forma circular. Para determinar su habitabilidad, necesitas calcular su área superficial usando su radio.\n\n**Objetivos:**\n- Crea una función que calcule el área de un círculo\n- La función debe recibir el radio como parámetro\n- Debe retornar el área calculada\n- Usa la fórmula: π × radio²\n\n**Datos del planeta:**\n- Radio: 6371 km (similar a la Tierra)\n- π ≈ 3.14159\n\n? ¡Cada nuevo mundo es una oportunidad para la humanidad!',NULL,3,0,1,150,0,'print(\"? === CALCULADORA DE DISTANCIAS ESTELARES ===\")\nimport math\n\n# TODO: Implementar cálculos de distancia\ndef calcular_distancia_euclidiana(punto1, punto2):\n    # Calcular distancia en 3D\n    pass\n\ndef calcular_distancia_manhattan(punto1, punto2):\n    # Calcular distancia Manhattan\n    pass\n\ndef calcular_distancia_minkowski(punto1, punto2, p=2):\n    # Calcular distancia Minkowski generalizada\n    pass\n\ndef convertir_años_luz_a_km(años_luz):\n    # 1 año luz = 9.461e12 km\n    pass\n\ndef convertir_parsecs_a_años_luz(parsecs):\n    # 1 parsec = 3.26156 años luz\n    pass\n\n# Coordenadas de estrellas (x, y, z en años luz)\nestrellas = {\n    \"Sol\": (0, 0, 0),\n    \"Proxima Centauri\": (4.24, 0, 0),\n    \"Sirius\": (8.6, 0, 0),\n    \"Vega\": (25, 0, 0),\n    \"Betelgeuse\": (640, 0, 0)\n}\n\nprint(\"? Calculando distancias entre estrellas:\")\nfor nombre1, coord1 in estrellas.items():\n    for nombre2, coord2 in estrellas.items():\n        if nombre1 != nombre2:\n            distancia = calcular_distancia_euclidiana(coord1, coord2)\n            print(f\"? {nombre1} ↔ {nombre2}: {distancia:.2f} años luz\")\n            break  # Solo mostrar una por estrella\n\nprint(\"\n? Cálculos estelares completados\")','? === CALCULADORA DE ÁREA PLANETARIA ===\n? Planeta descubierto:\n? Radio: 6371 km\n\n? Resultados del análisis:\n? Área superficial: 127516118.49 km²\n\n✅ Análisis planetario completado\n? Datos enviados a la base AstroCode','Calculadora de Distancias Estelares'),(14,5,2,'? **Misión: Sistema de Navegación Intergaláctica**\n\nEl sistema de navegación de tu nave ha detectado múltiples planetas en el sector. Como ingeniero de vuelo, debes crear un sistema de cálculo de distancias para planificar la ruta más eficiente.\n\n**Contexto de la misión:**\nTu nave se encuentra en las coordenadas (0, 0) del espacio. Has detectado varios planetas y necesitas calcular las distancias para determinar cuál visitar primero. El combustible es limitado, así que la eficiencia es crucial.\n\n**Objetivos:**\n- Crea una función que calcule la distancia entre dos puntos en el espacio\n- Implementa una función que determine si un planeta está dentro del rango de combustible\n- Desarrolla una función que encuentre el planeta más cercano\n\n**Fórmula de distancia:** √((x₂-x₁)² + (y₂-y₁)²)\n**Rango máximo:** 50 unidades espaciales\n\n¡La galaxia te espera, comandante! ?',NULL,3,0,3,400,0,'print(\"? === CONVERTIDOR DE UNIDADES ESPACIALES ===\")\n\n# TODO: Implementar sistema de conversiones\nclass ConvertidorEspacial:\n    def __init__(self):\n        # Factores de conversión\n        self.factores = {\n            \"km_a_millas\": 0.621371,\n            \"años_luz_a_km\": 9.461e12,\n            \"parsec_a_años_luz\": 3.26156,\n            \"ua_a_km\": 149597870.7,\n            \"kg_a_masas_solares\": 1 / 1.989e30\n        }\n    \n    # TODO: Convertir distancias\n    def convertir_distancia(self, valor, unidad_origen, unidad_destino):\n        # Implementar conversiones de distancia\n        pass\n    \n    # TODO: Convertir masas\n    def convertir_masa(self, valor, unidad_origen, unidad_destino):\n        # Implementar conversiones de masa\n        pass\n    \n    # TODO: Convertir velocidades\n    def convertir_velocidad(self, valor, unidad_origen, unidad_destino):\n        # Implementar conversiones de velocidad\n        pass\n    \n    # TODO: Conversión automática\n    def conversion_automatica(self, valor, unidad_origen, unidad_destino):\n        # Detectar tipo y convertir automáticamente\n        pass\n\n# Datos de prueba\nconversiones_prueba = [\n    {\"valor\": 4.24, \"origen\": \"años_luz\", \"destino\": \"km\"},\n    {\"valor\": 1.989e30, \"origen\": \"kg\", \"destino\": \"masas_solares\"},\n    {\"valor\": 299792458, \"origen\": \"m/s\", \"destino\": \"km/h\"},\n    {\"valor\": 1, \"origen\": \"ua\", \"destino\": \"km\"}\n]\n\nconvertidor = ConvertidorEspacial()\n\nprint(\"? Ejecutando conversiones:\")\nfor conversion in conversiones_prueba:\n    resultado = convertidor.conversion_automatica(\n        conversion[\"valor\"], \n        conversion[\"origen\"], \n        conversion[\"destino\"]\n    )\n    print(f\"? {conversion[valor]} {conversion[origen]} = {resultado} {conversion[destino]}\")\n\nprint(\"\n? Conversiones completadas\")','? === SISTEMA DE NAVEGACIÓN INTERGALÁCTICA ===\n? Posición de la nave: (0, 0)\n⛽ Rango máximo: 50 unidades\n\n? Análisis de planetas detectados:\nKepler-442b: 50.00 unidades - ✅ Alcanzable\nProxima-b: 25.00 unidades - ✅ Alcanzable\nTRAPPIST-1e: 100.00 unidades - ❌ Fuera de rango\n\n? Destino recomendado: Proxima-b\n? Coordenadas: (20, 15)','Biblioteca de Funciones Astronómicas'),(15,5,3,'⚡ SISTEMA DE FUNCIONES CUÁNTICAS AVANZADAS ⚡\n\nDesarrolla un sistema avanzado de funciones de orden superior para el procesamiento de datos cuánticos de AstroCode. Implementa map(), filter(), reduce() y permite el encadenamiento de operaciones para analizar grandes volúmenes de datos de sensores espaciales, detectar anomalías y procesar señales de civilizaciones extraterrestres.',NULL,5,0,5,900,0,'print(\"? === GENERADOR DE COORDENADAS GALÁCTICAS ===\")\nimport random\nimport math\n\n# TODO: Implementar generador de coordenadas\nclass GeneradorCoordenadas:\n    def __init__(self, semilla=None):\n        if semilla:\n            random.seed(semilla)\n    \n    # TODO: Generar coordenadas esféricas\n    def generar_esfericas(self, radio_min=0, radio_max=1000):\n        # Generar (r, θ, φ) en coordenadas esféricas\n        pass\n    \n    # TODO: Convertir esféricas a cartesianas\n    def esferas_a_cartesianas(self, r, theta, phi):\n        # Convertir (r, θ, φ) a (x, y, z)\n        pass\n    \n    # TODO: Generar coordenadas en galaxia espiral\n    def generar_galaxia_espiral(self, num_brazos=4, num_puntos=1000):\n        # Generar puntos siguiendo patrón espiral\n        pass\n    \n    # TODO: Generar cluster estelar\n    def generar_cluster(self, centro, radio, densidad):\n        # Generar cluster con distribución gaussiana\n        pass\n    \n    # TODO: Validar coordenadas\n    def validar_coordenadas(self, coordenadas):\n        # Verificar que las coordenadas sean válidas\n        pass\n\n# Configuración del generador\ngenerador = GeneradorCoordenadas(semilla=42)\n\nprint(\"? Generando mapa galáctico:\")\n\n# TODO: Generar diferentes tipos de objetos\nprint(\"\n⭐ Generando estrellas individuales:\")\nfor i in range(5):\n    coords_esfericas = generador.generar_esfericas(10, 1000)\n    coords_cartesianas = generador.esferas_a_cartesianas(*coords_esfericas)\n    print(f\"Estrella {i+1}: {coords_cartesianas}\")\n\nprint(\"\n? Generando galaxia espiral:\")\ngalaxia = generador.generar_galaxia_espiral(4, 100)\nprint(f\"Galaxia generada con {len(galaxia)} estrellas\")\n\nprint(\"\n⭐ Generando cluster estelar:\")\ncentro_cluster = (500, 300, 100)\ncluster = generador.generar_cluster(centro_cluster, 50, 0.8)\nprint(f\"Cluster generado con {len(cluster)} estrellas\")\n\nprint(\"\n? Mapa galáctico completado\")','⚡ === SISTEMA DE FUNCIONES CUÁNTICAS ===\n\n? Procesando datos de sensores:\n\n? Análisis de temperatura:\nAlpha: 228.15 K\nBeta: 295.15 K\nGamma: 261.15 K\nDelta: 340.15 K\n\n? Sectores con radiación alta:\nGamma: 0.8 radiación\n\n? Promedio de señales por sector:\nAlpha: 1.80\nBeta: 2.73\nGamma: 2.97\nDelta: 3.27\n\n? Análisis encadenado:\nSectores habitables con señales fuertes: Beta, Delta\n\n⚡ Procesamiento cuántico completado','Sistema de Funciones de Orden Superior'),(16,6,1,'? **Misión: Análisis de Datos de Sensores**\n\nComo analista de datos de la estación AstroCode, debes procesar las lecturas de 5 sensores de radiación para determinar las condiciones de seguridad del sector.\n\n**Contexto de la misión:**\nTu nave ha recopilado datos de radiación de diferentes puntos del sector. Necesitas analizar estos datos para encontrar los valores extremos y calcular el promedio para determinar si es seguro continuar.\n\n**Objetivos:**\n- Crea un array con 5 lecturas de sensores\n- Encuentra el valor mayor y menor\n- Calcula el promedio de todas las lecturas\n- Determina si el sector es seguro (promedio < 50)\n\n**Lecturas de sensores:** [23, 45, 12, 67, 34]\n**Límite de seguridad:** 50 unidades de radiación\n\n☢️ ¡La seguridad de la tripulación es prioritaria!',NULL,3,0,2,200,0,'print(\"? === SISTEMA DE INVENTARIO ESPACIAL ===\")\\n\\n# TODO: Implementar sistema de inventario\\nclass InventarioNave:\\n    def __init__(self, capacidad_maxima=1000):\\n        self.items = []\\n        self.capacidad_maxima = capacidad_maxima\\n        self.peso_actual = 0\\n    \\n    # TODO: Agregar item\\n    def agregar_item(self, item):\\n        # Verificar capacidad y agregar item\\n        pass\\n    \\n    # TODO: Remover item\\n    def remover_item(self, nombre_item, cantidad=1):\\n        # Remover cantidad específica de un item\\n        pass\\n    \\n    # TODO: Buscar items\\n    def buscar_items(self, criterio):\\n        # Buscar items por nombre, categoría, etc.\\n        pass\\n    \\n    # TODO: Organizar inventario\\n    def organizar_por_categoria(self):\\n        # Organizar items por categoría\\n        pass\\n    \\n    # TODO: Verificar recursos críticos\\n    def verificar_recursos_criticos(self):\\n        # Verificar niveles de recursos esenciales\\n        pass\\n    \\n    # TODO: Generar reporte\\n    def generar_reporte(self):\\n        # Generar reporte completo del inventario\\n        pass\\n\\n# Items de ejemplo\\nitems_iniciales = [\\n    {\"nombre\": \"Combustible\", \"cantidad\": 500, \"peso\": 2, \"categoria\": \"Energía\", \"critico\": True},\\n    {\"nombre\": \"Oxígeno\", \"cantidad\": 200, \"peso\": 1, \"categoria\": \"Soporte Vital\", \"critico\": True},\\n    {\"nombre\": \"Comida\", \"cantidad\": 150, \"peso\": 1.5, \"categoria\": \"Suministros\", \"critico\": True},\\n    {\"nombre\": \"Herramientas\", \"cantidad\": 50, \"peso\": 3, \"categoria\": \"Equipamiento\", \"critico\": False},\\n    {\"nombre\": \"Medicinas\", \"cantidad\": 30, \"peso\": 0.5, \"categoria\": \"Médico\", \"critico\": True}\\n]\\n\\n# Crear inventario\\ninventario = InventarioNave(1000)\\n\\nprint(\"? Cargando inventario inicial:\")\\nfor item in items_iniciales:\\n    resultado = inventario.agregar_item(item)\\n    print(f\"{{✅ if resultado else ❌}} {{item[nombre]}}: {{item[cantidad]}} unidades\")\\n\\nprint(\"\\\\n? Estado del inventario:\")\\nreporte = inventario.generar_reporte()\\nprint(reporte)\\n\\nprint(\"\\\\n? Verificando recursos críticos:\")\\ncriticos = inventario.verificar_recursos_criticos()\\nfor recurso in criticos:\\n    print(f\"⚠️ {{recurso[nombre]}}: {{recurso[nivel]}} - {{recurso[estado]}}\")\\n\\nprint(\"\\\\n? Sistema de inventario operativo\")','? === ANÁLISIS DE DATOS DE SENSORES ===\n☢️ Lecturas de radiación: [23, 45, 12, 67, 34]\n?️ Límite de seguridad: 50 unidades\n\n? Resultados del análisis:\n? Lectura máxima: 67 unidades\n? Lectura mínima: 12 unidades\n? Promedio: 36.20 unidades\n\n✅ SECTOR SEGURO - Continuar exploración','Inventario de Nave Espacial'),(17,6,2,'?️ **Misión: Inventario de Recursos Espaciales**\n\nComo administrador de recursos de AstroCode, debes gestionar el inventario de suministros de múltiples estaciones espaciales. El sistema debe procesar, filtrar y organizar grandes cantidades de datos de recursos.\n\n**Contexto de la misión:**\nTienes datos de inventario de 5 estaciones espaciales diferentes. Necesitas crear un sistema que pueda filtrar recursos por tipo, calcular totales, encontrar escasez y generar reportes consolidados.\n\n**Objetivos:**\n- Manipula arrays multidimensionales de inventarios\n- Implementa filtros por categoría y cantidad\n- Calcula estadísticas de recursos\n- Identifica estaciones con escasez crítica\n\n**Tipos de recursos:**\n- Combustible, Oxígeno, Alimentos, Medicinas, Repuestos\n- Umbral crítico: < 100 unidades\n\n? ¡La supervivencia de las estaciones depende de tu gestión!',NULL,3,0,3,250,0,'print(\"? === REGISTRO DE PLANETAS VISITADOS ===\")\nfrom datetime import datetime, timedelta\n\n# TODO: Implementar registro de planetas\nclass RegistroPlanetas:\n    def __init__(self):\n        self.planetas_visitados = []\n        self.planetas_favoritos = []\n        self.estadisticas = {}\n    \n    # TODO: Registrar visita\n    def registrar_visita(self, planeta_info):\n        # Registrar nueva visita a planeta\n        pass\n    \n    # TODO: Marcar como favorito\n    def marcar_favorito(self, nombre_planeta):\n        # Agregar planeta a favoritos\n        pass\n    \n    # TODO: Buscar planetas\n    def buscar_planetas(self, criterio, valor):\n        # Buscar planetas por diferentes criterios\n        pass\n    \n    # TODO: Obtener estadísticas\n    def calcular_estadisticas(self):\n        # Calcular estadísticas de viajes\n        pass\n    \n    # TODO: Generar itinerario\n    def generar_itinerario(self, planetas_objetivo):\n        # Generar ruta óptima para visitar planetas\n        pass\n    \n    # TODO: Exportar registro\n    def exportar_registro(self, formato=\"json\"):\n        # Exportar registro en diferentes formatos\n        pass\n\n# Datos de planetas visitados\nvisitas_ejemplo = [\n    {\n        \"nombre\": \"Kepler-442b\",\n        \"fecha_visita\": datetime.now() - timedelta(days=30),\n        \"duracion_estancia\": 5,\n        \"proposito\": \"Exploración\",\n        \"coordenadas\": {\"x\": 1200, \"y\": 800, \"z\": 300},\n        \"habitabilidad\": 8.5,\n        \"recursos\": [\"agua\", \"minerales\", \"atmósfera\"]\n    },\n    {\n        \"nombre\": \"Proxima Centauri b\",\n        \"fecha_visita\": datetime.now() - timedelta(days=15),\n        \"duracion_estancia\": 3,\n        \"proposito\": \"Investigación\",\n        \"coordenadas\": {\"x\": 4.24, \"y\": 0, \"z\": 0},\n        \"habitabilidad\": 6.2,\n        \"recursos\": [\"minerales\", \"radiación\"]\n    }\n]\n\n# Crear registro\nregistro = RegistroPlanetas()\n\nprint(\"? Cargando historial de viajes:\")\nfor visita in visitas_ejemplo:\n    registro.registrar_visita(visita)\n    print(f\"? {visita[nombre]} - {visita[fecha_visita].strftime(%Y-%m-%d)}\")\n\nprint(\"\n⭐ Marcando planetas favoritos:\")\nregistro.marcar_favorito(\"Kepler-442b\")\nprint(\"✅ Kepler-442b agregado a favoritos\")\n\nprint(\"\n? Estadísticas de viaje:\")\nestadisticas = registro.calcular_estadisticas()\nprint(f\"? Planetas visitados: {estadisticas.get(total_planetas, 0)}\")\nprint(f\"? Días totales de viaje: {estadisticas.get(dias_totales, 0)}\")\nprint(f\"⭐ Planetas favoritos: {len(registro.planetas_favoritos)}\")\n\nprint(\"\n? Registro planetario actualizado\")','?️ === INVENTARIO DE RECURSOS ESPACIALES ===\n? Análisis de inventario:\nCombustible: 450 unidades totales\nOxígeno: 330 unidades totales\nAlimentos: 380 unidades totales\nMedicinas: 140 unidades totales\nRepuestos: 280 unidades totales\n\n? Recursos en escasez crítica: 2\n⚠️ Estación Alpha - Oxígeno: 80 unidades\n⚠️ Estación Alpha - Medicinas: 50 unidades','Matriz de Coordenadas Espaciales'),(18,6,3,'? ARRAY DINÁMICO DE COMUNICACIONES ESPACIALES ?\n\nCrea una implementación eficiente de un array dinámico para el sistema de comunicaciones de AstroCode. El array debe redimensionarse automáticamente para manejar el flujo variable de mensajes interplanetarios, mantener un factor de carga óptimo para minimizar la latencia, y optimizar el uso de memoria en el espacio limitado de la nave.',NULL,4,0,5,500,0,'print(\"? === SIMULADOR DE ÓRBITAS PLANETARIAS ===\")\nimport math\n\n# TODO: Implementar simulador de órbitas\nclass SimuladorOrbitas:\n    def __init__(self):\n        self.G = 6.67430e-11  # Constante gravitacional\n        self.cuerpos_celestes = []\n        self.tiempo_simulacion = 0\n    \n    # TODO: Agregar cuerpo celeste\n    def agregar_cuerpo(self, nombre, masa, posicion, velocidad):\n        # Agregar planeta, luna o asteroide\n        pass\n    \n    # TODO: Calcular fuerza gravitacional\n    def calcular_fuerza_gravitacional(self, cuerpo1, cuerpo2):\n        # F = G * m1 * m2 / r²\n        pass\n    \n    # TODO: Actualizar posiciones\n    def actualizar_posiciones(self, dt):\n        # Integración numérica de las ecuaciones de movimiento\n        pass\n    \n    # TODO: Verificar colisiones\n    def verificar_colisiones(self):\n        # Detectar si dos cuerpos colisionan\n        pass\n    \n    # TODO: Simular período\n    def simular_periodo(self, duracion, pasos):\n        # Simular órbita durante un período específico\n        pass\n\n# Configuración del sistema solar simplificado\nsimulador = SimuladorOrbitas()\n\n# Agregar Sol\nsimulador.agregar_cuerpo(\n    \"Sol\", \n    masa=1.989e30, \n    posicion=(0, 0, 0), \n    velocidad=(0, 0, 0)\n)\n\n# Agregar Tierra\nsimulador.agregar_cuerpo(\n    \"Tierra\", \n    masa=5.972e24, \n    posicion=(149597870700, 0, 0),  # 1 UA\n    velocidad=(0, 29780, 0)  # Velocidad orbital\n)\n\nprint(\"? Sistema solar configurado\")\nprint(\"? Iniciando simulación orbital...\")\n\n# Simular un año terrestre\nresultados = simulador.simular_periodo(365 * 24 * 3600, 1000)\n\nprint(f\"? Simulación completada: {len(resultados)} puntos calculados\")\nprint(\"? Órbitas calculadas exitosamente\")','? === ARRAY DINÁMICO DE COMUNICACIONES ===\n\n? Procesando mensajes interplanetarios:\n1. Terra → Marte: Suministros en camino\n   ? Capacidad: 4, Uso: 25.0%\n2. Luna → Europa: Misión completada\n   ? Capacidad: 4, Uso: 50.0%\n3. Titan → Terra: Anomalía detectada\n   ? Capacidad: 4, Uso: 75.0%\n4. Marte → Kepler: Colonos listos\n   ? Capacidad: 8, Uso: 50.0%\n5. Europa → Luna: Datos científicos\n   ? Capacidad: 8, Uso: 62.5%\n\n? Pruebas de eliminación y compactación:\n❌ Eliminando mensaje 2\n? Capacidad reducida: 8 → 4\n✅ Factor de carga optimizado: 75.0%\n\n? Sistema de comunicaciones optimizado','Tensor Multidimensional Espacial'),(19,7,1,'? **Misión: Registro de Nave Espacial**\n\nComo administrador de flota de AstroCode, debes crear un sistema de registro para las naves espaciales usando objetos para almacenar su información.\n\n**Contexto de la misión:**\nLa flota de AstroCode está creciendo y necesitas un sistema para registrar y mostrar la información de cada nave. Cada nave tiene propiedades específicas que deben ser almacenadas.\n\n**Objetivos:**\n- Crea un objeto que represente una nave espacial\n- El objeto debe tener propiedades: nombre, tipo, tripulacion, combustible\n- Muestra la información de la nave\n- Accede a propiedades específicas del objeto\n\n**Datos de la nave:**\n- Nombre: \"Estrella Polar\"\n- Tipo: \"Explorador\"\n- Tripulación: 5\n- Combustible: 750\n\n? ¡Organizar la flota es clave para el éxito de las misiones!',NULL,3,0,2,250,0,'print(\"⛽ === CALCULADORA DE COMBUSTIBLE ESPACIAL ===\")\n\n# TODO: Implementar calculadora de combustible\nclass CalculadoraCombustible:\n    def __init__(self):\n        # Eficiencias de diferentes tipos de propulsión\n        self.eficiencias = {\n            \"quimico\": 450,      # Impulso específico (s)\n            \"ionico\": 3000,      # Impulso específico (s)\n            \"nuclear\": 900,      # Impulso específico (s)\n            \"fusion\": 10000      # Impulso específico (s)\n        }\n        self.g0 = 9.80665  # Aceleración gravitacional estándar\n    \n    # TODO: Calcular delta-v requerido\n    def calcular_delta_v(self, masa_inicial, masa_final, ve):\n        # Ecuación del cohete de Tsiolkovsky\n        # Δv = ve * ln(m0/mf)\n        pass\n    \n    # TODO: Calcular combustible necesario\n    def calcular_combustible_necesario(self, masa_nave, delta_v_objetivo, tipo_propulsion):\n        # Calcular masa de combustible requerida\n        pass\n    \n    # TODO: Optimizar trayectoria\n    def optimizar_trayectoria(self, origen, destino, masa_nave):\n        # Encontrar la trayectoria más eficiente\n        pass\n    \n    # TODO: Calcular tiempo de viaje\n    def calcular_tiempo_viaje(self, distancia, aceleracion_continua):\n        # Calcular tiempo con aceleración constante\n        pass\n    \n    # TODO: Análisis de eficiencia\n    def analizar_eficiencia(self, mision_params):\n        # Comparar diferentes tipos de propulsión\n        pass\n\n# Parámetros de misión\nmisiones = [\n    {\n        \"nombre\": \"Viaje a Marte\",\n        \"distancia\": 225e9,  # metros\n        \"masa_nave\": 50000,  # kg\n        \"delta_v_requerido\": 12000  # m/s\n    },\n    {\n        \"nombre\": \"Misión a Europa\",\n        \"distancia\": 628e9,  # metros\n        \"masa_nave\": 30000,  # kg\n        \"delta_v_requerido\": 15000  # m/s\n    }\n]\n\ncalculadora = CalculadoraCombustible()\n\nprint(\"? Analizando misiones espaciales:\")\nfor mision in misiones:\n    print(f\"\n? {mision[nombre]}:\")\n    \n    # Analizar cada tipo de propulsión\n    for tipo, isp in calculadora.eficiencias.items():\n        combustible = calculadora.calcular_combustible_necesario(\n            mision[\"masa_nave\"], \n            mision[\"delta_v_requerido\"], \n            tipo\n        )\n        tiempo = calculadora.calcular_tiempo_viaje(\n            mision[\"distancia\"], \n            10  # 10 m/s² aceleración\n        )\n        \n        print(f\"  ? {tipo.capitalize()}:\")\n        print(f\"    ⛽ Combustible: {combustible:,.0f} kg\")\n        print(f\"    ⏱️ Tiempo estimado: {tiempo:.1f} días\")\n\nprint(\"\n⛽ Análisis de combustible completado\")','? === REGISTRO DE NAVE ESPACIAL ===\n? Información de la nave:\n? Nombre: Estrella Polar\n? Tipo: Explorador\n? Tripulación: 5 personas\n⛽ Combustible: 750 litros\n\n✅ Nave registrada en la flota AstroCode','Clase Astronauta'),(20,7,2,'? **Misión: Sistema de Gestión de Naves Espaciales**\n\nComo ingeniero jefe de AstroCode, debes diseñar un sistema orientado a objetos para gestionar la flota de naves espaciales. Cada nave tiene características únicas y debe poder realizar operaciones específicas.\n\n**Contexto de la misión:**\nLa flota de AstroCode está creciendo rápidamente. Necesitas un sistema que permita crear diferentes tipos de naves, gestionar sus recursos, y simular operaciones de vuelo de manera eficiente.\n\n**Objetivos:**\n- Crea una clase base \"Nave\" con propiedades y métodos comunes\n- Implementa clases derivadas para diferentes tipos de naves\n- Gestiona combustible, escudos y sistemas de navegación\n- Simula operaciones de vuelo y combate\n\n**Tipos de naves:**\n- Explorador: Rápido, poco armamento\n- Carguero: Lento, gran capacidad\n- Militar: Equilibrado, bien armado\n\n⚔️ ¡El futuro de la galaxia está en tus manos!',NULL,3,0,4,250,0,'print(\"☄️ === SISTEMA DE DETECCIÓN DE ASTEROIDES ===\")\nimport random\nimport math\nfrom datetime import datetime, timedelta\n\n# TODO: Implementar detector de asteroides\nclass DetectorAsteroides:\n    def __init__(self, rango_deteccion=1000000):\n        self.rango_deteccion = rango_deteccion  # km\n        self.asteroides_detectados = []\n        self.alertas_activas = []\n    \n    # TODO: Escanear espacio\n    def escanear_espacio(self, coordenadas_nave):\n        # Buscar asteroides en el rango de detección\n        pass\n    \n    # TODO: Clasificar asteroide\n    def clasificar_asteroide(self, asteroide):\n        # Clasificar por tamaño, composición y peligrosidad\n        pass\n    \n    # TODO: Calcular trayectoria\n    def calcular_trayectoria(self, asteroide):\n        # Predecir la trayectoria del asteroide\n        pass\n    \n    # TODO: Evaluar riesgo de colisión\n    def evaluar_riesgo_colision(self, asteroide, coordenadas_nave):\n        # Calcular probabilidad de impacto\n        pass\n    \n    # TODO: Generar alerta\n    def generar_alerta(self, asteroide, nivel_riesgo):\n        # Crear alerta de seguridad\n        pass\n    \n    # TODO: Recomendar maniobra evasiva\n    def recomendar_maniobra_evasiva(self, asteroide, coordenadas_nave):\n        # Sugerir cambio de curso\n        pass\n\n# Configuración del detector\ndetector = DetectorAsteroides(rango_deteccion=500000)\ncoordenadas_nave = {\"x\": 100000, \"y\": 50000, \"z\": 25000}\n\nprint(\"?️ Iniciando escaneo del espacio...\")\n\n# Simular detección de asteroides\nasteroides_simulados = [\n    {\n        \"id\": \"AST-001\",\n        \"posicion\": {\"x\": 120000, \"y\": 60000, \"z\": 30000},\n        \"velocidad\": {\"vx\": -500, \"vy\": 200, \"vz\": -100},\n        \"tamaño\": 150,  # metros\n        \"composicion\": \"rocoso\"\n    },\n    {\n        \"id\": \"AST-002\",\n        \"posicion\": {\"x\": 95000, \"y\": 48000, \"z\": 22000},\n        \"velocidad\": {\"vx\": -800, \"vy\": -300, \"vz\": 50},\n        \"tamaño\": 75,   # metros\n        \"composicion\": \"metalico\"\n    }\n]\n\nprint(\"☄️ Asteroides detectados:\")\nfor asteroide in asteroides_simulados:\n    # Procesar cada asteroide\n    clasificacion = detector.clasificar_asteroide(asteroide)\n    trayectoria = detector.calcular_trayectoria(asteroide)\n    riesgo = detector.evaluar_riesgo_colision(asteroide, coordenadas_nave)\n    \n    print(f\"\n? {asteroide[id]}:\")\n    print(f\"  ? Tamaño: {asteroide[tamaño]} metros\")\n    print(f\"  ? Composición: {asteroide[composicion]}\")\n    print(f\"  ⚠️ Nivel de riesgo: {riesgo}\")\n    \n    if riesgo > 0.3:  # Riesgo alto\n        alerta = detector.generar_alerta(asteroide, riesgo)\n        maniobra = detector.recomendar_maniobra_evasiva(asteroide, coordenadas_nave)\n        print(f\"  ? ALERTA: {alerta}\")\n        print(f\"  ? Maniobra recomendada: {maniobra}\")\n\nprint(\"\n☄️ Escaneo completado - Espacio monitoreado\")','? === SISTEMA DE GESTIÓN DE NAVES ESPACIALES ===\n? Flota de AstroCode inicializada:\nExplorador Discovery - Combustible: 100, Velocidad: 150\nCarguero Titan - Combustible: 200, Velocidad: 80\nMilitar Guardian - Combustible: 150, Velocidad: 120\n\n⚡ Iniciando operaciones:\n? Discovery voló 50 unidades. Combustible restante: 95.0\n? Discovery está escaneando el área...\n? Resultado del escaneo: Planeta habitable detectado','Jerarquía de Vehículos Espaciales'),(21,7,3,'?️ ARQUITECTURA DE PATRONES ESPACIALES ?️\n\nCrea un sistema cohesivo de diseño de patrones para la gestión de naves espaciales en AstroCode. Implementa Factory Pattern para crear diferentes tipos de naves, Observer Pattern para monitorear sistemas críticos, y Strategy Pattern para diferentes modos de vuelo (exploración, combate, comercial). El sistema debe ser extensible y mantenible.',NULL,5,0,5,600,0,'print(\"?️ === MAPA ESTELAR INTERACTIVO ===\")\nimport math\nimport random\n\n# TODO: Implementar mapa estelar\nclass MapaEstelar:\n    def __init__(self, radio_mapa=1000):\n        self.radio_mapa = radio_mapa  # años luz\n        self.estrellas = []\n        self.constelaciones = []\n        self.rutas_navegacion = []\n    \n    # TODO: Generar estrellas\n    def generar_estrellas(self, cantidad=100):\n        # Generar estrellas con propiedades realistas\n        pass\n    \n    # TODO: Crear constelaciones\n    def crear_constelaciones(self):\n        # Agrupar estrellas en constelaciones\n        pass\n    \n    # TODO: Calcular distancias\n    def calcular_distancia_estrellas(self, estrella1, estrella2):\n        # Distancia euclidiana en 3D\n        pass\n    \n    # TODO: Buscar estrella más cercana\n    def encontrar_estrella_cercana(self, posicion, tipo_estrella=None):\n        # Encontrar la estrella más próxima\n        pass\n    \n    # TODO: Planificar ruta\n    def planificar_ruta(self, origen, destino, paradas_maximas=5):\n        # Algoritmo de pathfinding estelar\n        pass\n    \n    # TODO: Filtrar por propiedades\n    def filtrar_estrellas(self, criterios):\n        # Filtrar estrellas por masa, tipo, edad, etc.\n        pass\n    \n    # TODO: Exportar mapa\n    def exportar_mapa(self, formato=\"json\"):\n        # Exportar datos del mapa\n        pass\n\n# Tipos de estrellas\ntipos_estrellas = [\n    {\"tipo\": \"Enana Roja\", \"masa_solar\": 0.3, \"temperatura\": 3500, \"color\": \"rojo\"},\n    {\"tipo\": \"Sol\", \"masa_solar\": 1.0, \"temperatura\": 5778, \"color\": \"amarillo\"},\n    {\"tipo\": \"Gigante Azul\", \"masa_solar\": 15.0, \"temperatura\": 25000, \"color\": \"azul\"},\n    {\"tipo\": \"Enana Blanca\", \"masa_solar\": 0.6, \"temperatura\": 50000, \"color\": \"blanco\"}\n]\n\n# Crear mapa\nmapa = MapaEstelar(radio_mapa=500)\n\nprint(\"? Generando mapa estelar...\")\nmapa.generar_estrellas(50)\nprint(f\"✅ {len(mapa.estrellas)} estrellas generadas\")\n\nprint(\"\n? Creando constelaciones...\")\nmapa.crear_constelaciones()\nprint(f\"✅ {len(mapa.constelaciones)} constelaciones identificadas\")\n\nprint(\"\n? Funciones de navegación:\")\n\n# Buscar estrella cercana\nposicion_actual = {\"x\": 0, \"y\": 0, \"z\": 0}\nestrella_cercana = mapa.encontrar_estrella_cercana(posicion_actual, \"Sol\")\nif estrella_cercana:\n    distancia = mapa.calcular_distancia_estrellas(posicion_actual, estrella_cercana)\n    print(f\"⭐ Estrella más cercana: {estrella_cercana[nombre]} ({distancia:.2f} años luz)\")\n\n# Planificar ruta\norigen = {\"x\": 0, \"y\": 0, \"z\": 0}\ndestino = {\"x\": 100, \"y\": 50, \"z\": 25}\nruta = mapa.planificar_ruta(origen, destino)\nif ruta:\n    print(f\"?️ Ruta calculada: {len(ruta)} paradas\")\n    for i, parada in enumerate(ruta):\n        print(f\"  {i+1}. {parada[nombre]} - {parada[tipo]}\")\n\nprint(\"\n?️ Mapa estelar listo para navegación\")','?️ === ARQUITECTURA DE PATRONES ESPACIALES ===\n\n? Creando flota espacial:\n✅ Discovery (exploracion) creada y configurada\n✅ Defender (combate) creada y configurada\n✅ Trader (comercial) creada y configurada\n\n? Probando cambios de estrategia:\n? Discovery cambia a modo exploración\n⚔️ Defender cambia a modo combate\n? Trader cambia a modo comercial\n? Monitor detecta: Discovery inicia exploración\n? Monitor detecta: Defender activa sistemas de combate\n? Monitor detecta: Trader optimiza rutas comerciales\n\n?️ Arquitectura de patrones implementada','Arquitectura de Microservicios Espaciales'),(22,8,1,'? **Misión: Ordenamiento de Coordenadas Estelares**\n\nComo navegante espacial de AstroCode, debes ordenar las coordenadas de las estrellas detectadas para planificar la ruta de exploración más eficiente.\n\n**Contexto de la misión:**\nTu nave ha detectado varias estrellas en el sector. Para optimizar el combustible, necesitas ordenar sus coordenadas X de menor a mayor para seguir una ruta secuencial.\n\n**Objetivos:**\n- Implementa el algoritmo de ordenamiento burbuja\n- Ordena un array de coordenadas de menor a mayor\n- Muestra el array antes y después del ordenamiento\n- Cuenta el número de intercambios realizados\n\n**Coordenadas detectadas:** [64, 23, 89, 12, 45]\n\n⭐ ¡Una ruta ordenada significa menos combustible gastado!',NULL,3,0,2,300,0,'print(\"? === SISTEMA DE COMUNICACIONES ESPACIALES ===\")\nimport time\nimport random\n\n# TODO: Implementar sistema de comunicaciones\nclass SistemaComunicaciones:\n    def __init__(self):\n        self.canales_activos = []\n        self.mensajes_pendientes = []\n        self.estaciones_base = []\n        self.latencia_base = 0.3  # segundos\n    \n    # TODO: Establecer comunicación\n    def establecer_comunicacion(self, destino, protocolo=\"estandar\"):\n        # Establecer canal de comunicación\n        pass\n    \n    # TODO: Enviar mensaje\n    def enviar_mensaje(self, mensaje, destino, prioridad=\"normal\"):\n        # Enviar mensaje con gestión de prioridades\n        pass\n    \n    # TODO: Recibir mensaje\n    def recibir_mensajes(self):\n        # Procesar mensajes entrantes\n        pass\n    \n    # TODO: Calcular latencia\n    def calcular_latencia(self, distancia_km):\n        # Latencia basada en distancia (velocidad de la luz)\n        pass\n    \n    # TODO: Gestionar interferencias\n    def gestionar_interferencias(self, nivel_interferencia):\n        # Compensar interferencias electromagnéticas\n        pass\n\n# Configuración del sistema\nsistema_com = SistemaComunicaciones()\n\n# Estaciones base\nestaciones = [\n    {\"nombre\": \"Tierra-Base\", \"coordenadas\": (0, 0, 0), \"alcance\": 1000000},\n    {\"nombre\": \"Luna-Relay\", \"coordenadas\": (384400, 0, 0), \"alcance\": 500000},\n    {\"nombre\": \"Marte-Outpost\", \"coordenadas\": (225000000, 0, 0), \"alcance\": 300000}\n]\n\nprint(\"? Configurando red de comunicaciones:\")\nfor estacion in estaciones:\n    sistema_com.estaciones_base.append(estacion)\n    print(f\"✅ {estacion[nombre]} - Alcance: {estacion[alcance]:,} km\")\n\n# Simular comunicaciones\nmensajes_prueba = [\n    {\"contenido\": \"Solicitud de actualización orbital\", \"destino\": \"Marte-Outpost\", \"prioridad\": \"alta\"},\n    {\"contenido\": \"Reporte de estado de sistemas\", \"destino\": \"Tierra-Base\", \"prioridad\": \"normal\"},\n    {\"contenido\": \"Alerta de tormenta solar\", \"destino\": \"Luna-Relay\", \"prioridad\": \"critica\"}\n]\n\nprint(\"\n? Enviando mensajes:\")\nfor mensaje in mensajes_prueba:\n    resultado = sistema_com.enviar_mensaje(\n        mensaje[\"contenido\"], \n        mensaje[\"destino\"], \n        mensaje[\"prioridad\"]\n    )\n    print(f\"? {mensaje[destino]}: {mensaje[contenido][:30]}... [{mensaje[prioridad]}]\")\n\nprint(\"\n? Sistema de comunicaciones operativo\")','? === ORDENAMIENTO DE COORDENADAS ESTELARES ===\n⭐ Coordenadas originales: [64, 23, 89, 12, 45]\n? Coordenadas ordenadas: [12, 23, 45, 64, 89]\n? Intercambios realizados: 8\n\n✅ Ruta optimizada - Lista para navegación','Ordenar Planetas por Distancia'),(23,8,2,'? **Misión: Clasificador de Señales Cósmicas**\n\nComo analista de datos de AstroCode, has recibido múltiples señales del espacio profundo. Debes implementar algoritmos de ordenamiento eficientes para clasificar estas señales por frecuencia y prioridad.\n\n**Contexto de la misión:**\nEl radiotelescopio de AstroCode ha captado cientos de señales misteriosas. Algunas podrían ser de civilizaciones extraterrestres. Tu tarea es ordenar estas señales para que el equipo científico pueda analizarlas en orden de importancia.\n\n**Objetivos:**\n- Implementa el algoritmo Bubble Sort para señales pequeñas\n- Desarrolla Quick Sort para conjuntos grandes\n- Compara el rendimiento de ambos algoritmos\n- Ordena por frecuencia y intensidad\n\n**Datos de señales:**\n- Frecuencia: 1.0 - 10.0 GHz\n- Intensidad: 1 - 100 (prioridad)\n- Origen: Coordenadas espaciales\n\n? ¡Podrías ser el primero en detectar vida extraterrestre!',NULL,4,0,4,300,0,'print(\"? === ANALIZADOR DE DATOS ESPACIALES ===\")\nimport statistics\nimport random\nfrom datetime import datetime, timedelta\n\n# TODO: Implementar analizador de datos\nclass AnalizadorDatos:\n    def __init__(self):\n        self.datasets = {}\n        self.resultados_analisis = {}\n        self.alertas_anomalias = []\n    \n    # TODO: Cargar dataset\n    def cargar_dataset(self, nombre, datos, metadatos=None):\n        # Cargar y validar conjunto de datos\n        pass\n    \n    # TODO: Análisis estadístico básico\n    def analisis_estadistico(self, dataset_nombre):\n        # Calcular estadísticas descriptivas\n        pass\n    \n    # TODO: Detectar anomalías\n    def detectar_anomalias(self, dataset_nombre, umbral_desviacion=2.0):\n        # Identificar valores atípicos\n        pass\n    \n    # TODO: Análisis de tendencias\n    def analizar_tendencias(self, dataset_nombre, ventana_tiempo=7):\n        # Identificar patrones temporales\n        pass\n    \n    # TODO: Correlación entre variables\n    def calcular_correlaciones(self, dataset1, dataset2):\n        # Calcular correlación entre datasets\n        pass\n    \n    # TODO: Generar reporte\n    def generar_reporte(self, dataset_nombre):\n        # Crear reporte completo de análisis\n        pass\n\n# Datos de sensores espaciales\ndatos_sensores = {\n    \"temperatura_motor\": [\n        {\"timestamp\": datetime.now() - timedelta(hours=i), \"valor\": 85 + random.gauss(0, 5)}\n        for i in range(24, 0, -1)\n    ],\n    \"presion_combustible\": [\n        {\"timestamp\": datetime.now() - timedelta(hours=i), \"valor\": 150 + random.gauss(0, 10)}\n        for i in range(24, 0, -1)\n    ],\n    \"radiacion_cosmica\": [\n        {\"timestamp\": datetime.now() - timedelta(hours=i), \"valor\": 0.5 + random.gauss(0, 0.1)}\n        for i in range(24, 0, -1)\n    ]\n}\n\n# Crear analizador\nanalizador = AnalizadorDatos()\n\nprint(\"? Cargando datos de sensores:\")\nfor sensor, datos in datos_sensores.items():\n    analizador.cargar_dataset(sensor, datos, {\"unidad\": \"variable\", \"frecuencia\": \"horaria\"})\n    print(f\"✅ {sensor}: {len(datos)} mediciones cargadas\")\n\nprint(\"\n? Ejecutando análisis:\")\nfor sensor in datos_sensores.keys():\n    # Análisis estadístico\n    estadisticas = analizador.analisis_estadistico(sensor)\n    print(f\"\n? {sensor}:\")\n    print(f\"  ? Promedio: {estadisticas.get(promedio, 0):.2f}\")\n    print(f\"  ? Desviación: {estadisticas.get(desviacion, 0):.2f}\")\n    \n    # Detectar anomalías\n    anomalias = analizador.detectar_anomalias(sensor)\n    if anomalias:\n        print(f\"  ⚠️ Anomalías detectadas: {len(anomalias)}\")\n    \n    # Análisis de tendencias\n    tendencia = analizador.analizar_tendencias(sensor)\n    print(f\"  ? Tendencia: {tendencia}\")\n\nprint(\"\n? Análisis de datos completado\")','? === CLASIFICADOR DE SEÑALES CÓSMICAS ===\n? Señales detectadas:\nS001: 4.2 GHz, Intensidad: 85, Origen: Alfa Centauri\nS002: 1.7 GHz, Intensidad: 45, Origen: Vega\nS003: 8.1 GHz, Intensidad: 92, Origen: Proxima\nS004: 3.3 GHz, Intensidad: 67, Origen: Sirius\nS005: 6.8 GHz, Intensidad: 78, Origen: Betelgeuse\nS006: 2.1 GHz, Intensidad: 34, Origen: Rigel\n\n? Ordenando por intensidad (Bubble Sort):\n? Bubble Sort completado con 8 intercambios\n? S006: Intensidad 34 - Rigel\n? S002: Intensidad 45 - Vega\n? S004: Intensidad 67 - Sirius\n\n⚡ Ordenando por frecuencia (Quick Sort):\n? S002: 1.7 GHz - Vega\n? S006: 2.1 GHz - Rigel\n? S004: 3.3 GHz - Sirius','Algoritmo de Ordenamiento Cósmico'),(24,8,3,'? ALGORITMO HÍBRIDO DE CLASIFICACIÓN CÓSMICA ?\n\nDesarrolla un algoritmo de ordenamiento híbrido inteligente para clasificar datos astronómicos masivos en AstroCode. El algoritmo debe combinar múltiples técnicas (QuickSort, MergeSort, HeapSort) y adaptarse automáticamente según las características de los datos: tamaño del dataset, nivel de desorden, y patrones de distribución de estrellas y planetas.',NULL,5,0,5,700,0,'print(\"? === GENERADOR DE MISIONES ESPACIALES ===\")\nimport random\nfrom datetime import datetime, timedelta\n\n# TODO: Implementar generador de misiones\nclass GeneradorMisiones:\n    def __init__(self):\n        self.tipos_mision = [\"exploración\", \"rescate\", \"investigación\", \"transporte\", \"defensa\"]\n        self.dificultades = [\"fácil\", \"medio\", \"difícil\", \"extremo\"]\n        self.objetivos_base = []\n        self.misiones_generadas = []\n    \n    # TODO: Generar misión aleatoria\n    def generar_mision_aleatoria(self, nivel_jugador=1):\n        # Crear misión basada en nivel del jugador\n        pass\n    \n    # TODO: Crear objetivos\n    def crear_objetivos(self, tipo_mision, dificultad):\n        # Generar objetivos específicos para la misión\n        pass\n    \n    # TODO: Calcular recompensas\n    def calcular_recompensas(self, dificultad, objetivos_completados):\n        # Determinar puntos y recursos ganados\n        pass\n    \n    # TODO: Validar misión\n    def validar_mision(self, mision):\n        # Verificar que la misión sea factible\n        pass\n    \n    # TODO: Generar cadena de misiones\n    def generar_cadena_misiones(self, tema, cantidad=3):\n        # Crear serie de misiones relacionadas\n        pass\n\n# Plantillas de misiones\nplantillas_mision = {\n    \"exploración\": {\n        \"descripcion\": \"Explorar sector desconocido {sector}\",\n        \"objetivos\": [\"Escanear {num} planetas\", \"Identificar recursos\", \"Mapear rutas seguras\"],\n        \"recompensa_base\": 100\n    },\n    \"rescate\": {\n        \"descripcion\": \"Rescatar tripulación en {ubicacion}\",\n        \"objetivos\": [\"Localizar nave averiada\", \"Evacuar {num} tripulantes\", \"Reparar sistemas críticos\"],\n        \"recompensa_base\": 150\n    },\n    \"investigación\": {\n        \"descripcion\": \"Investigar anomalía en {ubicacion}\",\n        \"objetivos\": [\"Recolectar {num} muestras\", \"Analizar datos\", \"Reportar hallazgos\"],\n        \"recompensa_base\": 120\n    }\n}\n\n# Crear generador\ngenerador = GeneradorMisiones()\n\nprint(\"? Generando misiones espaciales:\")\n\n# Generar misiones para diferentes niveles\nniveles_jugador = [1, 3, 5, 8, 10]\n\nfor nivel in niveles_jugador:\n    print(f\"\n?‍? Misiones para Nivel {nivel}:\")\n    \n    for i in range(2):  # 2 misiones por nivel\n        mision = generador.generar_mision_aleatoria(nivel)\n        \n        print(f\"\n  ? Misión {i+1}:\")\n        print(f\"    ? Tipo: {mision.get(tipo, N/A)}\")\n        print(f\"    ? Ubicación: {mision.get(ubicacion, N/A)}\")\n        print(f\"    ⭐ Dificultad: {mision.get(dificultad, N/A)}\")\n        print(f\"    ? Recompensa: {mision.get(recompensa, 0)} puntos\")\n        \n        objetivos = mision.get(objetivos, [])\n        if objetivos:\n            print(f\"    ? Objetivos:\")\n            for j, objetivo in enumerate(objetivos, 1):\n                print(f\"      {j}. {objetivo}\")\n\n# Generar cadena de misiones\nprint(\"\n? Generando cadena de misiones Exploración de Andrómeda:\")\ncadena = generador.generar_cadena_misiones(\"exploración_andromedana\", 3)\n\nfor i, mision in enumerate(cadena, 1):\n    print(f\"\n  ? Capítulo {i}: {mision.get(titulo, Sin título)}\")\n    print(f\"    ? {mision.get(descripcion, Sin descripción)}\")\n\nprint(\"\n? Generador de misiones listo\")','? === ALGORITMO HÍBRIDO DE CLASIFICACIÓN ===\n\n? Datos astronómicos originales:\n1. Proxima Centauri - 4.24 años luz - Mag: 11.13\n2. Kepler-442b - 1200 años luz - Mag: 16.0\n3. Sirius - 8.6 años luz - Mag: -1.46\n4. TRAPPIST-1e - 40 años luz - Mag: 18.8\n5. Vega - 25 años luz - Mag: 0.03\n\n? Ejecutando clasificación híbrida:\n\n? Ordenando por distancia:\n? Análisis: 5 elementos, desorden medio → Usando QuickSort\n⚡ Resultado: Proxima Centauri, Sirius, Vega, TRAPPIST-1e, Kepler-442b\n\n? Ordenando por magnitud:\n? Análisis: 5 elementos, alta varianza → Usando MergeSort\n⚡ Resultado: Sirius, Vega, Proxima Centauri, Kepler-442b, TRAPPIST-1e\n\n? Ordenando por nombre:\n? Análisis: datos textuales → Usando HeapSort\n⚡ Resultado: Kepler-442b, Proxima Centauri, Sirius, TRAPPIST-1e, Vega\n\n? Clasificación cósmica completada','Algoritmo de Ordenamiento Cuántico'),(25,9,1,'? **Misión: Cálculo de Potencia de Reactor**\n\nComo ingeniero de reactores de AstroCode, debes calcular la potencia del reactor usando recursión para determinar si puede alimentar todos los sistemas de la nave.\n\n**Contexto de la misión:**\nEl reactor de la nave genera energía exponencialmente. Necesitas calcular la potencia total usando una función recursiva que simule el proceso de generación de energía.\n\n**Objetivos:**\n- Implementa una función recursiva para calcular potencias\n- Calcula base^exponente usando solo sumas\n- Maneja el caso base (exponente = 0)\n- Muestra el proceso de cálculo\n\n**Datos del reactor:**\n- Base: 3 (unidades de energía)\n- Exponente: 4 (ciclos de amplificación)\n- Resultado esperado: 3^4 = 81\n\n⚡ ¡La recursión simula el proceso natural del reactor!',NULL,3,0,2,350,0,'print(\"? === SISTEMA DE LOGROS ESPACIALES ===\")\nfrom datetime import datetime\n\n# TODO: Implementar sistema de logros\nclass SistemaLogros:\n    def __init__(self):\n        self.logros_disponibles = []\n        self.logros_desbloqueados = []\n        self.progreso_logros = {}\n        self.puntos_totales = 0\n    \n    # TODO: Definir logro\n    def definir_logro(self, logro_info):\n        # Agregar nuevo logro al sistema\n        pass\n    \n    # TODO: Verificar progreso\n    def verificar_progreso(self, accion, valor=1):\n        # Actualizar progreso hacia logros\n        pass\n    \n    # TODO: Desbloquear logro\n    def desbloquear_logro(self, logro_id):\n        # Marcar logro como completado\n        pass\n    \n    # TODO: Calcular puntos\n    def calcular_puntos_totales(self):\n        # Sumar puntos de todos los logros\n        pass\n    \n    # TODO: Obtener estadísticas\n    def obtener_estadisticas(self):\n        # Generar resumen de logros\n        pass\n\n# Definición de logros\nlogros_espaciales = [\n    {\n        \"id\": \"primer_vuelo\",\n        \"nombre\": \"Primer Vuelo\",\n        \"descripcion\": \"Completa tu primera misión espacial\",\n        \"tipo\": \"contador\",\n        \"objetivo\": 1,\n        \"puntos\": 10,\n        \"icono\": \"?\"\n    },\n    {\n        \"id\": \"explorador\",\n        \"nombre\": \"Explorador Galáctico\",\n        \"descripcion\": \"Visita 10 planetas diferentes\",\n        \"tipo\": \"contador\",\n        \"objetivo\": 10,\n        \"puntos\": 50,\n        \"icono\": \"?\"\n    },\n    {\n        \"id\": \"velocista\",\n        \"nombre\": \"Velocista Cósmico\",\n        \"descripcion\": \"Alcanza velocidad de 0.1c\",\n        \"tipo\": \"umbral\",\n        \"objetivo\": 29979245.8,  # m/s\n        \"puntos\": 75,\n        \"icono\": \"⚡\"\n    },\n    {\n        \"id\": \"coleccionista\",\n        \"nombre\": \"Coleccionista de Recursos\",\n        \"descripcion\": \"Recolecta 1000 unidades de minerales\",\n        \"tipo\": \"acumulativo\",\n        \"objetivo\": 1000,\n        \"puntos\": 30,\n        \"icono\": \"?\"\n    },\n    {\n        \"id\": \"superviviente\",\n        \"nombre\": \"Superviviente Espacial\",\n        \"descripcion\": \"Sobrevive 100 días en el espacio\",\n        \"tipo\": \"tiempo\",\n        \"objetivo\": 100,\n        \"puntos\": 100,\n        \"icono\": \"?️\"\n    }\n]\n\n# Crear sistema de logros\nsistema = SistemaLogros()\n\nprint(\"? Configurando sistema de logros:\")\nfor logro in logros_espaciales:\n    sistema.definir_logro(logro)\n    print(f\"✅ {logro[icono]} {logro[nombre]} - {logro[puntos]} puntos\")\n\nprint(\"\n? Simulando progreso del jugador:\")\n\n# Simular acciones del jugador\nacciones_simuladas = [\n    (\"mision_completada\", 1),\n    (\"planeta_visitado\", 3),\n    (\"velocidad_alcanzada\", 15000000),  # m/s\n    (\"mineral_recolectado\", 250),\n    (\"dia_supervivencia\", 25)\n]\n\nfor accion, valor in acciones_simuladas:\n    sistema.verificar_progreso(accion, valor)\n    print(f\"? {accion}: +{valor}\")\n\nprint(\"\n? Estado de logros:\")\nestadisticas = sistema.obtener_estadisticas()\n\nprint(f\"? Logros desbloqueados: {estadisticas.get(desbloqueados, 0)}/{estadisticas.get(total, 0)}\")\nprint(f\"? Puntos totales: {estadisticas.get(puntos, 0)}\")\nprint(f\"? Progreso general: {estadisticas.get(porcentaje, 0):.1f}%\")\n\n# Mostrar logros desbloqueados\nif sistema.logros_desbloqueados:\n    print(\"\n? Logros desbloqueados:\")\n    for logro in sistema.logros_desbloqueados:\n        print(f\"  {logro[icono]} {logro[nombre]} - {logro[puntos]} puntos\")\n\nprint(\"\n? Sistema de logros operativo\")','? === CÁLCULO DE POTENCIA DE REACTOR ===\n⚡ Base de energía: 3 unidades\n? Ciclos de amplificación: 4\n\n? Cálculo: 3^4 = 81\n? Potencia total del reactor: 81 unidades\n\n✅ REACTOR OPERATIVO - Energía suficiente','Factorial de Años Luz'),(26,9,2,'? **Misión: Explorador de Fractales Cósmicos**\n\nComo matemático espacial de AstroCode, has descubierto que las formaciones de asteroides en el cinturón de Kuiper siguen patrones fractales. Debes usar recursión para calcular y visualizar estos patrones complejos.\n\n**Contexto de la misión:**\nLos fractales cósmicos contienen información valiosa sobre la formación del sistema solar. Tu algoritmo recursivo debe calcular el factorial de coordenadas, generar secuencias de Fibonacci espaciales, y resolver el problema de las Torres de Hanoi para simular el movimiento de asteroides.\n\n**Objetivos:**\n- Implementa factorial recursivo para cálculos orbitales\n- Genera Fibonacci recursivo para patrones de asteroides\n- Resuelve Torres de Hanoi para simulación de movimientos\n- Calcula la profundidad máxima de recursión\n\n**Parámetros:**\n- Factorial: n = 8 (coordenadas orbitales)\n- Fibonacci: término 10 (patrón de asteroides)\n- Torres de Hanoi: 4 discos (asteroides)\n\n? ¡Los secretos del cosmos están en los números!',NULL,4,0,4,350,0,'print(\"?️ === ALGORITMO DE PATHFINDING ESPACIAL ===\")\nimport heapq\nimport math\n\n# TODO: Implementar algoritmo A* para navegación espacial\nclass PathfindingEspacial:\n    def __init__(self, mapa_espacial):\n        self.mapa = mapa_espacial\n        self.obstaculos = []\n        self.zonas_peligrosas = []\n    \n    # TODO: Implementar A*\n    def a_estrella(self, inicio, objetivo):\n        # Algoritmo A* adaptado para 3D\n        pass\n    \n    # TODO: Calcular heurística\n    def heuristica(self, punto1, punto2):\n        # Distancia euclidiana 3D\n        pass\n    \n    # TODO: Obtener vecinos\n    def obtener_vecinos(self, punto):\n        # Obtener puntos adyacentes válidos\n        pass\n    \n    # TODO: Verificar colisiones\n    def verificar_colision(self, punto):\n        # Verificar si el punto está libre\n        pass\n    \n    # TODO: Optimizar ruta\n    def optimizar_ruta(self, ruta):\n        # Suavizar la ruta calculada\n        pass\n\n# Configuración del espacio\nmapa_3d = {\n    \"dimensiones\": {\"x\": 1000, \"y\": 1000, \"z\": 1000},\n    \"obstaculos\": [\n        {\"centro\": (200, 300, 150), \"radio\": 50, \"tipo\": \"asteroide\"},\n        {\"centro\": (600, 700, 400), \"radio\": 80, \"tipo\": \"estacion\"},\n        {\"centro\": (800, 200, 600), \"radio\": 30, \"tipo\": \"satelite\"}\n    ],\n    \"zonas_peligrosas\": [\n        {\"centro\": (400, 500, 300), \"radio\": 100, \"peligro\": \"radiacion\"},\n        {\"centro\": (100, 800, 200), \"radio\": 75, \"peligro\": \"campo_magnetico\"}\n    ]\n}\n\n# Crear pathfinder\npathfinder = PathfindingEspacial(mapa_3d)\n\nprint(\"?️ Configurando sistema de navegación:\")\nprint(f\"? Espacio: {mapa_3d[dimensiones][x]}x{mapa_3d[dimensiones][y]}x{mapa_3d[dimensiones][z]}\")\nprint(f\"? Obstáculos: {len(mapa_3d[obstaculos])}\")\nprint(f\"⚠️ Zonas peligrosas: {len(mapa_3d[zonas_peligrosas])}\")\n\n# Calcular rutas\nrutas_prueba = [\n    {\"inicio\": (0, 0, 0), \"destino\": (900, 900, 900), \"nombre\": \"Ruta Larga\"},\n    {\"inicio\": (100, 100, 100), \"destino\": (300, 400, 200), \"nombre\": \"Ruta Corta\"},\n    {\"inicio\": (500, 500, 500), \"destino\": (750, 750, 750), \"nombre\": \"Ruta Compleja\"}\n]\n\nprint(\"\n? Calculando rutas:\")\nfor ruta_info in rutas_prueba:\n    print(f\"\n? {ruta_info[nombre]}:\")\n    print(f\"  ? Inicio: {ruta_info[inicio]}\")\n    print(f\"  ? Destino: {ruta_info[destino]}\")\n    \n    ruta = pathfinder.a_estrella(ruta_info[\"inicio\"], ruta_info[\"destino\"])\n    \n    if ruta:\n        ruta_optimizada = pathfinder.optimizar_ruta(ruta)\n        distancia_total = sum(\n            pathfinder.heuristica(ruta_optimizada[i], ruta_optimizada[i+1])\n            for i in range(len(ruta_optimizada)-1)\n        )\n        print(f\"  ✅ Ruta encontrada: {len(ruta_optimizada)} puntos\")\n        print(f\"  ? Distancia total: {distancia_total:.2f} unidades\")\n    else:\n        print(f\"  ❌ No se encontró ruta válida\")\n\nprint(\"\n?️ Sistema de pathfinding listo\")','? === EXPLORADOR DE FRACTALES CÓSMICOS ===\n? Calculando factorial cósmico de 5:\n? Calculando factorial de 5\n  ? Calculando factorial de 4\n    ? Calculando factorial de 3\n      ? Calculando factorial de 2\n        ? Calculando factorial de 1\n        ✅ Caso base alcanzado: 1! = 1\n      ? 2! = 2\n    ? 3! = 6\n  ? 4! = 24\n? 5! = 120\n\n? Resultado: 5! = 120\n? Llamadas recursivas: 5\n?️ Profundidad máxima: 4\n\n? Calculando Fibonacci cósmico del término 6:\n? Fibonacci cósmico de 6\n  ? Fibonacci cósmico de 5\n    ? Fibonacci cósmico de 4\n      ? Fibonacci cósmico de 3\n        ? Fibonacci cósmico de 2\n          ? Fibonacci cósmico de 1\n          ⭐ Caso base: F(1) = 1\n          ? Fibonacci cósmico de 0\n          ⭐ Caso base: F(0) = 0\n        ? F(2) = 1\n        ? Fibonacci cósmico de 1\n        ⭐ Caso base: F(1) = 1\n      ? F(3) = 2\n      ? Fibonacci cósmico de 2\n        ? Fibonacci cósmico de 1\n        ⭐ Caso base: F(1) = 1\n        ? Fibonacci cósmico de 0\n        ⭐ Caso base: F(0) = 0\n      ? F(2) = 1\n    ? F(4) = 3\n    ? Fibonacci cósmico de 3\n      ? Fibonacci cósmico de 2\n        ? Fibonacci cósmico de 1\n        ⭐ Caso base: F(1) = 1\n        ? Fibonacci cósmico de 0\n        ⭐ Caso base: F(0) = 0\n      ? F(2) = 1\n      ? Fibonacci cósmico de 1\n      ⭐ Caso base: F(1) = 1\n    ? F(3) = 2\n  ? F(5) = 5\n  ? Fibonacci cósmico de 4\n    ? Fibonacci cósmico de 3\n      ? Fibonacci cósmico de 2\n        ? Fibonacci cósmico de 1\n        ⭐ Caso base: F(1) = 1\n        ? Fibonacci cósmico de 0\n        ⭐ Caso base: F(0) = 0\n      ? F(2) = 1\n      ? Fibonacci cósmico de 1\n      ⭐ Caso base: F(1) = 1\n    ? F(3) = 2\n    ? Fibonacci cósmico de 2\n      ? Fibonacci cósmico de 1\n      ⭐ Caso base: F(1) = 1\n      ? Fibonacci cósmico de 0\n      ⭐ Caso base: F(0) = 0\n    ? F(2) = 1\n  ? F(4) = 3\n? F(6) = 8\n\n? Resultado: F(6) = 8\n? Llamadas recursivas: 25\n\n?️ Resolviendo Torres de Hanoi con 3 asteroides:\n? Mover asteroide 1 de Sector A a Sector C\n? Mover asteroide 2 de Sector A a Sector B\n? Mover asteroide 1 de Sector C a Sector B\n? Mover asteroide 3 de Sector A a Sector C\n? Mover asteroide 1 de Sector B a Sector A\n? Mover asteroide 2 de Sector B a Sector C\n? Mover asteroide 1 de Sector A a Sector C\n\n? Movimientos totales: 7','Exploración Recursiva de Galaxias'),(27,9,3,'? SOLUCIONADOR DE LABERINTOS CUÁNTICOS ?\n\nImplementa un solucionador avanzado de laberintos para navegar por campos de asteroides en AstroCode. Usa backtracking recursivo con optimizaciones de memoización para encontrar rutas seguras a través de laberintos tridimensionales de asteroides, considerando gravedad variable y campos magnéticos que cambian las reglas de navegación.',NULL,5,0,5,800,0,'print(\"⚛️ === SIMULADOR DE FÍSICA ESPACIAL ===\")\nimport math\nimport random\n\n# TODO: Implementar simulador de física\nclass SimuladorFisica:\n    def __init__(self):\n        self.objetos = []\n        self.fuerzas_activas = []\n        self.tiempo_simulacion = 0\n        self.dt = 0.01  # Paso de tiempo\n    \n    # TODO: Agregar objeto\n    def agregar_objeto(self, objeto):\n        # Agregar objeto físico al simulador\n        pass\n    \n    # TODO: Calcular fuerzas\n    def calcular_fuerzas(self, objeto):\n        # Calcular todas las fuerzas que actúan sobre el objeto\n        pass\n    \n    # TODO: Integrar movimiento\n    def integrar_movimiento(self, objeto, fuerzas):\n        # Integración de Verlet para mayor estabilidad\n        pass\n    \n    # TODO: Detectar colisiones\n    def detectar_colisiones(self):\n        # Detección de colisiones entre objetos\n        pass\n    \n    # TODO: Simular paso\n    def simular_paso(self):\n        # Simular un paso de tiempo\n        pass\n    \n    # TODO: Simular período\n    def simular(self, duracion, pasos_por_segundo=100):\n        # Ejecutar simulación completa\n        pass\n\n# Definir objetos espaciales\nobjetos_espaciales = [\n    {\n        \"nombre\": \"Nave Explorador\",\n        \"masa\": 50000,  # kg\n        \"posicion\": [0, 0, 0],\n        \"velocidad\": [100, 0, 0],\n        \"radio\": 10,\n        \"tipo\": \"nave\"\n    },\n    {\n        \"nombre\": \"Asteroide Alpha\",\n        \"masa\": 1000000,  # kg\n        \"posicion\": [1000, 500, 0],\n        \"velocidad\": [-50, 20, 0],\n        \"radio\": 50,\n        \"tipo\": \"asteroide\"\n    },\n    {\n        \"nombre\": \"Estación Orbital\",\n        \"masa\": 500000,  # kg\n        \"posicion\": [2000, 0, 1000],\n        \"velocidad\": [0, 30, 0],\n        \"radio\": 100,\n        \"tipo\": \"estacion\"\n    }\n]\n\n# Crear simulador\nsimulador = SimuladorFisica()\n\nprint(\"⚛️ Configurando simulación física:\")\nfor obj_info in objetos_espaciales:\n    simulador.agregar_objeto(obj_info)\n    print(f\"✅ {obj_info[nombre]}: masa={obj_info[masa]:,} kg\")\n\nprint(\"\n? Iniciando simulación:\")\nprint(\"? Parámetros:\")\nprint(f\"  ⏱️ Paso de tiempo: {simulador.dt} s\")\nprint(f\"  ? Duración: 10 segundos\")\nprint(f\"  ? Pasos por segundo: 100\")\n\n# Ejecutar simulación\nresultados = simulador.simular(duracion=10, pasos_por_segundo=100)\n\nprint(\"\n? Resultados de la simulación:\")\nfor i, objeto in enumerate(simulador.objetos):\n    pos_final = objeto[\"posicion\"]\n    vel_final = objeto[\"velocidad\"]\n    \n    print(f\"\n? {objeto[nombre]}:\")\n    print(f\"  ? Posición final: ({pos_final[0]:.1f}, {pos_final[1]:.1f}, {pos_final[2]:.1f})\")\n    print(f\"  ? Velocidad final: ({vel_final[0]:.1f}, {vel_final[1]:.1f}, {vel_final[2]:.1f}) m/s\")\n    \n    # Calcular energía cinética\n    energia_cinetica = 0.5 * objeto[\"masa\"] * sum(v**2 for v in vel_final)\n    print(f\"  ⚡ Energía cinética: {energia_cinetica:.2e} J\")\n\n# Verificar colisiones\ncolisiones = simulador.detectar_colisiones()\nif colisiones:\n    print(f\"\n? Colisiones detectadas: {len(colisiones)}\")\n    for colision in colisiones:\n        print(f\"  ⚠️ {colision[objeto1]} ↔ {colision[objeto2]}\")\nelse:\n    print(\"\n✅ No se detectaron colisiones\")\n\nprint(\"\n⚛️ Simulación física completada\")','? === SOLUCIONADOR DE LABERINTOS CUÁNTICOS ===\n\n? Configuración de navegación:\n? Inicio: Sector (0, 0, 0)\n? Destino: Sector (4, 4, 1)\n? Dimensiones: 5x5x2\n\n? Analizando campo de asteroides...\n\n✅ Ruta segura encontrada:\n1. (0,0,0) → (0,0,1) - Cambio de nivel\n2. (0,0,1) → (1,0,1) - Avance X\n3. (1,0,1) → (2,0,1) - Evitando asteroide\n4. (2,0,1) → (2,1,1) - Avance Y\n5. (2,1,1) → (2,2,1) - Ruta libre\n6. (2,2,1) → (3,2,1) - Navegando campo\n7. (3,2,1) → (4,2,1) - Aproximación final\n8. (4,2,1) → (4,3,1) - Último tramo\n9. (4,3,1) → (4,4,1) - ¡Destino alcanzado!\n\n? Distancia total: 12.5 unidades\n⚡ Optimizaciones aplicadas: Memoización, Poda de rutas\n\n? Navegación cuántica completada','Fractales del Espacio-Tiempo'),(28,10,1,'? **Misión: Sistema de Cola de Comandos**\n\nComo operador de sistemas de AstroCode, debes implementar una cola (queue) para gestionar los comandos que se envían a la nave en orden de llegada.\n\n**Contexto de la misión:**\nLa nave recibe múltiples comandos simultáneamente. Para evitar conflictos, debes procesarlos en el orden exacto en que llegaron usando una estructura de cola FIFO (First In, First Out).\n\n**Objetivos:**\n- Implementa una cola usando un array\n- Agrega comandos al final de la cola (enqueue)\n- Procesa comandos desde el inicio (dequeue)\n- Muestra el estado de la cola en cada operación\n\n**Comandos a procesar:**\n1. \"ACTIVAR_ESCUDOS\"\n2. \"ACELERAR\"\n3. \"ESCANEAR_SECTOR\"\n4. \"COMUNICAR_BASE\"\n\n? ¡El orden correcto evita errores críticos!',NULL,3,0,3,400,0,'print(\"? === RED NEURAL PARA RECONOCIMIENTO ESPACIAL ===\")\nimport random\nimport math\n\n# TODO: Implementar red neural simple\nclass RedNeuralEspacial:\n    def __init__(self, capas):\n        self.capas = capas\n        self.pesos = []\n        self.sesgos = []\n        self.inicializar_pesos()\n    \n    # TODO: Inicializar pesos\n    def inicializar_pesos(self):\n        # Inicialización aleatoria de pesos y sesgos\n        pass\n    \n    # TODO: Función de activación\n    def sigmoid(self, x):\n        # Función sigmoid\n        pass\n    \n    # TODO: Derivada de sigmoid\n    def sigmoid_derivada(self, x):\n        # Derivada de la función sigmoid\n        pass\n    \n    # TODO: Propagación hacia adelante\n    def forward(self, entrada):\n        # Calcular salida de la red\n        pass\n    \n    # TODO: Retropropagación\n    def backward(self, entrada, salida_esperada, tasa_aprendizaje=0.1):\n        # Algoritmo de retropropagación\n        pass\n    \n    # TODO: Entrenar\n    def entrenar(self, datos_entrenamiento, epocas=1000):\n        # Entrenar la red con los datos\n        pass\n    \n    # TODO: Predecir\n    def predecir(self, entrada):\n        # Hacer predicción\n        pass\n\n# Datos de entrenamiento para reconocimiento de objetos espaciales\n# Entrada: [tamaño, velocidad, reflectividad, temperatura]\n# Salida: [es_asteroide, es_nave, es_planeta, es_estrella]\ndatos_entrenamiento = [\n    # Asteroides\n    {\"entrada\": [0.1, 0.3, 0.2, 0.1], \"salida\": [1, 0, 0, 0]},\n    {\"entrada\": [0.2, 0.4, 0.3, 0.05], \"salida\": [1, 0, 0, 0]},\n    {\"entrada\": [0.15, 0.35, 0.25, 0.08], \"salida\": [1, 0, 0, 0]},\n    \n    # Naves\n    {\"entrada\": [0.05, 0.8, 0.9, 0.3], \"salida\": [0, 1, 0, 0]},\n    {\"entrada\": [0.08, 0.7, 0.85, 0.25], \"salida\": [0, 1, 0, 0]},\n    {\"entrada\": [0.06, 0.9, 0.95, 0.35], \"salida\": [0, 1, 0, 0]},\n    \n    # Planetas\n    {\"entrada\": [0.8, 0.1, 0.4, 0.4], \"salida\": [0, 0, 1, 0]},\n    {\"entrada\": [0.9, 0.05, 0.5, 0.45], \"salida\": [0, 0, 1, 0]},\n    {\"entrada\": [0.85, 0.08, 0.45, 0.42], \"salida\": [0, 0, 1, 0]},\n    \n    # Estrellas\n    {\"entrada\": [0.95, 0.02, 0.95, 0.98], \"salida\": [0, 0, 0, 1]},\n    {\"entrada\": [0.98, 0.01, 0.98, 0.95], \"salida\": [0, 0, 0, 1]},\n    {\"entrada\": [0.92, 0.03, 0.92, 0.99], \"salida\": [0, 0, 0, 1]}\n]\n\n# Crear red neural\n# Arquitectura: 4 entradas -> 8 ocultas -> 4 salidas\nred = RedNeuralEspacial([4, 8, 4])\n\nprint(\"? Configurando red neural:\")\nprint(f\"? Arquitectura: {red.capas}\")\nprint(f\"? Datos de entrenamiento: {len(datos_entrenamiento)} ejemplos\")\n\nprint(\"\n? Entrenando red neural...\")\nred.entrenar(datos_entrenamiento, epocas=2000)\nprint(\"✅ Entrenamiento completado\")\n\n# Probar la red\nprint(\"\n? Probando reconocimiento:\")\nobjetos_prueba = [\n    {\"datos\": [0.12, 0.32, 0.22, 0.07], \"tipo_real\": \"Asteroide\"},\n    {\"datos\": [0.07, 0.75, 0.88, 0.28], \"tipo_real\": \"Nave\"},\n    {\"datos\": [0.87, 0.06, 0.48, 0.43], \"tipo_real\": \"Planeta\"},\n    {\"datos\": [0.96, 0.015, 0.94, 0.97], \"tipo_real\": \"Estrella\"}\n]\n\ntipos_objetos = [\"Asteroide\", \"Nave\", \"Planeta\", \"Estrella\"]\n\nfor i, obj in enumerate(objetos_prueba):\n    prediccion = red.predecir(obj[\"datos\"])\n    tipo_predicho = tipos_objetos[prediccion.index(max(prediccion))]\n    confianza = max(prediccion) * 100\n    \n    print(f\"\n? Objeto {i+1}:\")\n    print(f\"  ? Datos: {obj[datos]}\")\n    print(f\"  ? Tipo real: {obj[tipo_real]}\")\n    print(f\"  ? Predicción: {tipo_predicho}\")\n    print(f\"  ? Confianza: {confianza:.1f}%\")\n    print(f\"  {✅ if tipo_predicho == obj[tipo_real] else ❌} {Correcto if tipo_predicho == obj[tipo_real] else Incorrecto}\")\n\nprint(\"\n? Red neural lista para reconocimiento\")','? === SISTEMA DE COLA DE COMANDOS ===\n\n? Agregando comandos a la cola:\n➕ Comando agregado: ACTIVAR_ESCUDOS\n? Cola actual: [ACTIVAR_ESCUDOS]\n➕ Comando agregado: ACELERAR\n? Cola actual: [ACTIVAR_ESCUDOS, ACELERAR]\n➕ Comando agregado: ESCANEAR_SECTOR\n? Cola actual: [ACTIVAR_ESCUDOS, ACELERAR, ESCANEAR_SECTOR]\n➕ Comando agregado: COMUNICAR_BASE\n? Cola actual: [ACTIVAR_ESCUDOS, ACELERAR, ESCANEAR_SECTOR, COMUNICAR_BASE]\n\n⚡ Procesando comandos:\n⚡ Procesando: ACTIVAR_ESCUDOS\n? Cola restante: [ACELERAR, ESCANEAR_SECTOR, COMUNICAR_BASE]\n⚡ Procesando: ACELERAR\n? Cola restante: [ESCANEAR_SECTOR, COMUNICAR_BASE]\n⚡ Procesando: ESCANEAR_SECTOR\n? Cola restante: [COMUNICAR_BASE]\n⚡ Procesando: COMUNICAR_BASE\n? Cola restante: []\n\n✅ Todos los comandos procesados','Pila de Comandos de Nave'),(29,10,2,'?️ **Misión: Centro de Comando de Comunicaciones**\n\nComo ingeniero de comunicaciones de AstroCode, debes implementar un sistema avanzado de gestión de mensajes usando estructuras de datos eficientes. El centro debe manejar colas de prioridad, pilas de historial y mapas de contactos.\n\n**Contexto de la misión:**\nEl centro de comando recibe miles de mensajes diarios de diferentes naves y estaciones. Necesitas un sistema que priorice mensajes de emergencia, mantenga historial de comunicaciones y gestione contactos de manera eficiente.\n\n**Objetivos:**\n- Implementa una cola de prioridad para mensajes\n- Crea una pila para historial de comandos\n- Desarrolla un mapa hash para contactos\n- Gestiona diferentes tipos de mensajes y prioridades\n\n**Tipos de mensajes:**\n- Emergencia (Prioridad 1), Operacional (Prioridad 2), Informativo (Prioridad 3)\n- Cada mensaje tiene: ID, remitente, contenido, timestamp\n\n? ¡La comunicación eficiente salva vidas en el espacio!',NULL,4,0,4,400,0,'print(\"⚙️ === OPTIMIZADOR DE RECURSOS ESPACIALES ===\")\n\n# TODO: Implementar optimizador de recursos\nclass OptimizadorRecursos:\n    def __init__(self):\n        self.recursos_disponibles = {}\n        self.demandas_activas = []\n        self.restricciones = []\n        self.solucion_optima = None\n    \n    # TODO: Agregar recurso\n    def agregar_recurso(self, nombre, cantidad_disponible, costo_unitario):\n        # Registrar recurso disponible\n        pass\n    \n    # TODO: Agregar demanda\n    def agregar_demanda(self, recursos_necesarios, prioridad, deadline=None):\n        # Registrar nueva demanda de recursos\n        pass\n    \n    # TODO: Algoritmo de optimización\n    def optimizar_asignacion(self):\n        # Resolver problema de asignación óptima\n        pass\n    \n    # TODO: Verificar factibilidad\n    def verificar_factibilidad(self, asignacion):\n        # Verificar si la asignación es válida\n        pass\n    \n    # TODO: Calcular eficiencia\n    def calcular_eficiencia(self, asignacion):\n        # Calcular métricas de eficiencia\n        pass\n\n# Configuración de recursos\nrecursos_nave = {\n    \"energia\": {\"disponible\": 1000, \"costo\": 1.5, \"unidad\": \"kWh\"},\n    \"combustible\": {\"disponible\": 500, \"costo\": 3.0, \"unidad\": \"litros\"},\n    \"oxigeno\": {\"disponible\": 200, \"costo\": 2.0, \"unidad\": \"m³\"},\n    \"agua\": {\"disponible\": 150, \"costo\": 1.0, \"unidad\": \"litros\"},\n    \"comida\": {\"disponible\": 100, \"costo\": 2.5, \"unidad\": \"kg\"}\n}\n\n# Demandas de sistemas\ndemandas_sistemas = [\n    {\n        \"sistema\": \"Soporte Vital\",\n        \"recursos\": {\"energia\": 200, \"oxigeno\": 50, \"agua\": 30},\n        \"prioridad\": 10,\n        \"critico\": True\n    },\n    {\n        \"sistema\": \"Propulsión\",\n        \"recursos\": {\"energia\": 300, \"combustible\": 200},\n        \"prioridad\": 8,\n        \"critico\": True\n    },\n    {\n        \"sistema\": \"Comunicaciones\",\n        \"recursos\": {\"energia\": 100},\n        \"prioridad\": 6,\n        \"critico\": False\n    },\n    {\n        \"sistema\": \"Investigación\",\n        \"recursos\": {\"energia\": 150, \"agua\": 20},\n        \"prioridad\": 4,\n        \"critico\": False\n    }\n]\n\n# Crear optimizador\noptimizador = OptimizadorRecursos()\n\nprint(\"⚙️ Configurando optimizador de recursos:\")\nfor nombre, info in recursos_nave.items():\n    optimizador.agregar_recurso(nombre, info[\"disponible\"], info[\"costo\"])\n    print(f\"✅ {nombre}: {info[disponible]} {info[unidad]} (${info[costo]}/{info[unidad]})\")\n\nprint(\"\n? Registrando demandas de sistemas:\")\nfor demanda in demandas_sistemas:\n    optimizador.agregar_demanda(\n        demanda[\"recursos\"], \n        demanda[\"prioridad\"], \n        deadline=None\n    )\n    recursos_str = \", \".join([f\"{k}: {v}\" for k, v in demanda[\"recursos\"].items()])\n    print(f\"? {demanda[sistema]}: {recursos_str} (Prioridad: {demanda[prioridad]})\")\n\nprint(\"\n? Ejecutando optimización...\")\nsolucion = optimizador.optimizar_asignacion()\n\nif solucion:\n    print(\"✅ Solución óptima encontrada:\")\n    \n    for sistema, asignacion in solucion.items():\n        print(f\"\n? {sistema}:\")\n        for recurso, cantidad in asignacion.items():\n            porcentaje = (cantidad / recursos_nave[recurso][\"disponible\"]) * 100\n            print(f\"  ? {recurso}: {cantidad} ({porcentaje:.1f}% del disponible)\")\n    \n    # Calcular métricas\n    eficiencia = optimizador.calcular_eficiencia(solucion)\n    print(f\"\n? Eficiencia total: {eficiencia:.2f}%\")\n    \n    factible = optimizador.verificar_factibilidad(solucion)\n    print(f\"✅ Solución factible: {Sí if factible else No}\")\nelse:\n    print(\"❌ No se encontró solución factible\")\n\nprint(\"\n⚙️ Optimización de recursos completada\")','?️ === CENTRO DE COMANDO DE COMUNICACIONES ===\n? Contacto agregado: Capitán Rodriguez (CMD001)\n? Contacto agregado: Ingeniera Chen (ENG002)\n? Contacto agregado: Dr. Patel (SCI003)\n\n? Procesando mensajes:\n? Mensaje encolado: MSG001 (Prioridad 3)\n? Mensaje encolado: MSG002 (Prioridad 1)\n? Mensaje encolado: MSG003 (Prioridad 2)\n? Estado actual de la cola:\n  1. MSG002 - Emergencia (P1)\n  2. MSG003 - Operacional (P2)\n  3. MSG001 - Informativo (P3)\n\n⚡ Procesando mensajes por prioridad:\n? Procesando mensaje: MSG002\n? Comando guardado: Procesado MSG002 de ENG002\n? Procesando mensaje: MSG003\n? Comando guardado: Procesado MSG003 de SCI003\n? Procesando mensaje: MSG001\n? Comando guardado: Procesado MSG001 de CMD001\n\n? Historial reciente:\n? Historial de comandos:\n  1. Procesado MSG002 de ENG002 (10:30:15)\n  2. Procesado MSG003 de SCI003 (10:30:15)\n  3. Procesado MSG001 de CMD001 (10:30:15)\n\n? Búsqueda de contactos:\n? Encontrado: Ingeniera Chen - Sector Beta (Ingeniero Jefe)\n? Contactos en Sector Alpha:\n  Capitán Rodriguez (CMD001) - Comandante\n  Dr. Patel (SCI003) - Científico','Árbol Binario de Sistemas Estelares'),(30,10,3,'? ÁRBOL AVL DE NAVEGACIÓN GALÁCTICA ?\n\nImplementa un árbol AVL auto-balanceado para el sistema de navegación galáctica de AstroCode. El árbol debe mantener coordenadas estelares ordenadas, realizar rotaciones automáticas para mantener el balance, y proporcionar búsquedas ultra-rápidas de rutas entre sistemas estelares para optimizar los viajes interplanetarios.',NULL,5,0,5,900,0,'print(\"? === SISTEMA DE INTELIGENCIA ARTIFICIAL ===\")\nimport random\nimport math\n\n# TODO: Implementar sistema de IA\nclass IAEspacial:\n    def __init__(self, nombre=\"ARIA\"):\n        self.nombre = nombre\n        self.conocimiento = {}\n        self.memoria_trabajo = []\n        self.objetivos_activos = []\n        self.estado_emocional = \"neutral\"\n    \n    # TODO: Procesar información\n    def procesar_informacion(self, datos):\n        # Analizar y procesar nueva información\n        pass\n    \n    # TODO: Tomar decisión\n    def tomar_decision(self, situacion, opciones):\n        # Algoritmo de toma de decisiones\n        pass\n    \n    # TODO: Aprender de experiencia\n    def aprender(self, experiencia, resultado):\n        # Actualizar conocimiento basado en experiencias\n        pass\n    \n    # TODO: Generar respuesta\n    def generar_respuesta(self, consulta):\n        # Generar respuesta inteligente\n        pass\n    \n    # TODO: Evaluar riesgo\n    def evaluar_riesgo(self, accion, contexto):\n        # Calcular nivel de riesgo de una acción\n        pass\n    \n    # TODO: Planificar misión\n    def planificar_mision(self, objetivo, recursos, restricciones):\n        # Crear plan de misión optimizado\n        pass\n\n# Configuración de la IA\nia = IAEspacial(\"ARIA-7\")\n\nprint(f\"? Inicializando {ia.nombre}...\")\nprint(\"? Cargando módulos de conocimiento:\")\n\n# Cargar conocimiento base\nconocimiento_base = {\n    \"navegacion\": {\n        \"sistemas_estelares\": 1247,\n        \"rutas_conocidas\": 3891,\n        \"peligros_identificados\": 156\n    },\n    \"protocolos\": {\n        \"emergencia\": 23,\n        \"comunicacion\": 45,\n        \"mantenimiento\": 67\n    },\n    \"especies\": {\n        \"conocidas\": 12,\n        \"hostiles\": 3,\n        \"aliadas\": 7,\n        \"neutrales\": 2\n    }\n}\n\nfor categoria, datos in conocimiento_base.items():\n    ia.conocimiento[categoria] = datos\n    print(f\"✅ {categoria.capitalize()}: {sum(datos.values()) if isinstance(datos, dict) else len(datos)} entradas\")\n\nprint(\"\n? Simulando interacciones con la IA:\")\n\n# Escenarios de prueba\nescenarios = [\n    {\n        \"situacion\": \"Detección de nave desconocida\",\n        \"datos\": {\"distancia\": 1000, \"tamaño\": \"mediano\", \"señales\": \"desconocidas\"},\n        \"opciones\": [\"investigar\", \"evadir\", \"comunicar\", \"alertar_base\"]\n    },\n    {\n        \"situacion\": \"Falla en sistema de soporte vital\",\n        \"datos\": {\"oxigeno\": 85, \"energia\": 60, \"tiempo_estimado\": 4},\n        \"opciones\": [\"reparar_inmediato\", \"buscar_estacion\", \"solicitar_rescate\", \"modo_emergencia\"]\n    },\n    {\n        \"situacion\": \"Oportunidad de investigación\",\n        \"datos\": {\"anomalia\": \"gravitacional\", \"recursos\": 70, \"tiempo_disponible\": 8},\n        \"opciones\": [\"investigar_completo\", \"escaneo_rapido\", \"marcar_ubicacion\", \"ignorar\"]\n    }\n]\n\nfor i, escenario in enumerate(escenarios, 1):\n    print(f\"\n? Escenario {i}: {escenario[situacion]}\")\n    \n    # Procesar información\n    ia.procesar_informacion(escenario[\"datos\"])\n    \n    # Evaluar opciones\n    print(\"? Evaluando opciones:\")\n    for opcion in escenario[\"opciones\"]:\n        riesgo = ia.evaluar_riesgo(opcion, escenario[\"datos\"])\n        print(f\"  ? {opcion}: Riesgo {riesgo:.1f}/10\")\n    \n    # Tomar decisión\n    decision = ia.tomar_decision(escenario[\"situacion\"], escenario[\"opciones\"])\n    print(f\"? Decisión de {ia.nombre}: {decision}\")\n    \n    # Generar explicación\n    explicacion = ia.generar_respuesta(f\"¿Por qué elegiste {decision}?\")\n    print(f\"? Explicación: {explicacion}\")\n\n# Planificación de misión\nprint(\"\n? Planificando misión de exploración:\")\nobjetivo_mision = \"Explorar sistema Kepler-442\"\nrecursos_disponibles = {\"combustible\": 80, \"suministros\": 90, \"tiempo\": 30}\nrestricciones = [\"evitar_zona_radiacion\", \"mantener_comunicacion\", \"retorno_seguro\"]\n\nplan = ia.planificar_mision(objetivo_mision, recursos_disponibles, restricciones)\n\nif plan:\n    print(f\"? Plan generado para: {objetivo_mision}\")\n    print(f\"⏱️ Duración estimada: {plan.get(duracion, N/A)} días\")\n    print(f\"? Probabilidad de éxito: {plan.get(probabilidad_exito, 0):.1f}%\")\n    print(f\"? Fases del plan: {len(plan.get(fases, []))}\")\nelse:\n    print(\"❌ No se pudo generar un plan factible\")\n\nprint(f\"\n? {ia.nombre} operativo y listo para asistir\")','? === ÁRBOL AVL DE NAVEGACIÓN GALÁCTICA ===\n\n? Construyendo mapa de navegación galáctica:\n1. Insertando Sol (50)\n   ? Altura: 1, Rotaciones: 0\n2. Insertando Proxima Centauri (25)\n   ? Altura: 2, Rotaciones: 0\n3. Insertando Sirius (75)\n   ? Altura: 2, Rotaciones: 0\n4. Insertando Wolf 359 (10)\n   ? Altura: 3, Rotaciones: 1\n5. Insertando Vega (60)\n   ? Altura: 3, Rotaciones: 1\n6. Insertando Altair (30)\n   ? Altura: 3, Rotaciones: 1\n7. Insertando Arcturus (80)\n   ? Altura: 3, Rotaciones: 1\n8. Insertando Barnard (15)\n   ? Altura: 4, Rotaciones: 2\n9. Insertando Capella (90)\n   ? Altura: 4, Rotaciones: 2\n\n? Sistemas ordenados por coordenada:\nWolf 359 (10) → Barnard (15) → Proxima Centauri (25) → Altair (30) → Sol (50) → Vega (60) → Sirius (75) → Arcturus (80) → Capella (90)\n\n? Pruebas de búsqueda:\n✅ Sol encontrado en coordenada 50\n✅ Vega encontrado en coordenada 60\n❌ Alpha Centauri no encontrado\n\n? Estadísticas finales del árbol:\n? Altura total: 4\n? Rotaciones realizadas: 2\n⭐ Sistemas registrados: 9\n⚖️ Árbol balanceado: ✅\n\n? Sistema de navegación galáctica listo','Grafo de Redes Galácticas'),(31,11,1,'? BÚSQUEDA BINARIA EN CATÁLOGO ESTELAR ?\n\nImplementa el algoritmo de búsqueda binaria para localizar rápidamente estrellas en el catálogo astronómico de AstroCode. El sistema debe buscar estrellas por magnitud en un array ordenado y comparar la eficiencia con búsqueda lineal, mostrando el número de comparaciones realizadas y el tiempo de ejecución para diferentes tamaños de catálogo.',NULL,4,0,3,500,0,'print(\"? === SIMULADOR DE ECOSISTEMA ESPACIAL ===\")\n\n# TODO: Implementar simulador de ecosistema\nclass EcosistemaEspacial:\n    def __init__(self):\n        self.especies = []\n        self.recursos = {}\n        self.ciclos_simulados = 0\n        self.eventos_aleatorios = []\n    \n    # TODO: Agregar especie\n    def agregar_especie(self, nombre, poblacion_inicial, tasa_crecimiento, recursos_necesarios):\n        # Registrar nueva especie en el ecosistema\n        pass\n    \n    # TODO: Simular ciclo\n    def simular_ciclo(self):\n        # Simular un ciclo de vida del ecosistema\n        pass\n    \n    # TODO: Calcular equilibrio\n    def calcular_equilibrio(self):\n        # Determinar si el ecosistema está en equilibrio\n        pass\n    \n    # TODO: Generar evento aleatorio\n    def generar_evento_aleatorio(self):\n        # Crear eventos que afecten el ecosistema\n        pass\n\n# Configuración inicial\necosistema = EcosistemaEspacial()\n\nprint(\"? Inicializando ecosistema espacial...\")\nprint(\"? Configurando especies y recursos\")\nprint(\"⚡ Sistema de simulación activo\")','? === BÚSQUEDA BINARIA EN CATÁLOGO ESTELAR ===\n\n? Catálogo estelar cargado:\n1. Sirius: -1.46\n2. Canopus: -0.74\n3. Arcturus: -0.05\n4. Vega: 0.03\n5. Capella: 0.08\n6. Rigel: 0.13\n7. Procyon: 0.34\n8. Betelgeuse: 0.50\n9. Aldebaran: 0.85\n10. Spica: 1.04\n\n? Comparando algoritmos de búsqueda:\n\n? Buscando estrella con magnitud -1.46:\n✅ Encontrada: Sirius\n? Búsqueda Binaria: 4 comparaciones, 0.0123ms\n? Búsqueda Lineal: 1 comparaciones, 0.0089ms\n⚡ Eficiencia: -300.0% menos comparaciones\n\n? Buscando estrella con magnitud 0.03:\n✅ Encontrada: Vega\n? Búsqueda Binaria: 2 comparaciones, 0.0098ms\n? Búsqueda Lineal: 4 comparaciones, 0.0156ms\n⚡ Eficiencia: 50.0% menos comparaciones\n\n? Buscando estrella con magnitud 1.04:\n✅ Encontrada: Spica\n? Búsqueda Binaria: 4 comparaciones, 0.0134ms\n? Búsqueda Lineal: 10 comparaciones, 0.0234ms\n⚡ Eficiencia: 60.0% menos comparaciones\n\n? Buscando estrella con magnitud 2.5:\n❌ No encontrada\n? Búsqueda Binaria: 4 comparaciones, 0.0112ms\n? Búsqueda Lineal: 10 comparaciones, 0.0198ms\n\n? Análisis de búsqueda completado','Búsqueda de Vida Extraterrestre'),(32,11,2,'Crea una implementación del algoritmo de Dijkstra para encontrar el camino más corto en un grafo ponderado.',NULL,4,0,5,500,0,'print(\"? === GENERADOR DE MÚSICA CÓSMICA ===\")\n\n# TODO: Implementar generador musical\nclass GeneradorMusicalCosmico:\n    def __init__(self):\n        self.escalas_cosmicas = {}\n        self.patrones_estelares = []\n        self.composicion_actual = []\n        self.instrumentos_espaciales = []\n    \n    # TODO: Mapear datos astronómicos\n    def mapear_datos_astronomicos(self, datos_telescopio):\n        # Convertir datos espaciales en notas musicales\n        pass\n    \n    # TODO: Generar melodía\n    def generar_melodia(self, tipo_objeto_espacial):\n        # Crear melodía basada en objetos espaciales\n        pass\n    \n    # TODO: Crear armonía\n    def crear_armonia(self, frecuencias_base):\n        # Generar armonías cósmicas\n        pass\n    \n    # TODO: Exportar composición\n    def exportar_composicion(self, formato=\"midi\"):\n        # Guardar la música generada\n        pass\n\n# Configuración musical\ngenerador = GeneradorMusicalCosmico()\n\nprint(\"? Inicializando generador musical cósmico...\")\nprint(\"? Cargando escalas del universo\")\nprint(\"? Listo para crear música espacial\")',NULL,'Algoritmo de Pathfinding Espacial'),(33,11,3,'Implementa un algoritmo de machine learning básico (regresión lineal) desde cero sin usar librerías externas.',NULL,5,0,5,500,0,'print(\"? === SISTEMA DE TERRAFORMACIÓN ===\")\n\n# TODO: Implementar sistema de terraformación\nclass SistemaTerraformacion:\n    def __init__(self):\n        self.planeta_objetivo = {}\n        self.tecnologias_disponibles = []\n        self.fases_terraformacion = []\n        self.recursos_necesarios = {}\n    \n    # TODO: Analizar planeta\n    def analizar_planeta(self, datos_planetarios):\n        # Evaluar condiciones actuales del planeta\n        pass\n    \n    # TODO: Diseñar plan\n    def disenar_plan_terraformacion(self):\n        # Crear plan detallado de terraformación\n        pass\n    \n    # TODO: Simular proceso\n    def simular_proceso(self, anos_simulacion):\n        # Simular el proceso de terraformación\n        pass\n    \n    # TODO: Monitorear progreso\n    def monitorear_progreso(self):\n        # Seguir el avance de la terraformación\n        pass\n\n# Configuración del sistema\nterraformador = SistemaTerraformacion()\n\nprint(\"? Inicializando sistema de terraformación...\")\nprint(\"? Analizando condiciones planetarias\")\nprint(\"? Sistema listo para transformar mundos\")',NULL,'Algoritmo de Machine Learning Cósmico'),(34,12,1,'Resuelve el problema de Fibonacci usando programación dinámica con memoización. Compara con la versión recursiva naive.',NULL,4,0,3,600,0,'print(\"? === RED NEURAL DE PREDICCIÓN ESPACIAL ===\")\n\n# TODO: Implementar red neural\nclass RedNeuralEspacial:\n    def __init__(self):\n        self.capas = []\n        self.pesos = []\n        self.datos_entrenamiento = []\n        self.precision_actual = 0.0\n    \n    # TODO: Configurar arquitectura\n    def configurar_arquitectura(self, capas_ocultas, neuronas_por_capa):\n        # Definir estructura de la red neural\n        pass\n    \n    # TODO: Entrenar red\n    def entrenar(self, datos_historicos, epocas=1000):\n        # Entrenar la red con datos espaciales\n        pass\n    \n    # TODO: Predecir evento\n    def predecir_evento(self, datos_actuales):\n        # Hacer predicción sobre eventos espaciales\n        pass\n    \n    # TODO: Evaluar precisión\n    def evaluar_precision(self, datos_prueba):\n        # Calcular precisión de las predicciones\n        pass\n\n# Configuración de la red\nred_neural = RedNeuralEspacial()\n\nprint(\"? Inicializando red neural espacial...\")\nprint(\"? Configurando arquitectura neuronal\")\nprint(\"? Sistema de predicción activado\")',NULL,'Optimización de Combustible'),(35,12,2,'Implementa la solución al problema de la mochila (knapsack) usando programación dinámica con optimización de espacio.',NULL,4,0,5,600,0,'print(\"? === SIMULADOR DE AGUJEROS DE GUSANO ===\")\n\n# TODO: Implementar simulador\nclass SimuladorAgujerosGusano:\n    def __init__(self):\n        self.agujeros_activos = []\n        self.conexiones_espaciales = {}\n        self.estabilidad_temporal = 1.0\n        self.energia_requerida = 0\n    \n    # TODO: Crear agujero de gusano\n    def crear_agujero_gusano(self, punto_origen, punto_destino, estabilidad):\n        # Generar nuevo agujero de gusano\n        pass\n    \n    # TODO: Calcular trayectoria\n    def calcular_trayectoria(self, masa_objeto, velocidad_inicial):\n        # Determinar ruta a través del agujero\n        pass\n    \n    # TODO: Simular viaje\n    def simular_viaje(self, nave_espacial, destino):\n        # Simular viaje a través del agujero de gusano\n        pass\n    \n    # TODO: Verificar estabilidad\n    def verificar_estabilidad(self, agujero_id):\n        # Comprobar si el agujero es estable\n        pass\n\n# Configuración del simulador\nsimulador = SimuladorAgujerosGusano()\n\nprint(\"? Inicializando simulador de agujeros de gusano...\")\nprint(\"⚡ Calculando distorsiones espacio-temporales\")\nprint(\"? Sistema de navegación interdimensional activo\")',NULL,'Problema de la Mochila Espacial'),(36,12,3,'Resuelve el problema de la subsecuencia común más larga (LCS) entre múltiples cadenas usando programación dinámica 3D.',NULL,5,0,5,600,0,'print(\"⛏️ === SISTEMA DE MINERÍA ASTEROIDAL ===\")\n\n# TODO: Implementar sistema de minería\nclass SistemaMineria:\n    def __init__(self):\n        self.asteroides_detectados = []\n        self.drones_mineros = []\n        self.recursos_extraidos = {}\n        self.eficiencia_operacion = 0.0\n    \n    # TODO: Escanear asteroides\n    def escanear_asteroides(self, sector_espacial):\n        # Detectar y analizar asteroides\n        pass\n    \n    # TODO: Evaluar rentabilidad\n    def evaluar_rentabilidad(self, asteroide):\n        # Calcular beneficio potencial\n        pass\n    \n    # TODO: Desplegar drones\n    def desplegar_drones(self, asteroide_objetivo, cantidad_drones):\n        # Enviar drones de minería\n        pass\n    \n    # TODO: Procesar materiales\n    def procesar_materiales(self, materiales_brutos):\n        # Refinar recursos extraídos\n        pass\n\n# Configuración del sistema\nmineria = SistemaMineria()\n\nprint(\"⛏️ Inicializando sistema de minería asteroidal...\")\nprint(\"? Desplegando drones exploradores\")\nprint(\"? Sistema de extracción activado\")',NULL,'Alineación de ADN Alienígena'),(37,13,1,'Implementa los algoritmos de recorrido DFS y BFS para un grafo representado con lista de adyacencia.',NULL,4,0,4,700,0,'print(\"?️ === GENERADOR DE CIVILIZACIONES ===\")\n\n# TODO: Implementar generador\nclass GeneradorCivilizaciones:\n    def __init__(self):\n        self.civilizaciones = []\n        self.tecnologias_disponibles = []\n        self.eventos_historicos = []\n        self.relaciones_diplomaticas = {}\n    \n    # TODO: Crear civilización\n    def crear_civilizacion(self, nombre, tipo, nivel_tecnologico):\n        # Generar nueva civilización\n        pass\n    \n    # TODO: Evolucionar tecnología\n    def evolucionar_tecnologia(self, civilizacion_id, años_transcurridos):\n        # Avanzar tecnológicamente\n        pass\n    \n    # TODO: Simular contacto\n    def simular_contacto(self, civ1_id, civ2_id):\n        # Simular primer contacto entre civilizaciones\n        pass\n    \n    # TODO: Generar conflicto\n    def generar_conflicto(self, motivo, civilizaciones_involucradas):\n        # Crear eventos de conflicto\n        pass\n\n# Configuración del generador\ngenerador = GeneradorCivilizaciones()\n\nprint(\"?️ Inicializando generador de civilizaciones...\")\nprint(\"? Creando especies inteligentes\")\nprint(\"? Sistema de evolución cultural activo\")',NULL,''),(38,13,2,'Crea un algoritmo para detectar ciclos en un grafo dirigido y otro para encontrar componentes fuertemente conexas.',NULL,4,0,5,700,0,'print(\"⚛️ === SIMULADOR DE FÍSICA CUÁNTICA ===\")\n\n# TODO: Implementar simulador cuántico\nclass SimuladorCuantico:\n    def __init__(self):\n        self.particulas = []\n        self.estados_cuanticos = {}\n        self.entrelazamientos = []\n        self.probabilidades = {}\n    \n    # TODO: Crear partícula\n    def crear_particula(self, tipo, spin, posicion):\n        # Generar nueva partícula cuántica\n        pass\n    \n    # TODO: Calcular superposición\n    def calcular_superposicion(self, particula_id):\n        # Determinar estados superpuestos\n        pass\n    \n    # TODO: Simular entrelazamiento\n    def simular_entrelazamiento(self, particula1_id, particula2_id):\n        # Crear entrelazamiento cuántico\n        pass\n    \n    # TODO: Colapsar función de onda\n    def colapsar_funcion_onda(self, particula_id):\n        # Colapsar estado cuántico\n        pass\n\n# Configuración del simulador\nsimulador = SimuladorCuantico()\n\nprint(\"⚛️ Inicializando simulador cuántico...\")\nprint(\"? Configurando funciones de onda\")\nprint(\"? Sistema de mecánica cuántica activo\")',NULL,''),(39,13,3,'Implementa el algoritmo de Ford-Fulkerson para encontrar el flujo máximo en una red de flujo.',NULL,5,0,5,700,0,'print(\"⏰ === SISTEMA DE EXPLORACIÓN TEMPORAL ===\")\n\n# TODO: Implementar explorador temporal\nclass ExploradorTemporal:\n    def __init__(self):\n        self.lineas_temporales = []\n        self.paradojas_detectadas = []\n        self.eventos_alterados = []\n        self.energia_temporal = 100.0\n    \n    # TODO: Viajar en el tiempo\n    def viajar_tiempo(self, destino_temporal, duracion):\n        # Realizar viaje temporal\n        pass\n    \n    # TODO: Detectar paradojas\n    def detectar_paradojas(self):\n        # Identificar inconsistencias temporales\n        pass\n    \n    # TODO: Corregir línea temporal\n    def corregir_linea_temporal(self, paradoja_id):\n        # Restaurar continuidad temporal\n        pass\n    \n    # TODO: Mapear consecuencias\n    def mapear_consecuencias(self, accion, momento_temporal):\n        # Calcular efectos de cambios temporales\n        pass\n\n# Configuración del explorador\nexplorador = ExploradorTemporal()\n\nprint(\"⏰ Inicializando explorador temporal...\")\nprint(\"? Calibrando flujo temporal\")\nprint(\"? Sistema de navegación temporal activo\")',NULL,''),(40,14,1,'Optimiza un algoritmo de búsqueda lineal implementando técnicas de early termination y cache-friendly access patterns.',NULL,4,0,4,800,0,'print(\"? === RED DE COMUNICACIÓN GALÁCTICA ===\")\n\n# TODO: Implementar red galáctica\nclass RedComunicacionGalactica:\n    def __init__(self):\n        self.nodos_comunicacion = []\n        self.canales_activos = {}\n        self.protocolos_encriptacion = []\n        self.latencia_promedio = 0.0\n    \n    # TODO: Establecer nodo\n    def establecer_nodo(self, ubicacion, potencia_señal):\n        # Crear nuevo nodo de comunicación\n        pass\n    \n    # TODO: Enrutar mensaje\n    def enrutar_mensaje(self, origen, destino, mensaje):\n        # Encontrar ruta óptima para el mensaje\n        pass\n    \n    # TODO: Encriptar comunicación\n    def encriptar_comunicacion(self, mensaje, nivel_seguridad):\n        # Aplicar encriptación cuántica\n        pass\n    \n    # TODO: Optimizar red\n    def optimizar_red(self):\n        # Mejorar eficiencia de la red\n        pass\n\n# Configuración de la red\nred_galactica = RedComunicacionGalactica()\n\nprint(\"? Inicializando red galáctica...\")\nprint(\"? Estableciendo nodos de comunicación\")\nprint(\"? Sistema de encriptación cuántica activo\")',NULL,''),(41,14,2,'Implementa un algoritmo genético para resolver el problema de optimización de funciones multimodales.',NULL,5,0,5,800,0,'print(\"?️ === SISTEMA DE COLONIZACIÓN PLANETARIA ===\")\n\n# TODO: Implementar sistema de colonización\nclass SistemaColonizacion:\n    def __init__(self):\n        self.planetas_candidatos = []\n        self.colonias_establecidas = []\n        self.recursos_colonizacion = {}\n        self.poblacion_total = 0\n    \n    # TODO: Evaluar planeta\n    def evaluar_planeta_colonizacion(self, datos_planeta):\n        # Analizar viabilidad para colonización\n        pass\n    \n    # TODO: Establecer colonia\n    def establecer_colonia(self, planeta, poblacion_inicial, recursos):\n        # Crear nueva colonia\n        pass\n    \n    # TODO: Gestionar crecimiento\n    def gestionar_crecimiento_poblacional(self, colonia_id):\n        # Administrar expansión de la colonia\n        pass\n    \n    # TODO: Coordinar suministros\n    def coordinar_suministros(self, origen, destino, recursos):\n        # Organizar transporte de recursos\n        pass\n\n# Configuración del sistema\ncolonizador = SistemaColonizacion()\n\nprint(\"?️ Inicializando sistema de colonización...\")\nprint(\"? Evaluando planetas candidatos\")\nprint(\"? Sistema de expansión galáctica activo\")',NULL,''),(42,14,3,'Crea un optimizador de consultas SQL básico que pueda reordenar joins y seleccionar índices óptimos.',NULL,5,0,5,800,0,'print(\"⚔️ === SIMULADOR DE BATALLAS ESPACIALES ===\")\n\n# TODO: Implementar simulador de combate\nclass SimuladorBatallas:\n    def __init__(self):\n        self.flotas_activas = []\n        self.campo_batalla = {}\n        self.tacticas_disponibles = []\n        self.resultado_batalla = None\n    \n    # TODO: Crear flota\n    def crear_flota(self, nombre, naves, comandante):\n        # Configurar flota de combate\n        pass\n    \n    # TODO: Planificar estrategia\n    def planificar_estrategia(self, flota_id, tactica, formacion):\n        # Definir estrategia de combate\n        pass\n    \n    # TODO: Simular combate\n    def simular_combate(self, flota1_id, flota2_id):\n        # Ejecutar simulación de batalla\n        pass\n    \n    # TODO: Calcular daños\n    def calcular_danos(self, atacante, defensor, tipo_arma):\n        # Determinar daño causado\n        pass\n\n# Configuración del simulador\nsimulador = SimuladorBatallas()\n\nprint(\"⚔️ Inicializando simulador de batallas...\")\nprint(\"? Configurando flotas espaciales\")\nprint(\"? Sistema de combate táctico activo\")',NULL,''),(43,15,1,'Implementa una búsqueda A* simple para encontrar el camino más corto en una cuadrícula 2D con obstáculos.',NULL,4,0,4,900,0,'print(\"? === GENERADOR DE UNIVERSOS PROCEDURALES ===\")\n\n# TODO: Implementar generador universal\nclass GeneradorUniversos:\n    def __init__(self):\n        self.galaxias_generadas = []\n        self.leyes_fisicas = {}\n        self.semilla_aleatoria = 0\n        self.parametros_universo = {}\n    \n    # TODO: Configurar leyes físicas\n    def configurar_leyes_fisicas(self, gravedad, velocidad_luz, constantes):\n        # Definir reglas del universo\n        pass\n    \n    # TODO: Generar galaxia\n    def generar_galaxia(self, tipo, tamaño, densidad_estelar):\n        # Crear nueva galaxia\n        pass\n    \n    # TODO: Poblar sistemas\n    def poblar_sistemas_estelares(self, galaxia_id, probabilidad_vida):\n        # Añadir sistemas planetarios\n        pass\n    \n    # TODO: Simular evolución\n    def simular_evolucion_temporal(self, años_simulacion):\n        # Evolucionar el universo en el tiempo\n        pass\n\n# Configuración del generador\ngenerador = GeneradorUniversos()\n\nprint(\"? Inicializando generador de universos...\")\nprint(\"⚛️ Configurando leyes físicas\")\nprint(\"? Sistema de generación procedural activo\")',NULL,''),(44,15,2,'Crea un motor de búsqueda de texto que implemente algoritmos de matching de patrones como KMP y Rabin-Karp.',NULL,5,0,5,900,0,'print(\"? === SISTEMA DE ASCENSIÓN TECNOLÓGICA ===\")\n\n# TODO: Implementar árbol tecnológico\nclass SistemaAscension:\n    def __init__(self):\n        self.tecnologias_disponibles = []\n        self.investigaciones_activas = []\n        self.nivel_civilizacion = 1\n        self.puntos_investigacion = 0\n    \n    # TODO: Investigar tecnología\n    def investigar_tecnologia(self, tech_id, recursos_asignados):\n        # Avanzar en investigación\n        pass\n    \n    # TODO: Desbloquear avances\n    def desbloquear_avances(self, tecnologia_completada):\n        # Activar nuevas tecnologías\n        pass\n    \n    # TODO: Calcular progreso\n    def calcular_progreso_civilizacion(self):\n        # Evaluar nivel de desarrollo\n        pass\n    \n    # TODO: Simular singularidad\n    def simular_singularidad_tecnologica(self):\n        # Evento de ascensión final\n        pass\n\n# Configuración del sistema\nascension = SistemaAscension()\n\nprint(\"? Inicializando sistema de ascensión...\")\nprint(\"? Configurando árbol tecnológico\")\nprint(\"? Camino hacia la singularidad activado\")',NULL,''),(45,15,3,'Implementa un sistema de búsqueda distribuida que pueda indexar y buscar en múltiples nodos de manera eficiente.',NULL,5,0,5,900,0,'print(\"? === SIMULADOR DE REALIDAD CÓSMICA ===\")\n\n# TODO: Implementar simulador maestro\nclass SimuladorRealidadCosmica:\n    def __init__(self):\n        self.universos_paralelos = []\n        self.dimensiones_activas = {}\n        self.entidades_cosmicas = []\n        self.realidad_base = None\n    \n    # TODO: Crear realidad\n    def crear_realidad(self, parametros_fundamentales):\n        # Generar nueva realidad cósmica\n        pass\n    \n    # TODO: Gestionar multiverso\n    def gestionar_multiverso(self, interacciones_dimensionales):\n        # Coordinar múltiples realidades\n        pass\n    \n    # TODO: Simular eventos cósmicos\n    def simular_eventos_cosmicos(self, tipo_evento, escala_temporal):\n        # Ejecutar eventos a escala universal\n        pass\n    \n    # TODO: Integrar todos los sistemas\n    def integrar_sistemas_previos(self, lista_sistemas):\n        # Combinar todos los proyectos anteriores\n        pass\n    \n    # TODO: Alcanzar omnisciencia\n    def alcanzar_omnisciencia_cosmica(self):\n        # Logro final del programa\n        pass\n\n# Configuración del simulador maestro\nsimulador_maestro = SimuladorRealidadCosmica()\n\nprint(\"? Inicializando simulador de realidad cósmica...\")\nprint(\"? Integrando todos los sistemas desarrollados\")\nprint(\"⚡ Preparando para simulación universal\")\nprint(\"\n✨ ¡PROYECTO FINAL ASTROCODE COMPLETADO!\")\nprint(\"? ¡Felicidades, has dominado la programación cósmica!\")',NULL,'');
/*!40000 ALTER TABLE `tareas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tareas_usuarios`
--

DROP TABLE IF EXISTS `tareas_usuarios`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tareas_usuarios` (
  `usuario_id` bigint NOT NULL,
  `tarea_id` bigint NOT NULL,
  `completado_el` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `tiempo_completado` time DEFAULT NULL,
  `puntos_base` int DEFAULT NULL,
  `puntos_bonus` int DEFAULT NULL,
  `puntos_totales` int DEFAULT NULL,
  PRIMARY KEY (`usuario_id`,`tarea_id`),
  KEY `tarea_id` (`tarea_id`),
  CONSTRAINT `tareas_usuarios_ibfk_1` FOREIGN KEY (`usuario_id`) REFERENCES `usuarios` (`id`),
  CONSTRAINT `tareas_usuarios_ibfk_2` FOREIGN KEY (`tarea_id`) REFERENCES `tareas` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tareas_usuarios`
--

LOCK TABLES `tareas_usuarios` WRITE;
/*!40000 ALTER TABLE `tareas_usuarios` DISABLE KEYS */;
INSERT INTO `tareas_usuarios` VALUES (2,1,'2025-06-29 20:11:01','00:04:01',50,0,50);
/*!40000 ALTER TABLE `tareas_usuarios` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tiempos_finalizacion`
--

DROP TABLE IF EXISTS `tiempos_finalizacion`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tiempos_finalizacion` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `umbral` time NOT NULL,
  `puntos_bonus` int NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tiempos_finalizacion`
--

LOCK TABLES `tiempos_finalizacion` WRITE;
/*!40000 ALTER TABLE `tiempos_finalizacion` DISABLE KEYS */;
INSERT INTO `tiempos_finalizacion` VALUES (1,'00:02:00',100),(2,'00:05:00',75),(3,'00:10:00',50),(4,'00:15:00',25),(5,'00:30:00',10);
/*!40000 ALTER TABLE `tiempos_finalizacion` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `usuarios`
--

DROP TABLE IF EXISTS `usuarios`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `usuarios` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nombre_usuario` varchar(255) NOT NULL,
  `correo_electronico` varchar(255) NOT NULL,
  `contrasena_hash` text NOT NULL,
  `nombre_completo` varchar(255) DEFAULT NULL,
  `puntos` int DEFAULT '0',
  `creado_el` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `nombre_usuario` (`nombre_usuario`),
  UNIQUE KEY `correo_electronico` (`correo_electronico`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `usuarios`
--

LOCK TABLES `usuarios` WRITE;
/*!40000 ALTER TABLE `usuarios` DISABLE KEYS */;
INSERT INTO `usuarios` VALUES (1,'testuser','test@example.com','$2b$10$pXTcHSWaIMH0vAyF/RrE1uJRNntWoXjYoQQMwzlK1TdFBJNLdkqrK','Usuario de Prueba',120,'2025-06-19 15:28:21'),(2,'michu','michu@gmail.com','$2b$12$v6tYh7cC06jk4iwMPli9ReNTY2SkMc2osr4A4n4z7HZXu9y63z0Am','Miguel Mier',1050,'2025-06-19 15:54:47'),(3,'marinita','marina@gmail.com','$2b$12$ATweMvWUBsN3sv4RWYu.Ku3SMnjvJs9WodYVLXDJ4ZDDUkl.MKRVi','Marina Izquierdo',9999,'2025-06-19 17:47:37'),(4,'merins','m@a.com','$2b$12$.E7UBjM2ul893sq9D0mADOPhkI0oLvdlwkrz1LHWep5Eha8F7JHDW','Marinita',0,'2025-06-19 17:48:40');
/*!40000 ALTER TABLE `usuarios` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-06-30 22:13:56
