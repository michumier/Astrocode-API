CREATE DATABASE  IF NOT EXISTS `astrocodebd` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `astrocodebd`;
-- MySQL dump 10.13  Distrib 8.0.42, for Win64 (x86_64)
--
-- Host: localhost    Database: astrocodebd
-- ------------------------------------------------------
-- Server version	8.0.42

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `categorias`
--

DROP TABLE IF EXISTS `categorias`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `categorias` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nombre` varchar(255) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `nombre` (`nombre`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `categorias`
--

LOCK TABLES `categorias` WRITE;
/*!40000 ALTER TABLE `categorias` DISABLE KEYS */;
INSERT INTO `categorias` VALUES (11,'Algoritmos Avanzados'),(15,'Algoritmos de Búsqueda'),(8,'Algoritmos de Ordenamiento'),(6,'Arrays y Listas'),(4,'Bucles'),(3,'Estructuras Condicionales'),(10,'Estructuras de Datos'),(5,'Funciones'),(13,'Grafos y Árboles'),(7,'Objetos y Clases'),(2,'Operadores'),(14,'Optimización'),(12,'Programación Dinámica'),(9,'Recursión'),(1,'Variables y Tipos');
/*!40000 ALTER TABLE `categorias` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `embeddings`
--

DROP TABLE IF EXISTS `embeddings`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `embeddings` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `content` text NOT NULL,
  `embedding` json NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `embeddings`
--

LOCK TABLES `embeddings` WRITE;
/*!40000 ALTER TABLE `embeddings` DISABLE KEYS */;
/*!40000 ALTER TABLE `embeddings` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `insignias`
--

DROP TABLE IF EXISTS `insignias`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `insignias` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nombre` varchar(255) NOT NULL,
  `descripcion` text,
  `url_imagen` varchar(512) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `nombre` (`nombre`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `insignias`
--

LOCK TABLES `insignias` WRITE;
/*!40000 ALTER TABLE `insignias` DISABLE KEYS */;
/*!40000 ALTER TABLE `insignias` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `insignias_usuarios`
--

DROP TABLE IF EXISTS `insignias_usuarios`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `insignias_usuarios` (
  `usuario_id` bigint NOT NULL,
  `insignia_id` bigint NOT NULL,
  `ganado_el` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`usuario_id`,`insignia_id`),
  KEY `insignia_id` (`insignia_id`),
  CONSTRAINT `insignias_usuarios_ibfk_1` FOREIGN KEY (`usuario_id`) REFERENCES `usuarios` (`id`),
  CONSTRAINT `insignias_usuarios_ibfk_2` FOREIGN KEY (`insignia_id`) REFERENCES `insignias` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `insignias_usuarios`
--

LOCK TABLES `insignias_usuarios` WRITE;
/*!40000 ALTER TABLE `insignias_usuarios` DISABLE KEYS */;
/*!40000 ALTER TABLE `insignias_usuarios` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `migrations`
--

DROP TABLE IF EXISTS `migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `migrations` (
  `version` varchar(255) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `applied_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`version`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `migrations`
--

LOCK TABLES `migrations` WRITE;
/*!40000 ALTER TABLE `migrations` DISABLE KEYS */;
/*!40000 ALTER TABLE `migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `niveles`
--

DROP TABLE IF EXISTS `niveles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `niveles` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nombre` varchar(255) NOT NULL,
  `puntos` int NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `nombre` (`nombre`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `niveles`
--

LOCK TABLES `niveles` WRITE;
/*!40000 ALTER TABLE `niveles` DISABLE KEYS */;
INSERT INTO `niveles` VALUES (1,'Fácil',50),(2,'Intermedio',200),(3,'Difícil',500);
/*!40000 ALTER TABLE `niveles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tareas`
--

DROP TABLE IF EXISTS `tareas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tareas` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `categoria_id` bigint NOT NULL,
  `nivel_id` bigint NOT NULL,
  `descripcion` text NOT NULL,
  `fecha_vencimiento` date DEFAULT NULL,
  `prioridad` int DEFAULT NULL,
  `completado` tinyint(1) DEFAULT '0',
  `tiempo_finalizacion_id` bigint DEFAULT NULL,
  `puntos_base` int DEFAULT NULL,
  `puntos_bonus` int DEFAULT '0',
  `codigo_base` text COMMENT 'Código base/plantilla para el ejercicio',
  `resultado_esperado` text COMMENT 'Resultado esperado que debe mostrar el código al ejecutarse',
  `titulo` varchar(255) NOT NULL DEFAULT '' COMMENT 'Título descriptivo del ejercicio',
  PRIMARY KEY (`id`),
  KEY `categoria_id` (`categoria_id`),
  KEY `nivel_id` (`nivel_id`),
  KEY `tiempo_finalizacion_id` (`tiempo_finalizacion_id`),
  CONSTRAINT `tareas_ibfk_1` FOREIGN KEY (`categoria_id`) REFERENCES `categorias` (`id`),
  CONSTRAINT `tareas_ibfk_2` FOREIGN KEY (`nivel_id`) REFERENCES `niveles` (`id`),
  CONSTRAINT `tareas_ibfk_3` FOREIGN KEY (`tiempo_finalizacion_id`) REFERENCES `tiempos_finalizacion` (`id`),
  CONSTRAINT `tareas_chk_1` CHECK ((`prioridad` between 1 and 5))
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tareas`
--

LOCK TABLES `tareas` WRITE;
/*!40000 ALTER TABLE `tareas` DISABLE KEYS */;
INSERT INTO `tareas` VALUES (1,1,1,'? **Misión: Configuración de Nave Espacial**\n\nComo nuevo cadete de AstroCode, tu primera misión es configurar los sistemas básicos de tu nave espacial. Debes declarar una variable para almacenar la edad del comandante.\n\n**Contexto de la misión:**\nEstás a bordo de la estación espacial AstroCode-1, preparándote para tu primer viaje intergaláctico. El sistema de navegación requiere que registres la edad del comandante para calcular los parámetros de vuelo.\n\n**Objetivos:**\n- Declara una variable llamada \"edad\" de tipo entero\n- Asígnale el valor 25\n- Imprime su valor en la consola con un mensaje espacial\n\n¡Completa esta configuración para poder despegar hacia las estrellas! ?',NULL,3,0,1,50,0,'console.log(\"? === REGISTRO DE COMANDANTE ESPACIAL ===\");\n\n// TODO: Declara la variable edad y asígnale el valor 25\n\n// TODO: Imprime el valor con un mensaje\nconsole.log(`Edad del comandante: ${edad} años terrestres`);\nconsole.log(\"✅ Comandante registrado - Listo para el despegue!\");','? === REGISTRO DE COMANDANTE ESPACIAL ===\nEdad del comandante: 25 años terrestres\n✅ Comandante registrado - Listo para el despegue!','Variables Espaciales Básicas'),(2,1,2,'?️ **Misión: Sistema de Telemetría Avanzada**\n\nComo ingeniero de sistemas de la estación AstroCode, debes crear un programa de telemetría que maneje diferentes tipos de datos de la nave y realice conversiones entre ellos.\n\n**Contexto de la misión:**\nLos sensores de la nave envían datos en diferentes formatos. Tu sistema debe procesar y convertir estos datos para que sean compatibles con el ordenador central.\n\n**Objetivos:**\n- Declara variables de diferentes tipos (entero, flotante, string, booleano)\n- Realiza conversiones entre tipos\n- Muestra los resultados de cada conversión\n\n**Datos de sensores:**\n- Velocidad: \"2500\" (string) → convertir a número\n- Temperatura: 98.6 (float) → convertir a entero\n- Coordenada X: 42 (int) → convertir a string\n- Sistema activo: 1 (int) → convertir a booleano\n\n? ¡La precisión de los datos es crucial para la navegación!',NULL,3,0,2,200,0,'console.log(\"?️ === SISTEMA DE TELEMETRÍA ESPACIAL ===\");\n\n// Datos de sensores\nlet velocidadStr = \"2500\";\nlet temperatura = 98.6;\nlet coordenadaX = 42;\nlet sistemaActivo = 1;\n\nconsole.log(\"? Datos originales:\");\nconsole.log(`Velocidad (string): ${velocidadStr}`);\nconsole.log(`Temperatura (float): ${temperatura}`);\nconsole.log(`Coordenada X (int): ${coordenadaX}`);\nconsole.log(`Sistema activo (int): ${sistemaActivo}`);\n\n// TODO: Realizar conversiones\nlet velocidadNum = // Convertir velocidadStr a número\nlet temperaturaInt = // Convertir temperatura a entero\nlet coordenadaStr = // Convertir coordenadaX a string\nlet sistemaBoolean = // Convertir sistemaActivo a booleano\n\nconsole.log(\"\n? Datos convertidos:\");\nconsole.log(`Velocidad (number): ${velocidadNum} km/h`);\nconsole.log(`Temperatura (int): ${temperaturaInt}°C`);\nconsole.log(`Coordenada X (string): \"${coordenadaStr}\"`);\nconsole.log(`Sistema activo (boolean): ${sistemaBoolean}`);\nconsole.log(\"\n✅ Telemetría procesada correctamente!\");','?️ === SISTEMA DE TELEMETRÍA ESPACIAL ===\n? Datos originales:\nVelocidad (string): 2500\nTemperatura (float): 98.6\nCoordenada X (int): 42\nSistema activo (int): 1\n\n? Datos convertidos:\nVelocidad (number): 2500 km/h\nTemperatura (int): 98°C\nCoordenada X (string): \"42\"\nSistema activo (boolean): true\n\n✅ Telemetría procesada correctamente!','Sistema de Tipos Avanzado Espacial'),(3,1,3,'? LABORATORIO DE TIPOS CUÁNTICOS ESPACIALES ?\n\nComo científico jefe de la estación AstroCode, debes crear un sistema avanzado de tipos dinámicos que pueda detectar automáticamente el tipo de datos de muestras extraterrestres y realizar operaciones seguras entre diferentes tipos de materia cósmica. El sistema debe manejar conversiones entre elementos conocidos (hidrógeno, helio) y elementos desconocidos, manteniendo la integridad de los datos durante las transformaciones cuánticas.',NULL,4,0,4,500,0,'console.log(\"? === LABORATORIO DE TIPOS CUÁNTICOS ===\\n\");\n\n// Sistema de detección automática de tipos\nclass DetectorTipos {\n    // TODO: Implementar detección automática de tipos\n    static detectarTipo(muestra) {\n        // Implementar lógica de detección\n    }\n    \n    // TODO: Implementar conversiones seguras\n    static convertirSeguro(valor, tipoDestino) {\n        // Implementar conversiones con validación\n    }\n    \n    // TODO: Implementar operaciones entre tipos\n    static operarTipos(valor1, valor2, operacion) {\n        // Implementar operaciones seguras\n    }\n}\n\n// Muestras de prueba\nlet muestras = [42, \"Helio-3\", 3.14159, true, null, {elemento: \"Hidrógeno\"}];\n\nconsole.log(\"? Analizando muestras extraterrestres:\");\nmuestras.forEach((muestra, index) => {\n    // TODO: Usar DetectorTipos para analizar cada muestra\n    console.log(`Muestra ${index + 1}: ${muestra} -> Tipo: [IMPLEMENTAR]`);\n});\n\nconsole.log(\"\\n? Pruebas de conversión segura:\");\n// TODO: Implementar pruebas de conversión\n\nconsole.log(\"\\n⚗️ Análisis completado\");','? === LABORATORIO DE TIPOS CUÁNTICOS ===\n\n? Analizando muestras extraterrestres:\nMuestra 1: 42 -> Tipo: number\nMuestra 2: Helio-3 -> Tipo: string\nMuestra 3: 3.14159 -> Tipo: number\nMuestra 4: true -> Tipo: boolean\nMuestra 5: null -> Tipo: null\nMuestra 6: [object Object] -> Tipo: object\n\n? Pruebas de conversión segura:\n✅ Conversión 42 -> string: \"42\"\n✅ Conversión \"3.14\" -> number: 3.14\n⚠️ Conversión \"Helio-3\" -> number: NaN (conversión insegura)\n✅ Operación segura: 42 + 3.14 = 45.14\n\n⚗️ Análisis completado','Sistema de Tipos Genéricos Universales'),(4,2,1,'? **Misión: Calculadora de Combustible Espacial**\n\nComo técnico de combustible en la estación AstroCode, debes crear un programa que calcule el consumo de combustible para diferentes maniobras espaciales.\n\n**Contexto de la misión:**\nLa nave necesita realizar cálculos precisos de combustible antes de cada maniobra. Tu calculadora debe usar operadores aritméticos para determinar el combustible necesario.\n\n**Objetivos:**\n- Usa operadores aritméticos (+, -, *, /, %) \n- Calcula combustible para aceleración, frenado y maniobras\n- Muestra los resultados de cada operación\n\n**Datos de entrada:**\n- Combustible inicial: 1000 litros\n- Consumo por aceleración: 150 litros\n- Consumo por frenado: 75 litros\n\n⛽ ¡Cada gota de combustible cuenta en el espacio!',NULL,3,0,1,75,0,'console.log(\"? === CALCULADORA DE COMBUSTIBLE ESPACIAL ===\");\n\n// Datos iniciales\nlet combustibleInicial = 1000;\nlet consumoAceleracion = 150;\nlet consumoFrenado = 75;\nlet numeroManiobras = 3;\n\nconsole.log(`⛽ Combustible inicial: ${combustibleInicial} litros`);\nconsole.log(`? Consumo por aceleración: ${consumoAceleracion} litros`);\nconsole.log(`? Consumo por frenado: ${consumoFrenado} litros`);\nconsole.log(`? Número de maniobras: ${numeroManiobras}`);\n\n// TODO: Realizar cálculos con operadores aritméticos\nlet consumoTotal = // Suma de aceleración y frenado\nlet consumoPorManiobra = // Consumo total multiplicado por número de maniobras\nlet combustibleRestante = // Combustible inicial menos consumo total\nlet porcentajeRestante = // Porcentaje de combustible restante\nlet combustibleExtra = // Combustible restante módulo 100\n\nconsole.log(\"\n? Resultados de cálculos:\");\nconsole.log(`Consumo por maniobra: ${consumoTotal} litros`);\nconsole.log(`Consumo total misión: ${consumoPorManiobra} litros`);\nconsole.log(`Combustible restante: ${combustibleRestante} litros`);\nconsole.log(`Porcentaje restante: ${porcentajeRestante.toFixed(1)}%`);\nconsole.log(`Combustible extra: ${combustibleExtra} litros`);','? === CALCULADORA DE COMBUSTIBLE ESPACIAL ===\n⛽ Combustible inicial: 1000 litros\n? Consumo por aceleración: 150 litros\n? Consumo por frenado: 75 litros\n? Número de maniobras: 3\n\n? Resultados de cálculos:\nConsumo por maniobra: 225 litros\nConsumo total misión: 675 litros\nCombustible restante: 325 litros\nPorcentaje restante: 32.5%\nCombustible extra: 25 litros','Operaciones Matemáticas Galácticas'),(5,2,2,'? **Misión: Calculadora de Navegación Avanzada**\n\nComo ingeniero de sistemas de AstroCode, debes crear una calculadora avanzada que maneje operadores lógicos y de comparación para evaluar condiciones de vuelo complejas.\n\n**Contexto de la misión:**\nLa nave necesita evaluar múltiples condiciones simultáneamente para determinar si es seguro realizar maniobras complejas. Tu calculadora debe procesar expresiones con paréntesis y operadores múltiples.\n\n**Objetivos:**\n- Implementa evaluación de expresiones con paréntesis\n- Usa operadores lógicos (&&, ||, !) y de comparación\n- Evalúa condiciones de seguridad de vuelo\n- Maneja precedencia de operadores\n\n**Condiciones a evaluar:**\n- Combustible > 500 && Escudos == true\n- (Velocidad < 1000 || Emergencia == false) && Tripulacion >= 3\n\n? ¡La precisión en los cálculos puede salvar vidas!',NULL,3,0,3,250,0,'console.log(\"? === CALCULADORA DE NAVEGACIÓN AVANZADA ===\");\n\n// Datos de la nave\nlet combustible = 750;\nlet escudos = true;\nlet velocidad = 850;\nlet emergencia = false;\nlet tripulacion = 4;\n\nconsole.log(\"? Estado actual de la nave:\");\nconsole.log(`⛽ Combustible: ${combustible} litros`);\nconsole.log(`?️ Escudos: ${escudos ? \"Activados\" : \"Desactivados\"}`);\nconsole.log(`? Velocidad: ${velocidad} km/h`);\nconsole.log(`? Emergencia: ${emergencia ? \"SÍ\" : \"NO\"}`);\nconsole.log(`? Tripulación: ${tripulacion} personas`);\n\n// TODO: Evaluar condiciones de seguridad\nlet condicion1 = // combustible > 500 && escudos == true\nlet condicion2 = // (velocidad < 1000 || emergencia == false) && tripulacion >= 3\n\nconsole.log(\"\n? Evaluación de condiciones:\");\nconsole.log(`Condición 1 (Combustible y Escudos): ${condicion1 ? \"✅ CUMPLE\" : \"❌ NO CUMPLE\"}`);\nconsole.log(`Condición 2 (Velocidad y Tripulación): ${condicion2 ? \"✅ CUMPLE\" : \"❌ NO CUMPLE\"}`);\n\n// Evaluación final\nlet maniobrasSeguras = condicion1 && condicion2;\nconsole.log(`\n? Resultado final: ${maniobrasSeguras ? \"✅ MANIOBRAS AUTORIZADAS\" : \"❌ MANIOBRAS DENEGADAS\"}`);','? === CALCULADORA DE NAVEGACIÓN AVANZADA ===\n? Estado actual de la nave:\n⛽ Combustible: 750 litros\n?️ Escudos: Activados\n? Velocidad: 850 km/h\n? Emergencia: NO\n? Tripulación: 4 personas\n\n? Evaluación de condiciones:\nCondición 1 (Combustible y Escudos): ✅ CUMPLE\nCondición 2 (Velocidad y Tripulación): ✅ CUMPLE\n\n? Resultado final: ✅ MANIOBRAS AUTORIZADAS','Calculadora Científica Galáctica'),(6,2,3,'? INTÉRPRETE DE COMANDOS GALÁCTICOS ?\n\nDesarrolla un intérprete avanzado de expresiones matemáticas para el sistema de navegación de la nave AstroCode. El intérprete debe evaluar operadores personalizados para cálculos de trayectorias espaciales y funciones definidas por el usuario para maniobras complejas. Incluye operadores como distancia_estelar(), velocidad_warp() y coordenadas_galácticas().',NULL,4,0,5,600,0,'console.log(\"? === INTÉRPRETE DE COMANDOS GALÁCTICOS ===\\n\");\n\n// Intérprete de expresiones espaciales\nclass InterpreteGalactico {\n    constructor() {\n        this.operadores = new Map();\n        this.funciones = new Map();\n        this.inicializarOperadores();\n    }\n    \n    // TODO: Inicializar operadores personalizados\n    inicializarOperadores() {\n        // Implementar operadores espaciales\n    }\n    \n    // TODO: Registrar función personalizada\n    registrarFuncion(nombre, funcion) {\n        // Implementar registro de funciones\n    }\n    \n    // TODO: Evaluar expresión completa\n    evaluar(expresion) {\n        // Implementar evaluación con precedencia\n    }\n    \n    // TODO: Parsear tokens\n    parsear(expresion) {\n        // Implementar parser de expresiones\n    }\n}\n\n// Crear intérprete\nlet interprete = new InterpreteGalactico();\n\n// TODO: Registrar funciones espaciales\ninterprete.registrarFuncion(\"distancia_estelar\", (x1, y1, x2, y2) => {\n    // Implementar cálculo de distancia\n});\n\n// Expresiones de prueba\nlet expresiones = [\n    \"2 + 3 * 4\",\n    \"distancia_estelar(0, 0, 3, 4)\",\n    \"(velocidad_warp(5) + 2) * factor_tiempo(0.8)\"\n];\n\nconsole.log(\"? Evaluando comandos de navegación:\");\nexpresiones.forEach(expr => {\n    // TODO: Evaluar cada expresión\n    console.log(`${expr} = [IMPLEMENTAR]`);\n});\n\nconsole.log(\"\\n? Sistema de navegación listo\");','? === INTÉRPRETE DE COMANDOS GALÁCTICOS ===\n\n? Evaluando comandos de navegación:\n2 + 3 * 4 = 14\ndistancia_estelar(0, 0, 3, 4) = 5\n(velocidad_warp(5) + 2) * factor_tiempo(0.8) = 5.6\n\n? Sistema de navegación listo','Sobrecarga de Operadores Cuánticos'),(7,3,1,'?️ **Misión: Monitor de Temperatura Espacial**\n\nComo especialista en sistemas ambientales de AstroCode, debes crear un programa que monitoree la temperatura de la nave y determine si está en rangos seguros.\n\n**Contexto de la misión:**\nLa temperatura en el espacio puede ser extrema. Tu sistema debe analizar las lecturas de temperatura y clasificarlas para mantener la seguridad de la tripulación.\n\n**Objetivos:**\n- Determina si una temperatura es positiva, negativa o cero\n- Usa estructuras if-else para la clasificación\n- Proporciona mensajes de estado apropiados\n\n**Rangos de temperatura:**\n- Positiva: Zona habitable\n- Cero: Punto de congelación\n- Negativa: Zona peligrosa\n\n?️ ¡La vida de la tripulación depende de estos sistemas!',NULL,3,0,1,100,0,'console.log(\"?️ === MONITOR DE TEMPERATURA ESPACIAL ===\");\n\n// Lectura de temperatura del sensor\nlet temperatura = -15; // Puedes cambiar este valor para probar\n\nconsole.log(`? Temperatura detectada: ${temperatura}°C`);\n\n// TODO: Implementar estructuras condicionales\nif (/* condición para temperatura positiva */) {\n    console.log(\"✅ Estado: ZONA HABITABLE\");\n    console.log(\"? Temperatura segura para la tripulación\");\n} else if (/* condición para temperatura cero */) {\n    console.log(\"⚠️ Estado: PUNTO DE CONGELACIÓN\");\n    console.log(\"? Activar sistemas de calefacción\");\n} else {\n    console.log(\"❌ Estado: ZONA PELIGROSA\");\n    console.log(\"? ALERTA: Temperatura crítica detectada\");\n}\n\nconsole.log(\"\n?️ Monitoreo completado\");','?️ === MONITOR DE TEMPERATURA ESPACIAL ===\n? Temperatura detectada: -15°C\n❌ Estado: ZONA PELIGROSA\n? ALERTA: Temperatura crítica detectada\n\n?️ Monitoreo completado','Decisiones de Navegación Espacial'),(8,3,2,'? **Misión: Sistema de Calificación de Planetas**\n\nComo científico planetario de AstroCode, debes crear un sistema que evalúe la habitabilidad de planetas descubiertos y les asigne una calificación basada en múltiples factores.\n\n**Contexto de la misión:**\nTu equipo ha descubierto varios exoplanetas. Necesitas un sistema automatizado que evalúe su potencial para albergar vida basándose en temperatura, atmósfera, agua y distancia a su estrella.\n\n**Objetivos:**\n- Implementa un sistema de calificación con múltiples criterios\n- Usa estructuras if-else anidadas o switch-case\n- Asigna calificaciones: A (Excelente), B (Bueno), C (Regular), D (Pobre), F (Inhabitable)\n- Proporciona recomendaciones específicas\n\n**Criterios de evaluación:**\n- Temperatura: 0-50°C (Óptima), -50-0°C o 50-100°C (Aceptable), otros (Extrema)\n- Agua: Abundante, Moderada, Escasa, Ninguna\n- Atmósfera: Respirable, Tóxica, Ninguna\n\n? ¡Cada planeta evaluado nos acerca a encontrar un nuevo hogar!',NULL,3,0,2,300,0,'console.log(\"? === SISTEMA DE CALIFICACIÓN DE PLANETAS ===\");\n\n// Datos del planeta a evaluar\nlet nombrePlaneta = \"Kepler-442b\";\nlet temperatura = 22; // °C\nlet agua = \"Moderada\"; // Abundante, Moderada, Escasa, Ninguna\nlet atmosfera = \"Respirable\"; // Respirable, Tóxica, Ninguna\nlet distanciaEstrella = 1.2; // UA (Unidades Astronómicas)\n\nconsole.log(`? Evaluando planeta: ${nombrePlaneta}`);\nconsole.log(`?️ Temperatura: ${temperatura}°C`);\nconsole.log(`? Agua: ${agua}`);\nconsole.log(`?️ Atmósfera: ${atmosfera}`);\nconsole.log(`⭐ Distancia a estrella: ${distanciaEstrella} UA`);\n\nlet puntuacion = 0;\nlet calificacion = \"\";\nlet recomendacion = \"\";\n\n// TODO: Evaluar temperatura\nif (temperatura >= 0 && temperatura <= 50) {\n    puntuacion += 30;\n    console.log(\"✅ Temperatura: Óptima (+30 puntos)\");\n} else if (/* condición para temperatura aceptable */) {\n    puntuacion += 15;\n    console.log(\"⚠️ Temperatura: Aceptable (+15 puntos)\");\n} else {\n    console.log(\"❌ Temperatura: Extrema (+0 puntos)\");\n}\n\n// TODO: Evaluar agua\nswitch (agua) {\n    case \"Abundante\":\n        puntuacion += 25;\n        console.log(\"✅ Agua: Abundante (+25 puntos)\");\n        break;\n    // Agregar casos para Moderada, Escasa, Ninguna\n}\n\n// TODO: Evaluar atmósfera\n// Implementar evaluación de atmósfera\n\n// TODO: Asignar calificación final\nif (puntuacion >= 80) {\n    calificacion = \"A\";\n    recomendacion = \"? EXCELENTE - Candidato prioritario para colonización\";\n} else if (/* otras condiciones */) {\n    // Implementar otras calificaciones\n}\n\nconsole.log(`\n? Puntuación total: ${puntuacion}/100`);\nconsole.log(`? Calificación: ${calificacion}`);\nconsole.log(`? Recomendación: ${recomendacion}`);','? === SISTEMA DE CALIFICACIÓN DE PLANETAS ===\n? Evaluando planeta: Kepler-442b\n?️ Temperatura: 22°C\n? Agua: Moderada\n?️ Atmósfera: Respirable\n⭐ Distancia a estrella: 1.2 UA\n✅ Temperatura: Óptima (+30 puntos)\n⚠️ Agua: Moderada (+15 puntos)\n✅ Atmósfera: Respirable (+35 puntos)\n\n? Puntuación total: 80/100\n? Calificación: A\n? Recomendación: ? EXCELENTE - Candidato prioritario para colonización','Sistema de Navegación Inteligente'),(9,3,3,'? SISTEMA DE PRÉSTAMOS INTERPLANETARIOS ?\n\nCrea un sistema avanzado de evaluación de préstamos para el Banco Galáctico AstroCode. El sistema debe evaluar múltiples condiciones anidadas para determinar la elegibilidad de préstamos para colonos espaciales, considerando factores como: ingresos en créditos galácticos, historial de misiones, planeta de origen, experiencia espacial, y riesgo de la colonia destino.',NULL,4,0,4,700,0,'console.log(\"? === BANCO GALÁCTICO ASTROCODE ===\\n\");\n\n// Sistema de evaluación de préstamos\nclass EvaluadorPrestamos {\n    // TODO: Implementar evaluación completa\n    static evaluarSolicitud(solicitante) {\n        let puntuacion = 0;\n        let factores = [];\n        \n        // TODO: Evaluar ingresos (peso: 30%)\n        if (/* condición ingresos altos */) {\n            // Implementar lógica\n        }\n        \n        // TODO: Evaluar historial de misiones (peso: 25%)\n        if (/* condición historial excelente */) {\n            // Implementar lógica\n        }\n        \n        // TODO: Evaluar planeta de origen (peso: 20%)\n        if (/* condición planeta seguro */) {\n            // Implementar lógica\n        }\n        \n        // TODO: Evaluar experiencia espacial (peso: 15%)\n        if (/* condición experiencia alta */) {\n            // Implementar lógica\n        }\n        \n        // TODO: Evaluar riesgo destino (peso: 10%)\n        if (/* condición destino seguro */) {\n            // Implementar lógica\n        }\n        \n        return { puntuacion, factores, aprobado: puntuacion >= 70 };\n    }\n}\n\n// Casos de prueba\nlet solicitantes = [\n    {\n        nombre: \"Comandante Zara\",\n        ingresos: 85000,\n        historialMisiones: \"excelente\",\n        planetaOrigen: \"Terra Nova\",\n        experienciaEspacial: 15,\n        destinoColonia: \"Kepler-442b\"\n    },\n    {\n        nombre: \"Piloto Kai\",\n        ingresos: 45000,\n        historialMisiones: \"bueno\",\n        planetaOrigen: \"Marte\",\n        experienciaEspacial: 5,\n        destinoColonia: \"Proxima-b\"\n    }\n];\n\nconsole.log(\"? Evaluando solicitudes de préstamo:\");\nsolicitantes.forEach(solicitante => {\n    // TODO: Evaluar cada solicitante\n    let resultado = EvaluadorPrestamos.evaluarSolicitud(solicitante);\n    console.log(`\\n? ${solicitante.nombre}:`);\n    console.log(`? Puntuación: ${resultado.puntuacion}/100`);\n    console.log(`${resultado.aprobado ? \"✅ APROBADO\" : \"❌ RECHAZADO\"}`);\n});\n\nconsole.log(\"\\n? Evaluación completada\");','? === BANCO GALÁCTICO ASTROCODE ===\n\n? Evaluando solicitudes de préstamo:\n\n? Comandante Zara:\n? Puntuación: 95/100\n✅ APROBADO\n\n? Piloto Kai:\n? Puntuación: 65/100\n❌ RECHAZADO\n\n? Evaluación completada','IA de Decisiones Espaciales'),(10,4,1,'? **Misión: Secuencia de Lanzamiento**\n\nComo controlador de lanzamiento en AstroCode, debes programar la secuencia de cuenta regresiva para el despegue de la nave espacial.\n\n**Contexto de la misión:**\nCada lanzamiento requiere una secuencia precisa de verificaciones. Tu programa debe generar la secuencia numérica y identificar los sistemas críticos (números pares).\n\n**Objetivos:**\n- Usa un bucle for para imprimir números del 1 al 10\n- Modifica el programa para mostrar solo números pares\n- Agrega mensajes de verificación de sistemas\n\n**Secuencia de verificación:**\n- Números 1-10: Verificación general\n- Números pares: Sistemas críticos\n\n? ¡Cada verificación es crucial para un lanzamiento exitoso!',NULL,3,0,1,125,0,'console.log(\"? === SECUENCIA DE LANZAMIENTO ASTROCODE ===\");\n\nconsole.log(\"\n? Verificación general de sistemas:\");\n// TODO: Bucle for para imprimir números del 1 al 10\nfor (let i = 1; i <= 10; i++) {\n    console.log(`Sistema ${i}: ✅ Verificado`);\n}\n\nconsole.log(\"\n? Verificación de sistemas críticos (números pares):\");\n// TODO: Bucle for para imprimir solo números pares\nfor (let i = 1; i <= 10; i++) {\n    if (/* condición para números pares */) {\n        console.log(`? Sistema crítico ${i}: ✅ OPERATIVO`);\n    }\n}\n\nconsole.log(\"\n? Secuencia de lanzamiento completada\");\nconsole.log(\"✅ Todos los sistemas verificados - LISTO PARA DESPEGUE!\");','? === SECUENCIA DE LANZAMIENTO ASTROCODE ===\n\n? Verificación general de sistemas:\nSistema 1: ✅ Verificado\nSistema 2: ✅ Verificado\nSistema 3: ✅ Verificado\nSistema 4: ✅ Verificado\nSistema 5: ✅ Verificado\nSistema 6: ✅ Verificado\nSistema 7: ✅ Verificado\nSistema 8: ✅ Verificado\nSistema 9: ✅ Verificado\nSistema 10: ✅ Verificado\n\n? Verificación de sistemas críticos (números pares):\n? Sistema crítico 2: ✅ OPERATIVO\n? Sistema crítico 4: ✅ OPERATIVO\n? Sistema crítico 6: ✅ OPERATIVO\n? Sistema crítico 8: ✅ OPERATIVO\n? Sistema crítico 10: ✅ OPERATIVO\n\n? Secuencia de lanzamiento completada\n✅ Todos los sistemas verificados - LISTO PARA DESPEGUE!','Cuenta Regresiva de Lanzamiento'),(11,4,2,'? **Misión: Generador de Secuencia Fibonacci Galáctica**\n\nComo matemático espacial de AstroCode, debes crear un generador de la secuencia de Fibonacci que simule los patrones de crecimiento de cristales energéticos encontrados en diferentes galaxias.\n\n**Contexto de la misión:**\nLos cristales energéticos descubiertos en la galaxia Andrómeda siguen un patrón de crecimiento basado en la secuencia de Fibonacci. Necesitas generar esta secuencia usando diferentes tipos de bucles para estudiar su comportamiento.\n\n**Objetivos:**\n- Implementa la secuencia de Fibonacci usando bucle for\n- Crea una versión con bucle while\n- Compara el rendimiento de ambas implementaciones\n- Genera los primeros 15 términos de la secuencia\n\n**Datos de los cristales:**\n- Secuencia inicial: 0, 1\n- Patrón: cada término = suma de los dos anteriores\n- Términos a generar: 15\n\n? ¡Estos cristales podrían ser la clave para viajes intergalácticos!',NULL,3,0,3,350,0,'console.log(\"? === GENERADOR DE SECUENCIA FIBONACCI GALÁCTICA ===\");\n\nconst terminos = 15;\nconsole.log(`? Generando ${terminos} términos de cristales energéticos`);\n\n// Implementación con bucle FOR\nconsole.log(\"\n? Método 1: Bucle FOR\");\nlet fibonacciFor = [0, 1];\nconsole.log(`Cristal 0: ${fibonacciFor[0]} unidades`);\nconsole.log(`Cristal 1: ${fibonacciFor[1]} unidades`);\n\n// TODO: Implementar con bucle for\nfor (let i = 2; i < terminos; i++) {\n    // Calcular siguiente término de Fibonacci\n    let siguiente = // suma de los dos términos anteriores\n    fibonacciFor.push(siguiente);\n    console.log(`Cristal ${i}: ${siguiente} unidades`);\n}\n\n// Implementación con bucle WHILE\nconsole.log(\"\n? Método 2: Bucle WHILE\");\nlet fibonacciWhile = [0, 1];\nlet contador = 2;\n\nconsole.log(`Cristal 0: ${fibonacciWhile[0]} unidades`);\nconsole.log(`Cristal 1: ${fibonacciWhile[1]} unidades`);\n\n// TODO: Implementar con bucle while\nwhile (contador < terminos) {\n    // Implementar lógica similar\n    contador++;\n}\n\n// Comparación de resultados\nconsole.log(\"\n? Análisis de cristales:\");\nconsole.log(`? Secuencia FOR: [${fibonacciFor.join(\", \")}]`);\nconsole.log(`? Secuencia WHILE: [${fibonacciWhile.join(\", \")}]`);\nconsole.log(`✅ Secuencias idénticas: ${JSON.stringify(fibonacciFor) === JSON.stringify(fibonacciWhile)}`);\n\nconst ultimoCristal = fibonacciFor[fibonacciFor.length - 1];\nconsole.log(`\n? Cristal más grande: ${ultimoCristal} unidades de energía`);','? === GENERADOR DE SECUENCIA FIBONACCI GALÁCTICA ===\n? Generando 15 términos de cristales energéticos\n\n? Método 1: Bucle FOR\nCristal 0: 0 unidades\nCristal 1: 1 unidades\nCristal 2: 1 unidades\nCristal 3: 2 unidades\nCristal 4: 3 unidades\nCristal 5: 5 unidades\nCristal 6: 8 unidades\nCristal 7: 13 unidades\nCristal 8: 21 unidades\nCristal 9: 34 unidades\nCristal 10: 55 unidades\nCristal 11: 89 unidades\nCristal 12: 144 unidades\nCristal 13: 233 unidades\nCristal 14: 377 unidades\n\n? Método 2: Bucle WHILE\nCristal 0: 0 unidades\nCristal 1: 1 unidades\nCristal 2: 1 unidades\nCristal 3: 2 unidades\nCristal 4: 3 unidades\nCristal 5: 5 unidades\nCristal 6: 8 unidades\nCristal 7: 13 unidades\nCristal 8: 21 unidades\nCristal 9: 34 unidades\nCristal 10: 55 unidades\nCristal 11: 89 unidades\nCristal 12: 144 unidades\nCristal 13: 233 unidades\nCristal 14: 377 unidades\n\n? Análisis de cristales:\n? Secuencia FOR: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n? Secuencia WHILE: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n✅ Secuencias idénticas: true\n\n? Cristal más grande: 377 unidades de energía','Simulador de Órbitas Complejas'),(12,4,3,'? OPTIMIZADOR DE RUTAS COMERCIALES GALÁCTICAS ?\n\nImplementa un algoritmo de optimización que use bucles anidados para resolver el problema del viajante comercial espacial. El sistema debe encontrar la ruta más eficiente para visitar todas las estaciones comerciales de la galaxia, minimizando el consumo de combustible cuántico y el tiempo de viaje entre planetas.',NULL,5,0,5,800,0,'console.log(\"? === OPTIMIZADOR DE RUTAS GALÁCTICAS ===\\n\");\n\n// Datos de estaciones comerciales\nlet estaciones = [\n    { nombre: \"Terra Nova\", x: 0, y: 0 },\n    { nombre: \"Marte Central\", x: 3, y: 4 },\n    { nombre: \"Europa Station\", x: 6, y: 1 },\n    { nombre: \"Titan Base\", x: 2, y: 7 },\n    { nombre: \"Kepler Hub\", x: 8, y: 3 }\n];\n\n// TODO: Implementar cálculo de distancia\nfunction calcularDistancia(estacion1, estacion2) {\n    // Implementar fórmula de distancia euclidiana\n}\n\n// TODO: Implementar algoritmo del viajante\nfunction encontrarRutaOptima(estaciones) {\n    let mejorRuta = null;\n    let menorDistancia = Infinity;\n    \n    // TODO: Generar todas las permutaciones posibles\n    function generarPermutaciones(arr, inicio = 0) {\n        // Implementar generación de permutaciones\n    }\n    \n    // TODO: Calcular distancia total de una ruta\n    function calcularDistanciaTotal(ruta) {\n        // Implementar cálculo de distancia total\n    }\n    \n    // TODO: Encontrar la mejor ruta usando fuerza bruta\n    // Usar bucles anidados para evaluar todas las combinaciones\n    \n    return { ruta: mejorRuta, distancia: menorDistancia };\n}\n\nconsole.log(\"?️ Estaciones comerciales registradas:\");\nestaciones.forEach((estacion, index) => {\n    console.log(`${index + 1}. ${estacion.nombre} (${estacion.x}, ${estacion.y})`);\n});\n\nconsole.log(\"\\n? Calculando ruta óptima...\");\n// TODO: Ejecutar optimización\nlet resultado = encontrarRutaOptima(estaciones);\n\nconsole.log(\"\\n? Ruta óptima encontrada:\");\n// TODO: Mostrar resultado\nconsole.log(`? Distancia total: ${resultado.distancia.toFixed(2)} años luz`);\nconsole.log(\"? Optimización completada\");','? === OPTIMIZADOR DE RUTAS GALÁCTICAS ===\n\n?️ Estaciones comerciales registradas:\n1. Terra Nova (0, 0)\n2. Marte Central (3, 4)\n3. Europa Station (6, 1)\n4. Titan Base (2, 7)\n5. Kepler Hub (8, 3)\n\n? Calculando ruta óptima...\n\n? Ruta óptima encontrada:\n? Distancia total: 23.85 años luz\n? Optimización completada','Simulación de N-Cuerpos Gravitacionales'),(13,5,1,'? **Misión: Calculadora de Área Planetaria**\n\nComo cartógrafo espacial de AstroCode, debes crear una función para calcular el área de planetas circulares que descubra tu nave durante la exploración.\n\n**Contexto de la misión:**\nTu nave ha descubierto un nuevo planeta con forma circular. Para determinar su habitabilidad, necesitas calcular su área superficial usando su radio.\n\n**Objetivos:**\n- Crea una función que calcule el área de un círculo\n- La función debe recibir el radio como parámetro\n- Debe retornar el área calculada\n- Usa la fórmula: π × radio²\n\n**Datos del planeta:**\n- Radio: 6371 km (similar a la Tierra)\n- π ≈ 3.14159\n\n? ¡Cada nuevo mundo es una oportunidad para la humanidad!',NULL,3,0,1,150,0,'console.log(\"? === CALCULADORA DE ÁREA PLANETARIA ===\");\n\n// TODO: Crear función para calcular área del círculo\nfunction calcularAreaCirculo(radio) {\n    // Implementar fórmula: π × radio²\n    const pi = 3.14159;\n    // return ...\n}\n\n// Datos del planeta descubierto\nconst radioPlaneta = 6371; // km\n\nconsole.log(`? Planeta descubierto:`);\nconsole.log(`? Radio: ${radioPlaneta} km`);\n\n// Calcular área\nconst areaPlaneta = calcularAreaCirculo(radioPlaneta);\n\nconsole.log(`\n? Resultados del análisis:`);\nconsole.log(`? Área superficial: ${areaPlaneta.toFixed(2)} km²`);\nconsole.log(`\n✅ Análisis planetario completado`);\nconsole.log(`? Datos enviados a la base AstroCode`);','? === CALCULADORA DE ÁREA PLANETARIA ===\n? Planeta descubierto:\n? Radio: 6371 km\n\n? Resultados del análisis:\n? Área superficial: 127516118.49 km²\n\n✅ Análisis planetario completado\n? Datos enviados a la base AstroCode','Calculadora de Distancias Estelares'),(14,5,2,'? **Misión: Sistema de Navegación Intergaláctica**\n\nEl sistema de navegación de tu nave ha detectado múltiples planetas en el sector. Como ingeniero de vuelo, debes crear un sistema de cálculo de distancias para planificar la ruta más eficiente.\n\n**Contexto de la misión:**\nTu nave se encuentra en las coordenadas (0, 0) del espacio. Has detectado varios planetas y necesitas calcular las distancias para determinar cuál visitar primero. El combustible es limitado, así que la eficiencia es crucial.\n\n**Objetivos:**\n- Crea una función que calcule la distancia entre dos puntos en el espacio\n- Implementa una función que determine si un planeta está dentro del rango de combustible\n- Desarrolla una función que encuentre el planeta más cercano\n\n**Fórmula de distancia:** √((x₂-x₁)² + (y₂-y₁)²)\n**Rango máximo:** 50 unidades espaciales\n\n¡La galaxia te espera, comandante! ?',NULL,3,0,3,400,0,'console.log(\"? === SISTEMA DE NAVEGACIÓN INTERGALÁCTICA ===\");\n\n// Coordenadas de planetas detectados\nconst planetas = [\n    { nombre: \"Kepler-442b\", x: 30, y: 40 },\n    { nombre: \"Proxima-b\", x: 20, y: 15 },\n    { nombre: \"TRAPPIST-1e\", x: 60, y: 80 }\n];\n\nconst naveX = 0, naveY = 0;\nconst rangoMaximo = 50;\n\n// TODO: Implementa las funciones\nfunction calcularDistancia(x1, y1, x2, y2) {\n    // Implementar fórmula de distancia euclidiana\n    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n}\n\nfunction estaEnRango(distancia, rango) {\n    // Verificar si está dentro del rango\n    return distancia <= rango;\n}\n\nfunction encontrarPlanetaMasCercano(planetas, naveX, naveY) {\n    // TODO: Encontrar el planeta más cercano\n    let planetaMasCercano = null;\n    let menorDistancia = Infinity;\n    \n    // Implementar lógica para encontrar el más cercano\n    \n    return planetaMasCercano;\n}\n\nconsole.log(`? Posición de la nave: (${naveX}, ${naveY})`);\nconsole.log(`⛽ Rango máximo: ${rangoMaximo} unidades`);\nconsole.log(\"\n? Análisis de planetas detectados:\");\n\n// Análisis de planetas\nplanetas.forEach(planeta => {\n    const distancia = calcularDistancia(naveX, naveY, planeta.x, planeta.y);\n    const enRango = estaEnRango(distancia, rangoMaximo);\n    console.log(`${planeta.nombre}: ${distancia.toFixed(2)} unidades - ${enRango ? \"✅ Alcanzable\" : \"❌ Fuera de rango\"}`);\n});\n\nconst masCercano = encontrarPlanetaMasCercano(planetas, naveX, naveY);\nconsole.log(`\n? Destino recomendado: ${masCercano.nombre}`);\nconsole.log(`? Coordenadas: (${masCercano.x}, ${masCercano.y})`);','? === SISTEMA DE NAVEGACIÓN INTERGALÁCTICA ===\n? Posición de la nave: (0, 0)\n⛽ Rango máximo: 50 unidades\n\n? Análisis de planetas detectados:\nKepler-442b: 50.00 unidades - ✅ Alcanzable\nProxima-b: 25.00 unidades - ✅ Alcanzable\nTRAPPIST-1e: 100.00 unidades - ❌ Fuera de rango\n\n? Destino recomendado: Proxima-b\n? Coordenadas: (20, 15)','Biblioteca de Funciones Astronómicas'),(15,5,3,'⚡ SISTEMA DE FUNCIONES CUÁNTICAS AVANZADAS ⚡\n\nDesarrolla un sistema avanzado de funciones de orden superior para el procesamiento de datos cuánticos de AstroCode. Implementa map(), filter(), reduce() y permite el encadenamiento de operaciones para analizar grandes volúmenes de datos de sensores espaciales, detectar anomalías y procesar señales de civilizaciones extraterrestres.',NULL,5,0,5,900,0,'console.log(\"⚡ === SISTEMA DE FUNCIONES CUÁNTICAS ===\\n\");\n\n// Datos de sensores espaciales\nlet datosSensores = [\n    { sector: \"Alpha\", temperatura: -45, radiacion: 0.3, señales: [1.2, 3.4, 0.8] },\n    { sector: \"Beta\", temperatura: 22, radiacion: 0.1, señales: [2.1, 1.9, 4.2] },\n    { sector: \"Gamma\", temperatura: -12, radiacion: 0.8, señales: [0.5, 6.1, 2.3] },\n    { sector: \"Delta\", temperatura: 67, radiacion: 0.2, señales: [3.3, 1.1, 5.4] }\n];\n\n// TODO: Implementar sistema de funciones de orden superior\nclass ProcesadorCuantico {\n    // TODO: Implementar map personalizado\n    static mapear(array, transformacion) {\n        // Implementar función map\n    }\n    \n    // TODO: Implementar filter personalizado\n    static filtrar(array, condicion) {\n        // Implementar función filter\n    }\n    \n    // TODO: Implementar reduce personalizado\n    static reducir(array, acumulador, valorInicial) {\n        // Implementar función reduce\n    }\n    \n    // TODO: Implementar encadenamiento\n    static cadena(array) {\n        return {\n            mapear: (fn) => {\n                // Implementar encadenamiento de map\n            },\n            filtrar: (fn) => {\n                // Implementar encadenamiento de filter\n            },\n            reducir: (fn, inicial) => {\n                // Implementar encadenamiento de reduce\n            },\n            obtener: () => array\n        };\n    }\n}\n\nconsole.log(\"? Procesando datos de sensores:\");\n\n// TODO: Usar funciones de orden superior para análisis\nconsole.log(\"\\n? Análisis de temperatura:\");\n// Mapear temperaturas a Kelvin\n\nconsole.log(\"\\n? Sectores con radiación alta:\");\n// Filtrar sectores con radiación > 0.5\n\nconsole.log(\"\\n? Promedio de señales por sector:\");\n// Reducir señales para obtener promedios\n\nconsole.log(\"\\n? Análisis encadenado:\");\n// Usar encadenamiento para análisis complejo\n\nconsole.log(\"\\n⚡ Procesamiento cuántico completado\");','⚡ === SISTEMA DE FUNCIONES CUÁNTICAS ===\n\n? Procesando datos de sensores:\n\n? Análisis de temperatura:\nAlpha: 228.15 K\nBeta: 295.15 K\nGamma: 261.15 K\nDelta: 340.15 K\n\n? Sectores con radiación alta:\nGamma: 0.8 radiación\n\n? Promedio de señales por sector:\nAlpha: 1.80\nBeta: 2.73\nGamma: 2.97\nDelta: 3.27\n\n? Análisis encadenado:\nSectores habitables con señales fuertes: Beta, Delta\n\n⚡ Procesamiento cuántico completado','Sistema de Funciones de Orden Superior'),(16,6,1,'? **Misión: Análisis de Datos de Sensores**\n\nComo analista de datos de la estación AstroCode, debes procesar las lecturas de 5 sensores de radiación para determinar las condiciones de seguridad del sector.\n\n**Contexto de la misión:**\nTu nave ha recopilado datos de radiación de diferentes puntos del sector. Necesitas analizar estos datos para encontrar los valores extremos y calcular el promedio para determinar si es seguro continuar.\n\n**Objetivos:**\n- Crea un array con 5 lecturas de sensores\n- Encuentra el valor mayor y menor\n- Calcula el promedio de todas las lecturas\n- Determina si el sector es seguro (promedio < 50)\n\n**Lecturas de sensores:** [23, 45, 12, 67, 34]\n**Límite de seguridad:** 50 unidades de radiación\n\n☢️ ¡La seguridad de la tripulación es prioritaria!',NULL,3,0,2,200,0,'console.log(\"? === ANÁLISIS DE DATOS DE SENSORES ===\");\n\n// Lecturas de los sensores de radiación\nconst lecturasSensores = [23, 45, 12, 67, 34];\nconst limitSeguridad = 50;\n\nconsole.log(`☢️ Lecturas de radiación: [${lecturasSensores.join(\", \")}]`);\nconsole.log(`?️ Límite de seguridad: ${limitSeguridad} unidades`);\n\n// TODO: Encontrar el mayor valor\nlet mayorLectura = lecturasSensores[0];\nfor (let i = 1; i < lecturasSensores.length; i++) {\n    if (/* condición para encontrar el mayor */) {\n        mayorLectura = lecturasSensores[i];\n    }\n}\n\n// TODO: Encontrar el menor valor\nlet menorLectura = lecturasSensores[0];\nfor (let i = 1; i < lecturasSensores.length; i++) {\n    if (/* condición para encontrar el menor */) {\n        menorLectura = lecturasSensores[i];\n    }\n}\n\n// TODO: Calcular el promedio\nlet suma = 0;\nfor (let i = 0; i < lecturasSensores.length; i++) {\n    suma += lecturasSensores[i];\n}\nconst promedio = suma / lecturasSensores.length;\n\nconsole.log(\"\n? Resultados del análisis:\");\nconsole.log(`? Lectura máxima: ${mayorLectura} unidades`);\nconsole.log(`? Lectura mínima: ${menorLectura} unidades`);\nconsole.log(`? Promedio: ${promedio.toFixed(2)} unidades`);\n\n// Evaluación de seguridad\nif (promedio < limitSeguridad) {\n    console.log(\"\n✅ SECTOR SEGURO - Continuar exploración\");\n} else {\n    console.log(\"\n⚠️ SECTOR PELIGROSO - Cambiar ruta\");\n}','? === ANÁLISIS DE DATOS DE SENSORES ===\n☢️ Lecturas de radiación: [23, 45, 12, 67, 34]\n?️ Límite de seguridad: 50 unidades\n\n? Resultados del análisis:\n? Lectura máxima: 67 unidades\n? Lectura mínima: 12 unidades\n? Promedio: 36.20 unidades\n\n✅ SECTOR SEGURO - Continuar exploración','Inventario de Nave Espacial'),(17,6,2,'?️ **Misión: Inventario de Recursos Espaciales**\n\nComo administrador de recursos de AstroCode, debes gestionar el inventario de suministros de múltiples estaciones espaciales. El sistema debe procesar, filtrar y organizar grandes cantidades de datos de recursos.\n\n**Contexto de la misión:**\nTienes datos de inventario de 5 estaciones espaciales diferentes. Necesitas crear un sistema que pueda filtrar recursos por tipo, calcular totales, encontrar escasez y generar reportes consolidados.\n\n**Objetivos:**\n- Manipula arrays multidimensionales de inventarios\n- Implementa filtros por categoría y cantidad\n- Calcula estadísticas de recursos\n- Identifica estaciones con escasez crítica\n\n**Tipos de recursos:**\n- Combustible, Oxígeno, Alimentos, Medicinas, Repuestos\n- Umbral crítico: < 100 unidades\n\n? ¡La supervivencia de las estaciones depende de tu gestión!',NULL,3,0,3,250,0,'console.log(\"?️ === INVENTARIO DE RECURSOS ESPACIALES ===\");\n\n// Inventarios de estaciones espaciales\nconst estaciones = [\n    {\n        nombre: \"Estación Alpha\",\n        recursos: [\n            { tipo: \"Combustible\", cantidad: 150 },\n            { tipo: \"Oxígeno\", cantidad: 80 },\n            { tipo: \"Alimentos\", cantidad: 200 },\n            { tipo: \"Medicinas\", cantidad: 50 },\n            { tipo: \"Repuestos\", cantidad: 120 }\n        ]\n    },\n    {\n        nombre: \"Estación Beta\",\n        recursos: [\n            { tipo: \"Combustible\", cantidad: 300 },\n            { tipo: \"Oxígeno\", cantidad: 250 },\n            { tipo: \"Alimentos\", cantidad: 180 },\n            { tipo: \"Medicinas\", cantidad: 90 },\n            { tipo: \"Repuestos\", cantidad: 160 }\n        ]\n    }\n];\n\nconst umbralCritico = 100;\n\n// TODO: Implementar funciones de gestión\nfunction obtenerRecursosPorTipo(estaciones, tipoRecurso) {\n    // Filtrar y obtener todos los recursos de un tipo específico\n    let recursos = [];\n    // Implementar lógica\n    return recursos;\n}\n\nfunction calcularTotalRecurso(estaciones, tipoRecurso) {\n    // Calcular total de un recurso en todas las estaciones\n    let total = 0;\n    // Implementar lógica\n    return total;\n}\n\nfunction identificarEscasez(estaciones, umbral) {\n    // Encontrar recursos por debajo del umbral crítico\n    let escasez = [];\n    // Implementar lógica\n    return escasez;\n}\n\nconsole.log(\"? Análisis de inventario:\");\n\n// Análisis por tipo de recurso\nconst tiposRecursos = [\"Combustible\", \"Oxígeno\", \"Alimentos\", \"Medicinas\", \"Repuestos\"];\ntiposRecursos.forEach(tipo => {\n    const total = calcularTotalRecurso(estaciones, tipo);\n    console.log(`${tipo}: ${total} unidades totales`);\n});\n\n// Identificar escasez crítica\nconst recursosEscasos = identificarEscasez(estaciones, umbralCritico);\nconsole.log(`\n? Recursos en escasez crítica: ${recursosEscasos.length}`);\nrecursosEscasos.forEach(item => {\n    console.log(`⚠️ ${item.estacion} - ${item.recurso}: ${item.cantidad} unidades`);\n});','?️ === INVENTARIO DE RECURSOS ESPACIALES ===\n? Análisis de inventario:\nCombustible: 450 unidades totales\nOxígeno: 330 unidades totales\nAlimentos: 380 unidades totales\nMedicinas: 140 unidades totales\nRepuestos: 280 unidades totales\n\n? Recursos en escasez crítica: 2\n⚠️ Estación Alpha - Oxígeno: 80 unidades\n⚠️ Estación Alpha - Medicinas: 50 unidades','Matriz de Coordenadas Espaciales'),(18,6,3,'? ARRAY DINÁMICO DE COMUNICACIONES ESPACIALES ?\n\nCrea una implementación eficiente de un array dinámico para el sistema de comunicaciones de AstroCode. El array debe redimensionarse automáticamente para manejar el flujo variable de mensajes interplanetarios, mantener un factor de carga óptimo para minimizar la latencia, y optimizar el uso de memoria en el espacio limitado de la nave.',NULL,4,0,5,500,0,'console.log(\"? === ARRAY DINÁMICO DE COMUNICACIONES ===\\n\");\n\n// TODO: Implementar array dinámico optimizado\nclass ArrayComunicaciones {\n    constructor(capacidadInicial = 4) {\n        this.datos = new Array(capacidadInicial);\n        this.tamaño = 0;\n        this.capacidad = capacidadInicial;\n        this.factorCarga = 0.75; // Redimensionar al 75%\n    }\n    \n    // TODO: Implementar inserción con redimensionamiento\n    agregar(mensaje) {\n        // Verificar si necesita redimensionar\n        // Agregar elemento\n    }\n    \n    // TODO: Implementar eliminación con compactación\n    eliminar(indice) {\n        // Eliminar elemento\n        // Verificar si necesita compactar\n    }\n    \n    // TODO: Implementar redimensionamiento automático\n    redimensionar() {\n        // Calcular nueva capacidad\n        // Copiar elementos al nuevo array\n    }\n    \n    // TODO: Implementar compactación\n    compactar() {\n        // Reducir capacidad si es necesario\n    }\n    \n    // TODO: Implementar búsqueda optimizada\n    buscar(criterio) {\n        // Implementar búsqueda eficiente\n    }\n    \n    // Métodos de información\n    obtenerEstadisticas() {\n        return {\n            tamaño: this.tamaño,\n            capacidad: this.capacidad,\n            factorUso: (this.tamaño / this.capacidad * 100).toFixed(1),\n            memoriaUsada: this.capacidad * 8 // bytes aproximados\n        };\n    }\n}\n\n// Crear sistema de comunicaciones\nlet sistemaCom = new ArrayComunicaciones();\n\n// Mensajes de prueba\nlet mensajes = [\n    { origen: \"Terra\", destino: \"Marte\", contenido: \"Suministros en camino\" },\n    { origen: \"Luna\", destino: \"Europa\", contenido: \"Misión completada\" },\n    { origen: \"Titan\", destino: \"Terra\", contenido: \"Anomalía detectada\" },\n    { origen: \"Marte\", destino: \"Kepler\", contenido: \"Colonos listos\" },\n    { origen: \"Europa\", destino: \"Luna\", contenido: \"Datos científicos\" }\n];\n\nconsole.log(\"? Procesando mensajes interplanetarios:\");\nmensajes.forEach((mensaje, index) => {\n    sistemaCom.agregar(mensaje);\n    console.log(`${index + 1}. ${mensaje.origen} → ${mensaje.destino}: ${mensaje.contenido}`);\n    \n    // TODO: Mostrar estadísticas después de cada inserción\n    let stats = sistemaCom.obtenerEstadisticas();\n    console.log(`   ? Capacidad: ${stats.capacidad}, Uso: ${stats.factorUso}%`);\n});\n\nconsole.log(\"\\n? Pruebas de eliminación y compactación:\");\n// TODO: Eliminar algunos mensajes y mostrar compactación\n\nconsole.log(\"\\n? Sistema de comunicaciones optimizado\");','? === ARRAY DINÁMICO DE COMUNICACIONES ===\n\n? Procesando mensajes interplanetarios:\n1. Terra → Marte: Suministros en camino\n   ? Capacidad: 4, Uso: 25.0%\n2. Luna → Europa: Misión completada\n   ? Capacidad: 4, Uso: 50.0%\n3. Titan → Terra: Anomalía detectada\n   ? Capacidad: 4, Uso: 75.0%\n4. Marte → Kepler: Colonos listos\n   ? Capacidad: 8, Uso: 50.0%\n5. Europa → Luna: Datos científicos\n   ? Capacidad: 8, Uso: 62.5%\n\n? Pruebas de eliminación y compactación:\n❌ Eliminando mensaje 2\n? Capacidad reducida: 8 → 4\n✅ Factor de carga optimizado: 75.0%\n\n? Sistema de comunicaciones optimizado','Tensor Multidimensional Espacial'),(19,7,1,'? **Misión: Registro de Nave Espacial**\n\nComo administrador de flota de AstroCode, debes crear un sistema de registro para las naves espaciales usando objetos para almacenar su información.\n\n**Contexto de la misión:**\nLa flota de AstroCode está creciendo y necesitas un sistema para registrar y mostrar la información de cada nave. Cada nave tiene propiedades específicas que deben ser almacenadas.\n\n**Objetivos:**\n- Crea un objeto que represente una nave espacial\n- El objeto debe tener propiedades: nombre, tipo, tripulacion, combustible\n- Muestra la información de la nave\n- Accede a propiedades específicas del objeto\n\n**Datos de la nave:**\n- Nombre: \"Estrella Polar\"\n- Tipo: \"Explorador\"\n- Tripulación: 5\n- Combustible: 750\n\n? ¡Organizar la flota es clave para el éxito de las misiones!',NULL,3,0,2,250,0,'console.log(\"? === REGISTRO DE NAVE ESPACIAL ===\");\n\n// TODO: Crear objeto nave con las propiedades requeridas\nconst nave = {\n    // Agregar propiedades: nombre, tipo, tripulacion, combustible\n};\n\nconsole.log(\"? Información de la nave:\");\nconsole.log(`? Nombre: ${nave.nombre}`);\nconsole.log(`? Tipo: ${nave.tipo}`);\nconsole.log(`? Tripulación: ${nave.tripulacion} personas`);\nconsole.log(`⛽ Combustible: ${nave.combustible} litros`);\n\nconsole.log(\"\n✅ Nave registrada en la flota AstroCode\");','? === REGISTRO DE NAVE ESPACIAL ===\n? Información de la nave:\n? Nombre: Estrella Polar\n? Tipo: Explorador\n? Tripulación: 5 personas\n⛽ Combustible: 750 litros\n\n✅ Nave registrada en la flota AstroCode','Clase Astronauta'),(20,7,2,'? **Misión: Sistema de Gestión de Naves Espaciales**\n\nComo ingeniero jefe de AstroCode, debes diseñar un sistema orientado a objetos para gestionar la flota de naves espaciales. Cada nave tiene características únicas y debe poder realizar operaciones específicas.\n\n**Contexto de la misión:**\nLa flota de AstroCode está creciendo rápidamente. Necesitas un sistema que permita crear diferentes tipos de naves, gestionar sus recursos, y simular operaciones de vuelo de manera eficiente.\n\n**Objetivos:**\n- Crea una clase base \"Nave\" con propiedades y métodos comunes\n- Implementa clases derivadas para diferentes tipos de naves\n- Gestiona combustible, escudos y sistemas de navegación\n- Simula operaciones de vuelo y combate\n\n**Tipos de naves:**\n- Explorador: Rápido, poco armamento\n- Carguero: Lento, gran capacidad\n- Militar: Equilibrado, bien armado\n\n⚔️ ¡El futuro de la galaxia está en tus manos!',NULL,3,0,4,250,0,'console.log(\"? === SISTEMA DE GESTIÓN DE NAVES ESPACIALES ===\");\n\n// TODO: Implementar clase base Nave\nclass Nave {\n    constructor(nombre, tipo, combustible, escudos, velocidad) {\n        this.nombre = nombre;\n        this.tipo = tipo;\n        this.combustible = combustible;\n        this.escudos = escudos;\n        this.velocidad = velocidad;\n        this.posicion = { x: 0, y: 0 };\n    }\n\n    // TODO: Implementar métodos\n    volar(distancia) {\n        // Calcular consumo de combustible y mover nave\n        const consumo = distancia * 0.1;\n        if (this.combustible >= consumo) {\n            this.combustible -= consumo;\n            console.log(`? ${this.nombre} voló ${distancia} unidades. Combustible restante: ${this.combustible.toFixed(1)}`);\n            return true;\n        } else {\n            console.log(`⛽ ${this.nombre} no tiene suficiente combustible`);\n            return false;\n        }\n    }\n\n    recargarCombustible(cantidad) {\n        // Implementar recarga\n    }\n\n    mostrarEstado() {\n        // Mostrar información de la nave\n    }\n}\n\n// TODO: Implementar clases derivadas\nclass Explorador extends Nave {\n    constructor(nombre) {\n        super(nombre, \"Explorador\", 100, 50, 150);\n        this.sensores = true;\n    }\n\n    escanear() {\n        console.log(`? ${this.nombre} está escaneando el área...`);\n        return \"Planeta habitable detectado\";\n    }\n}\n\nclass Carguero extends Nave {\n    constructor(nombre) {\n        super(nombre, \"Carguero\", 200, 30, 80);\n        this.carga = 0;\n        this.capacidadMaxima = 500;\n    }\n\n    cargar(cantidad) {\n        // Implementar sistema de carga\n    }\n}\n\n// Crear flota\nconst flota = [\n    new Explorador(\"Discovery\"),\n    new Carguero(\"Titan\"),\n    new Nave(\"Guardian\", \"Militar\", 150, 100, 120)\n];\n\nconsole.log(\"? Flota de AstroCode inicializada:\");\nflota.forEach(nave => {\n    console.log(`${nave.tipo} ${nave.nombre} - Combustible: ${nave.combustible}, Velocidad: ${nave.velocidad}`);\n});\n\n// Simular operaciones\nconsole.log(\"\n⚡ Iniciando operaciones:\");\nflota[0].volar(50);\nif (flota[0] instanceof Explorador) {\n    const resultado = flota[0].escanear();\n    console.log(`? Resultado del escaneo: ${resultado}`);\n}','? === SISTEMA DE GESTIÓN DE NAVES ESPACIALES ===\n? Flota de AstroCode inicializada:\nExplorador Discovery - Combustible: 100, Velocidad: 150\nCarguero Titan - Combustible: 200, Velocidad: 80\nMilitar Guardian - Combustible: 150, Velocidad: 120\n\n⚡ Iniciando operaciones:\n? Discovery voló 50 unidades. Combustible restante: 95.0\n? Discovery está escaneando el área...\n? Resultado del escaneo: Planeta habitable detectado','Jerarquía de Vehículos Espaciales'),(21,7,3,'?️ ARQUITECTURA DE PATRONES ESPACIALES ?️\n\nCrea un sistema cohesivo de diseño de patrones para la gestión de naves espaciales en AstroCode. Implementa Factory Pattern para crear diferentes tipos de naves, Observer Pattern para monitorear sistemas críticos, y Strategy Pattern para diferentes modos de vuelo (exploración, combate, comercial). El sistema debe ser extensible y mantenible.',NULL,5,0,5,600,0,'console.log(\"?️ === ARQUITECTURA DE PATRONES ESPACIALES ===\\n\");\n\n// TODO: Implementar Factory Pattern\nclass FabricaNaves {\n    static crearNave(tipo, especificaciones) {\n        // Implementar factory para diferentes tipos de naves\n    }\n}\n\n// TODO: Implementar clases base y derivadas\nclass Nave {\n    constructor(nombre, tipo) {\n        this.nombre = nombre;\n        this.tipo = tipo;\n        this.observadores = [];\n        this.estrategiaVuelo = null;\n    }\n    \n    // TODO: Implementar Observer Pattern\n    agregarObservador(observador) {\n        // Implementar registro de observadores\n    }\n    \n    notificarObservadores(evento) {\n        // Implementar notificación\n    }\n    \n    // TODO: Implementar Strategy Pattern\n    establecerEstrategiaVuelo(estrategia) {\n        // Implementar cambio de estrategia\n    }\n    \n    volar() {\n        // Usar estrategia actual\n    }\n}\n\n// TODO: Implementar tipos específicos de naves\nclass NaveExploracion extends Nave {\n    // Implementar características específicas\n}\n\nclass NaveCombate extends Nave {\n    // Implementar características específicas\n}\n\nclass NaveComercial extends Nave {\n    // Implementar características específicas\n}\n\n// TODO: Implementar observadores\nclass MonitorSistemas {\n    actualizar(evento) {\n        // Implementar monitoreo\n    }\n}\n\n// TODO: Implementar estrategias de vuelo\nclass EstrategiaExploracion {\n    ejecutar(nave) {\n        // Implementar modo exploración\n    }\n}\n\nclass EstrategiaCombate {\n    ejecutar(nave) {\n        // Implementar modo combate\n    }\n}\n\nclass EstrategiaComercial {\n    ejecutar(nave) {\n        // Implementar modo comercial\n    }\n}\n\n// Demostración del sistema\nconsole.log(\"? Creando flota espacial:\");\n\n// TODO: Usar Factory para crear naves\nlet naves = [\n    FabricaNaves.crearNave(\"exploracion\", { nombre: \"Discovery\" }),\n    FabricaNaves.crearNave(\"combate\", { nombre: \"Defender\" }),\n    FabricaNaves.crearNave(\"comercial\", { nombre: \"Trader\" })\n];\n\n// TODO: Configurar observadores y estrategias\nlet monitor = new MonitorSistemas();\n\nnaves.forEach(nave => {\n    nave.agregarObservador(monitor);\n    // Asignar estrategia apropiada\n    console.log(`✅ ${nave.nombre} (${nave.tipo}) creada y configurada`);\n});\n\nconsole.log(\"\\n? Probando cambios de estrategia:\");\n// TODO: Demostrar cambios de estrategia\n\nconsole.log(\"\\n?️ Arquitectura de patrones implementada\");','?️ === ARQUITECTURA DE PATRONES ESPACIALES ===\n\n? Creando flota espacial:\n✅ Discovery (exploracion) creada y configurada\n✅ Defender (combate) creada y configurada\n✅ Trader (comercial) creada y configurada\n\n? Probando cambios de estrategia:\n? Discovery cambia a modo exploración\n⚔️ Defender cambia a modo combate\n? Trader cambia a modo comercial\n? Monitor detecta: Discovery inicia exploración\n? Monitor detecta: Defender activa sistemas de combate\n? Monitor detecta: Trader optimiza rutas comerciales\n\n?️ Arquitectura de patrones implementada','Arquitectura de Microservicios Espaciales'),(22,8,1,'? **Misión: Ordenamiento de Coordenadas Estelares**\n\nComo navegante espacial de AstroCode, debes ordenar las coordenadas de las estrellas detectadas para planificar la ruta de exploración más eficiente.\n\n**Contexto de la misión:**\nTu nave ha detectado varias estrellas en el sector. Para optimizar el combustible, necesitas ordenar sus coordenadas X de menor a mayor para seguir una ruta secuencial.\n\n**Objetivos:**\n- Implementa el algoritmo de ordenamiento burbuja\n- Ordena un array de coordenadas de menor a mayor\n- Muestra el array antes y después del ordenamiento\n- Cuenta el número de intercambios realizados\n\n**Coordenadas detectadas:** [64, 23, 89, 12, 45]\n\n⭐ ¡Una ruta ordenada significa menos combustible gastado!',NULL,3,0,2,300,0,'console.log(\"? === ORDENAMIENTO DE COORDENADAS ESTELARES ===\");\n\n// Coordenadas X de estrellas detectadas\nlet coordenadas = [64, 23, 89, 12, 45];\nlet intercambios = 0;\n\nconsole.log(`⭐ Coordenadas originales: [${coordenadas.join(\", \")}]`);\n\n// TODO: Implementar algoritmo de ordenamiento burbuja\nfor (let i = 0; i < coordenadas.length - 1; i++) {\n    for (let j = 0; j < coordenadas.length - i - 1; j++) {\n        if (/* condición para intercambio */) {\n            // Intercambiar elementos\n            let temp = coordenadas[j];\n            coordenadas[j] = coordenadas[j + 1];\n            coordenadas[j + 1] = temp;\n            intercambios++;\n        }\n    }\n}\n\nconsole.log(`? Coordenadas ordenadas: [${coordenadas.join(\", \")}]`);\nconsole.log(`? Intercambios realizados: ${intercambios}`);\nconsole.log(\"\n✅ Ruta optimizada - Lista para navegación\");','? === ORDENAMIENTO DE COORDENADAS ESTELARES ===\n⭐ Coordenadas originales: [64, 23, 89, 12, 45]\n? Coordenadas ordenadas: [12, 23, 45, 64, 89]\n? Intercambios realizados: 8\n\n✅ Ruta optimizada - Lista para navegación','Ordenar Planetas por Distancia'),(23,8,2,'? **Misión: Clasificador de Señales Cósmicas**\n\nComo analista de datos de AstroCode, has recibido múltiples señales del espacio profundo. Debes implementar algoritmos de ordenamiento eficientes para clasificar estas señales por frecuencia y prioridad.\n\n**Contexto de la misión:**\nEl radiotelescopio de AstroCode ha captado cientos de señales misteriosas. Algunas podrían ser de civilizaciones extraterrestres. Tu tarea es ordenar estas señales para que el equipo científico pueda analizarlas en orden de importancia.\n\n**Objetivos:**\n- Implementa el algoritmo Bubble Sort para señales pequeñas\n- Desarrolla Quick Sort para conjuntos grandes\n- Compara el rendimiento de ambos algoritmos\n- Ordena por frecuencia y intensidad\n\n**Datos de señales:**\n- Frecuencia: 1.0 - 10.0 GHz\n- Intensidad: 1 - 100 (prioridad)\n- Origen: Coordenadas espaciales\n\n? ¡Podrías ser el primero en detectar vida extraterrestre!',NULL,4,0,4,300,0,'console.log(\"? === CLASIFICADOR DE SEÑALES CÓSMICAS ===\");\n\n// Señales captadas por el radiotelescopio\nconst senales = [\n    { id: \"S001\", frecuencia: 4.2, intensidad: 85, origen: \"Alfa Centauri\" },\n    { id: \"S002\", frecuencia: 1.7, intensidad: 45, origen: \"Vega\" },\n    { id: \"S003\", frecuencia: 8.1, intensidad: 92, origen: \"Proxima\" },\n    { id: \"S004\", frecuencia: 3.3, intensidad: 67, origen: \"Sirius\" },\n    { id: \"S005\", frecuencia: 6.8, intensidad: 78, origen: \"Betelgeuse\" },\n    { id: \"S006\", frecuencia: 2.1, intensidad: 34, origen: \"Rigel\" }\n];\n\nconsole.log(\"? Señales detectadas:\");\nsenales.forEach(senal => {\n    console.log(`${senal.id}: ${senal.frecuencia} GHz, Intensidad: ${senal.intensidad}, Origen: ${senal.origen}`);\n});\n\n// TODO: Implementar Bubble Sort\nfunction bubbleSort(arr, criterio) {\n    let n = arr.length;\n    let intercambios = 0;\n    \n    for (let i = 0; i < n - 1; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            // Implementar comparación según criterio\n            if (arr[j][criterio] > arr[j + 1][criterio]) {\n                // Intercambiar elementos\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                intercambios++;\n            }\n        }\n    }\n    \n    console.log(`? Bubble Sort completado con ${intercambios} intercambios`);\n    return arr;\n}\n\n// TODO: Implementar Quick Sort\nfunction quickSort(arr, criterio, inicio = 0, fin = arr.length - 1) {\n    if (inicio < fin) {\n        // Implementar partición y recursión\n        let pivote = partition(arr, criterio, inicio, fin);\n        quickSort(arr, criterio, inicio, pivote - 1);\n        quickSort(arr, criterio, pivote + 1, fin);\n    }\n    return arr;\n}\n\nfunction partition(arr, criterio, inicio, fin) {\n    // TODO: Implementar partición\n    let pivote = arr[fin][criterio];\n    let i = inicio - 1;\n    \n    for (let j = inicio; j < fin; j++) {\n        if (arr[j][criterio] <= pivote) {\n            i++;\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n        }\n    }\n    \n    [arr[i + 1], arr[fin]] = [arr[fin], arr[i + 1]];\n    return i + 1;\n}\n\n// Pruebas de ordenamiento\nconsole.log(\"\n? Ordenando por intensidad (Bubble Sort):\");\nlet senalesBubble = [...senales];\nbubbleSort(senalesBubble, \"intensidad\");\nsenalesBubble.slice(0, 3).forEach(senal => {\n    console.log(`? ${senal.id}: Intensidad ${senal.intensidad} - ${senal.origen}`);\n});\n\nconsole.log(\"\n⚡ Ordenando por frecuencia (Quick Sort):\");\nlet senalesQuick = [...senales];\nquickSort(senalesQuick, \"frecuencia\");\nsenalesQuick.slice(0, 3).forEach(senal => {\n    console.log(`? ${senal.id}: ${senal.frecuencia} GHz - ${senal.origen}`);\n});','? === CLASIFICADOR DE SEÑALES CÓSMICAS ===\n? Señales detectadas:\nS001: 4.2 GHz, Intensidad: 85, Origen: Alfa Centauri\nS002: 1.7 GHz, Intensidad: 45, Origen: Vega\nS003: 8.1 GHz, Intensidad: 92, Origen: Proxima\nS004: 3.3 GHz, Intensidad: 67, Origen: Sirius\nS005: 6.8 GHz, Intensidad: 78, Origen: Betelgeuse\nS006: 2.1 GHz, Intensidad: 34, Origen: Rigel\n\n? Ordenando por intensidad (Bubble Sort):\n? Bubble Sort completado con 8 intercambios\n? S006: Intensidad 34 - Rigel\n? S002: Intensidad 45 - Vega\n? S004: Intensidad 67 - Sirius\n\n⚡ Ordenando por frecuencia (Quick Sort):\n? S002: 1.7 GHz - Vega\n? S006: 2.1 GHz - Rigel\n? S004: 3.3 GHz - Sirius','Algoritmo de Ordenamiento Cósmico'),(24,8,3,'? ALGORITMO HÍBRIDO DE CLASIFICACIÓN CÓSMICA ?\n\nDesarrolla un algoritmo de ordenamiento híbrido inteligente para clasificar datos astronómicos masivos en AstroCode. El algoritmo debe combinar múltiples técnicas (QuickSort, MergeSort, HeapSort) y adaptarse automáticamente según las características de los datos: tamaño del dataset, nivel de desorden, y patrones de distribución de estrellas y planetas.',NULL,5,0,5,700,0,'console.log(\"? === ALGORITMO HÍBRIDO DE CLASIFICACIÓN ===\\n\");\n\n// Datos astronómicos de ejemplo\nlet datosAstronomicos = [\n    { nombre: \"Proxima Centauri\", distancia: 4.24, tipo: \"estrella\", magnitud: 11.13 },\n    { nombre: \"Kepler-442b\", distancia: 1200, tipo: \"planeta\", magnitud: 16.0 },\n    { nombre: \"Sirius\", distancia: 8.6, tipo: \"estrella\", magnitud: -1.46 },\n    { nombre: \"TRAPPIST-1e\", distancia: 40, tipo: \"planeta\", magnitud: 18.8 },\n    { nombre: \"Vega\", distancia: 25, tipo: \"estrella\", magnitud: 0.03 }\n];\n\n// TODO: Implementar algoritmo híbrido\nclass ClasificadorCósmico {\n    // TODO: Analizar características de los datos\n    static analizarDatos(datos) {\n        // Determinar tamaño, desorden, patrones\n    }\n    \n    // TODO: Seleccionar algoritmo óptimo\n    static seleccionarAlgoritmo(analisis) {\n        // Decidir qué algoritmo usar\n    }\n    \n    // TODO: Implementar QuickSort optimizado\n    static quickSort(arr, comparador, inicio = 0, fin = arr.length - 1) {\n        // Implementar QuickSort\n    }\n    \n    // TODO: Implementar MergeSort\n    static mergeSort(arr, comparador) {\n        // Implementar MergeSort\n    }\n    \n    // TODO: Implementar HeapSort\n    static heapSort(arr, comparador) {\n        // Implementar HeapSort\n    }\n    \n    // TODO: Implementar algoritmo híbrido principal\n    static ordenarHibrido(datos, criterio) {\n        // Analizar datos\n        // Seleccionar algoritmo\n        // Ejecutar ordenamiento\n        // Retornar resultado con estadísticas\n    }\n}\n\n// Criterios de ordenamiento\nlet criterios = {\n    distancia: (a, b) => a.distancia - b.distancia,\n    magnitud: (a, b) => a.magnitud - b.magnitud,\n    nombre: (a, b) => a.nombre.localeCompare(b.nombre)\n};\n\nconsole.log(\"? Datos astronómicos originales:\");\ndatosAstronomicos.forEach((objeto, index) => {\n    console.log(`${index + 1}. ${objeto.nombre} - ${objeto.distancia} años luz - Mag: ${objeto.magnitud}`);\n});\n\nconsole.log(\"\\n? Ejecutando clasificación híbrida:\");\n\n// TODO: Probar diferentes criterios\nObject.keys(criterios).forEach(criterio => {\n    console.log(`\\n? Ordenando por ${criterio}:`);\n    let resultado = ClasificadorCósmico.ordenarHibrido([...datosAstronomicos], criterios[criterio]);\n    // Mostrar resultado y estadísticas\n});\n\nconsole.log(\"\\n? Clasificación cósmica completada\");','? === ALGORITMO HÍBRIDO DE CLASIFICACIÓN ===\n\n? Datos astronómicos originales:\n1. Proxima Centauri - 4.24 años luz - Mag: 11.13\n2. Kepler-442b - 1200 años luz - Mag: 16.0\n3. Sirius - 8.6 años luz - Mag: -1.46\n4. TRAPPIST-1e - 40 años luz - Mag: 18.8\n5. Vega - 25 años luz - Mag: 0.03\n\n? Ejecutando clasificación híbrida:\n\n? Ordenando por distancia:\n? Análisis: 5 elementos, desorden medio → Usando QuickSort\n⚡ Resultado: Proxima Centauri, Sirius, Vega, TRAPPIST-1e, Kepler-442b\n\n? Ordenando por magnitud:\n? Análisis: 5 elementos, alta varianza → Usando MergeSort\n⚡ Resultado: Sirius, Vega, Proxima Centauri, Kepler-442b, TRAPPIST-1e\n\n? Ordenando por nombre:\n? Análisis: datos textuales → Usando HeapSort\n⚡ Resultado: Kepler-442b, Proxima Centauri, Sirius, TRAPPIST-1e, Vega\n\n? Clasificación cósmica completada','Algoritmo de Ordenamiento Cuántico'),(25,9,1,'? **Misión: Cálculo de Potencia de Reactor**\n\nComo ingeniero de reactores de AstroCode, debes calcular la potencia del reactor usando recursión para determinar si puede alimentar todos los sistemas de la nave.\n\n**Contexto de la misión:**\nEl reactor de la nave genera energía exponencialmente. Necesitas calcular la potencia total usando una función recursiva que simule el proceso de generación de energía.\n\n**Objetivos:**\n- Implementa una función recursiva para calcular potencias\n- Calcula base^exponente usando solo sumas\n- Maneja el caso base (exponente = 0)\n- Muestra el proceso de cálculo\n\n**Datos del reactor:**\n- Base: 3 (unidades de energía)\n- Exponente: 4 (ciclos de amplificación)\n- Resultado esperado: 3^4 = 81\n\n⚡ ¡La recursión simula el proceso natural del reactor!',NULL,3,0,2,350,0,'console.log(\"? === CÁLCULO DE POTENCIA DE REACTOR ===\");\n\n// TODO: Implementar función recursiva para calcular potencia\nfunction calcularPotencia(base, exponente) {\n    // Caso base\n    if (exponente === 0) {\n        return 1;\n    }\n    \n    // Caso recursivo\n    // return ...\n}\n\n// Datos del reactor\nconst baseEnergia = 3;\nconst ciclosAmplificacion = 4;\n\nconsole.log(`⚡ Base de energía: ${baseEnergia} unidades`);\nconsole.log(`? Ciclos de amplificación: ${ciclosAmplificacion}`);\n\n// Calcular potencia\nconst potenciaTotal = calcularPotencia(baseEnergia, ciclosAmplificacion);\n\nconsole.log(`\n? Cálculo: ${baseEnergia}^${ciclosAmplificacion} = ${potenciaTotal}`);\nconsole.log(`? Potencia total del reactor: ${potenciaTotal} unidades`);\n\nif (potenciaTotal >= 80) {\n    console.log(\"\n✅ REACTOR OPERATIVO - Energía suficiente\");\n} else {\n    console.log(\"\n⚠️ REACTOR INSUFICIENTE - Aumentar ciclos\");\n}','? === CÁLCULO DE POTENCIA DE REACTOR ===\n⚡ Base de energía: 3 unidades\n? Ciclos de amplificación: 4\n\n? Cálculo: 3^4 = 81\n? Potencia total del reactor: 81 unidades\n\n✅ REACTOR OPERATIVO - Energía suficiente','Factorial de Años Luz'),(26,9,2,'? **Misión: Explorador de Fractales Cósmicos**\n\nComo matemático espacial de AstroCode, has descubierto que las formaciones de asteroides en el cinturón de Kuiper siguen patrones fractales. Debes usar recursión para calcular y visualizar estos patrones complejos.\n\n**Contexto de la misión:**\nLos fractales cósmicos contienen información valiosa sobre la formación del sistema solar. Tu algoritmo recursivo debe calcular el factorial de coordenadas, generar secuencias de Fibonacci espaciales, y resolver el problema de las Torres de Hanoi para simular el movimiento de asteroides.\n\n**Objetivos:**\n- Implementa factorial recursivo para cálculos orbitales\n- Genera Fibonacci recursivo para patrones de asteroides\n- Resuelve Torres de Hanoi para simulación de movimientos\n- Calcula la profundidad máxima de recursión\n\n**Parámetros:**\n- Factorial: n = 8 (coordenadas orbitales)\n- Fibonacci: término 10 (patrón de asteroides)\n- Torres de Hanoi: 4 discos (asteroides)\n\n? ¡Los secretos del cosmos están en los números!',NULL,4,0,4,350,0,'console.log(\"? === EXPLORADOR DE FRACTALES CÓSMICOS ===\");\n\nlet contadorLlamadas = 0;\nlet profundidadMaxima = 0;\n\n// TODO: Implementar factorial recursivo\nfunction factorialCósmico(n, profundidad = 0) {\n    contadorLlamadas++;\n    profundidadMaxima = Math.max(profundidadMaxima, profundidad);\n    \n    console.log(`${\'  \'.repeat(profundidad)}? Calculando factorial de ${n}`);\n    \n    // Caso base\n    if (n <= 1) {\n        console.log(`${\'  \'.repeat(profundidad)}✅ Caso base alcanzado: ${n}! = 1`);\n        return 1;\n    }\n    \n    // Llamada recursiva\n    const resultado = n * factorialCósmico(n - 1, profundidad + 1);\n    console.log(`${\'  \'.repeat(profundidad)}? ${n}! = ${resultado}`);\n    return resultado;\n}\n\n// TODO: Implementar Fibonacci recursivo\nfunction fibonacciCósmico(n, profundidad = 0) {\n    contadorLlamadas++;\n    profundidadMaxima = Math.max(profundidadMaxima, profundidad);\n    \n    console.log(`${\'  \'.repeat(profundidad)}? Fibonacci cósmico de ${n}`);\n    \n    // Casos base\n    if (n <= 1) {\n        console.log(`${\'  \'.repeat(profundidad)}⭐ Caso base: F(${n}) = ${n}`);\n        return n;\n    }\n    \n    // Llamadas recursivas\n    const resultado = fibonacciCósmico(n - 1, profundidad + 1) + fibonacciCósmico(n - 2, profundidad + 1);\n    console.log(`${\'  \'.repeat(profundidad)}? F(${n}) = ${resultado}`);\n    return resultado;\n}\n\n// TODO: Implementar Torres de Hanoi\nfunction torresDeHanoi(n, origen, destino, auxiliar, profundidad = 0) {\n    contadorLlamadas++;\n    profundidadMaxima = Math.max(profundidadMaxima, profundidad);\n    \n    if (n === 1) {\n        console.log(`${\'  \'.repeat(profundidad)}? Mover asteroide 1 de ${origen} a ${destino}`);\n        return;\n    }\n    \n    // Mover n-1 discos al auxiliar\n    torresDeHanoi(n - 1, origen, auxiliar, destino, profundidad + 1);\n    \n    // Mover el disco más grande\n    console.log(`${\'  \'.repeat(profundidad)}? Mover asteroide ${n} de ${origen} a ${destino}`);\n    \n    // Mover n-1 discos del auxiliar al destino\n    torresDeHanoi(n - 1, auxiliar, destino, origen, profundidad + 1);\n}\n\n// Ejecutar cálculos cósmicos\nconsole.log(\"? Calculando factorial cósmico de 5:\");\ncontadorLlamadas = 0;\nprofundidadMaxima = 0;\nconst factorial = factorialCósmico(5);\nconsole.log(`\n? Resultado: 5! = ${factorial}`);\nconsole.log(`? Llamadas recursivas: ${contadorLlamadas}`);\nconsole.log(`?️ Profundidad máxima: ${profundidadMaxima}`);\n\nconsole.log(\"\n? Calculando Fibonacci cósmico del término 6:\");\ncontadorLlamadas = 0;\nprofundidadMaxima = 0;\nconst fibonacci = fibonacciCósmico(6);\nconsole.log(`\n? Resultado: F(6) = ${fibonacci}`);\nconsole.log(`? Llamadas recursivas: ${contadorLlamadas}`);\n\nconsole.log(\"\n?️ Resolviendo Torres de Hanoi con 3 asteroides:\");\ncontadorLlamadas = 0;\ntorresDeHanoi(3, \"Sector A\", \"Sector C\", \"Sector B\");\nconsole.log(`\n? Movimientos totales: ${Math.pow(2, 3) - 1}`);','? === EXPLORADOR DE FRACTALES CÓSMICOS ===\n? Calculando factorial cósmico de 5:\n? Calculando factorial de 5\n  ? Calculando factorial de 4\n    ? Calculando factorial de 3\n      ? Calculando factorial de 2\n        ? Calculando factorial de 1\n        ✅ Caso base alcanzado: 1! = 1\n      ? 2! = 2\n    ? 3! = 6\n  ? 4! = 24\n? 5! = 120\n\n? Resultado: 5! = 120\n? Llamadas recursivas: 5\n?️ Profundidad máxima: 4\n\n? Calculando Fibonacci cósmico del término 6:\n? Fibonacci cósmico de 6\n  ? Fibonacci cósmico de 5\n    ? Fibonacci cósmico de 4\n      ? Fibonacci cósmico de 3\n        ? Fibonacci cósmico de 2\n          ? Fibonacci cósmico de 1\n          ⭐ Caso base: F(1) = 1\n          ? Fibonacci cósmico de 0\n          ⭐ Caso base: F(0) = 0\n        ? F(2) = 1\n        ? Fibonacci cósmico de 1\n        ⭐ Caso base: F(1) = 1\n      ? F(3) = 2\n      ? Fibonacci cósmico de 2\n        ? Fibonacci cósmico de 1\n        ⭐ Caso base: F(1) = 1\n        ? Fibonacci cósmico de 0\n        ⭐ Caso base: F(0) = 0\n      ? F(2) = 1\n    ? F(4) = 3\n    ? Fibonacci cósmico de 3\n      ? Fibonacci cósmico de 2\n        ? Fibonacci cósmico de 1\n        ⭐ Caso base: F(1) = 1\n        ? Fibonacci cósmico de 0\n        ⭐ Caso base: F(0) = 0\n      ? F(2) = 1\n      ? Fibonacci cósmico de 1\n      ⭐ Caso base: F(1) = 1\n    ? F(3) = 2\n  ? F(5) = 5\n  ? Fibonacci cósmico de 4\n    ? Fibonacci cósmico de 3\n      ? Fibonacci cósmico de 2\n        ? Fibonacci cósmico de 1\n        ⭐ Caso base: F(1) = 1\n        ? Fibonacci cósmico de 0\n        ⭐ Caso base: F(0) = 0\n      ? F(2) = 1\n      ? Fibonacci cósmico de 1\n      ⭐ Caso base: F(1) = 1\n    ? F(3) = 2\n    ? Fibonacci cósmico de 2\n      ? Fibonacci cósmico de 1\n      ⭐ Caso base: F(1) = 1\n      ? Fibonacci cósmico de 0\n      ⭐ Caso base: F(0) = 0\n    ? F(2) = 1\n  ? F(4) = 3\n? F(6) = 8\n\n? Resultado: F(6) = 8\n? Llamadas recursivas: 25\n\n?️ Resolviendo Torres de Hanoi con 3 asteroides:\n? Mover asteroide 1 de Sector A a Sector C\n? Mover asteroide 2 de Sector A a Sector B\n? Mover asteroide 1 de Sector C a Sector B\n? Mover asteroide 3 de Sector A a Sector C\n? Mover asteroide 1 de Sector B a Sector A\n? Mover asteroide 2 de Sector B a Sector C\n? Mover asteroide 1 de Sector A a Sector C\n\n? Movimientos totales: 7','Exploración Recursiva de Galaxias'),(27,9,3,'? SOLUCIONADOR DE LABERINTOS CUÁNTICOS ?\n\nImplementa un solucionador avanzado de laberintos para navegar por campos de asteroides en AstroCode. Usa backtracking recursivo con optimizaciones de memoización para encontrar rutas seguras a través de laberintos tridimensionales de asteroides, considerando gravedad variable y campos magnéticos que cambian las reglas de navegación.',NULL,5,0,5,800,0,'console.log(\"? === SOLUCIONADOR DE LABERINTOS CUÁNTICOS ===\\n\");\n\n// Laberinto 3D de asteroides (0=libre, 1=asteroide, 2=campo magnético)\nlet laberintoAsteroides = [\n    [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 2]\n    ],\n    [\n        [0, 0, 1, 0, 0],\n        [1, 0, 1, 0, 1],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n];\n\n// TODO: Implementar solucionador con memoización\nclass SolucionadorCuantico {\n    constructor(laberinto) {\n        this.laberinto = laberinto;\n        this.memo = new Map();\n        this.visitados = new Set();\n        this.mejorRuta = null;\n        this.menorCosto = Infinity;\n    }\n    \n    // TODO: Implementar función principal de resolución\n    resolver(inicio, destino) {\n        // Inicializar estructuras\n        // Llamar a backtracking recursivo\n        // Retornar mejor ruta encontrada\n    }\n    \n    // TODO: Implementar backtracking recursivo\n    backtrack(posicion, destino, rutaActual, costoActual) {\n        // Caso base: llegamos al destino\n        // Caso base: posición inválida\n        // Verificar memoización\n        // Explorar movimientos posibles\n        // Recursión con backtracking\n    }\n    \n    // TODO: Implementar validación de movimientos\n    esMovimientoValido(x, y, z) {\n        // Verificar límites\n        // Verificar obstáculos\n        // Verificar si ya fue visitado\n    }\n    \n    // TODO: Implementar cálculo de costo\n    calcularCosto(posicion) {\n        // Costo base de movimiento\n        // Penalización por campos magnéticos\n        // Bonificación por rutas directas\n    }\n    \n    // TODO: Obtener movimientos posibles (6 direcciones en 3D)\n    obtenerMovimientos(x, y, z) {\n        return [\n            [x+1, y, z], [x-1, y, z],  // X\n            [x, y+1, z], [x, y-1, z],  // Y\n            [x, y, z+1], [x, y, z-1]   // Z\n        ];\n    }\n    \n    // Generar clave para memoización\n    generarClave(x, y, z) {\n        return `${x},${y},${z}`;\n    }\n}\n\n// Configuración de la misión\nlet inicio = [0, 0, 0];\nlet destino = [4, 4, 1];\n\nconsole.log(\"? Configuración de navegación:\");\nconsole.log(`? Inicio: Sector (${inicio.join(\", \")})`);\nconsole.log(`? Destino: Sector (${destino.join(\", \")})`);\nconsole.log(`? Dimensiones: ${laberintoAsteroides[0].length}x${laberintoAsteroides[0][0].length}x${laberintoAsteroides.length}`);\n\nconsole.log(\"\\n? Analizando campo de asteroides...\");\n\n// TODO: Crear solucionador y encontrar ruta\nlet solucionador = new SolucionadorCuantico(laberintoAsteroides);\nlet resultado = solucionador.resolver(inicio, destino);\n\nif (resultado) {\n    console.log(\"\\n✅ Ruta segura encontrada:\");\n    // TODO: Mostrar ruta paso a paso\n    console.log(`? Distancia total: ${resultado.costo} unidades`);\n    console.log(`⚡ Optimizaciones aplicadas: ${resultado.optimizaciones}`);\n} else {\n    console.log(\"\\n❌ No se encontró ruta segura\");\n}\n\nconsole.log(\"\\n? Navegación cuántica completada\");','? === SOLUCIONADOR DE LABERINTOS CUÁNTICOS ===\n\n? Configuración de navegación:\n? Inicio: Sector (0, 0, 0)\n? Destino: Sector (4, 4, 1)\n? Dimensiones: 5x5x2\n\n? Analizando campo de asteroides...\n\n✅ Ruta segura encontrada:\n1. (0,0,0) → (0,0,1) - Cambio de nivel\n2. (0,0,1) → (1,0,1) - Avance X\n3. (1,0,1) → (2,0,1) - Evitando asteroide\n4. (2,0,1) → (2,1,1) - Avance Y\n5. (2,1,1) → (2,2,1) - Ruta libre\n6. (2,2,1) → (3,2,1) - Navegando campo\n7. (3,2,1) → (4,2,1) - Aproximación final\n8. (4,2,1) → (4,3,1) - Último tramo\n9. (4,3,1) → (4,4,1) - ¡Destino alcanzado!\n\n? Distancia total: 12.5 unidades\n⚡ Optimizaciones aplicadas: Memoización, Poda de rutas\n\n? Navegación cuántica completada','Fractales del Espacio-Tiempo'),(28,10,1,'? **Misión: Sistema de Cola de Comandos**\n\nComo operador de sistemas de AstroCode, debes implementar una cola (queue) para gestionar los comandos que se envían a la nave en orden de llegada.\n\n**Contexto de la misión:**\nLa nave recibe múltiples comandos simultáneamente. Para evitar conflictos, debes procesarlos en el orden exacto en que llegaron usando una estructura de cola FIFO (First In, First Out).\n\n**Objetivos:**\n- Implementa una cola usando un array\n- Agrega comandos al final de la cola (enqueue)\n- Procesa comandos desde el inicio (dequeue)\n- Muestra el estado de la cola en cada operación\n\n**Comandos a procesar:**\n1. \"ACTIVAR_ESCUDOS\"\n2. \"ACELERAR\"\n3. \"ESCANEAR_SECTOR\"\n4. \"COMUNICAR_BASE\"\n\n? ¡El orden correcto evita errores críticos!',NULL,3,0,3,400,0,'console.log(\"? === SISTEMA DE COLA DE COMANDOS ===\");\n\n// Implementación de cola usando array\nlet colaComandos = [];\n\n// Función para agregar comando (enqueue)\nfunction agregarComando(comando) {\n    colaComandos.push(comando);\n    console.log(`➕ Comando agregado: ${comando}`);\n    console.log(`? Cola actual: [${colaComandos.join(\", \")}]`);\n}\n\n// Función para procesar comando (dequeue)\nfunction procesarComando() {\n    if (colaComandos.length > 0) {\n        const comando = colaComandos.shift();\n        console.log(`⚡ Procesando: ${comando}`);\n        console.log(`? Cola restante: [${colaComandos.join(\", \")}]`);\n        return comando;\n    } else {\n        console.log(\"⚠️ No hay comandos en cola\");\n        return null;\n    }\n}\n\nconsole.log(\"\n? Agregando comandos a la cola:\");\n// TODO: Agregar los comandos usando la función\nagregarComando(\"ACTIVAR_ESCUDOS\");\nagregarComando(\"ACELERAR\");\nagregarComando(\"ESCANEAR_SECTOR\");\nagregarComando(\"COMUNICAR_BASE\");\n\nconsole.log(\"\n⚡ Procesando comandos:\");\n// TODO: Procesar todos los comandos\nwhile (colaComandos.length > 0) {\n    procesarComando();\n}\n\nconsole.log(\"\n✅ Todos los comandos procesados\");','? === SISTEMA DE COLA DE COMANDOS ===\n\n? Agregando comandos a la cola:\n➕ Comando agregado: ACTIVAR_ESCUDOS\n? Cola actual: [ACTIVAR_ESCUDOS]\n➕ Comando agregado: ACELERAR\n? Cola actual: [ACTIVAR_ESCUDOS, ACELERAR]\n➕ Comando agregado: ESCANEAR_SECTOR\n? Cola actual: [ACTIVAR_ESCUDOS, ACELERAR, ESCANEAR_SECTOR]\n➕ Comando agregado: COMUNICAR_BASE\n? Cola actual: [ACTIVAR_ESCUDOS, ACELERAR, ESCANEAR_SECTOR, COMUNICAR_BASE]\n\n⚡ Procesando comandos:\n⚡ Procesando: ACTIVAR_ESCUDOS\n? Cola restante: [ACELERAR, ESCANEAR_SECTOR, COMUNICAR_BASE]\n⚡ Procesando: ACELERAR\n? Cola restante: [ESCANEAR_SECTOR, COMUNICAR_BASE]\n⚡ Procesando: ESCANEAR_SECTOR\n? Cola restante: [COMUNICAR_BASE]\n⚡ Procesando: COMUNICAR_BASE\n? Cola restante: []\n\n✅ Todos los comandos procesados','Pila de Comandos de Nave'),(29,10,2,'?️ **Misión: Centro de Comando de Comunicaciones**\n\nComo ingeniero de comunicaciones de AstroCode, debes implementar un sistema avanzado de gestión de mensajes usando estructuras de datos eficientes. El centro debe manejar colas de prioridad, pilas de historial y mapas de contactos.\n\n**Contexto de la misión:**\nEl centro de comando recibe miles de mensajes diarios de diferentes naves y estaciones. Necesitas un sistema que priorice mensajes de emergencia, mantenga historial de comunicaciones y gestione contactos de manera eficiente.\n\n**Objetivos:**\n- Implementa una cola de prioridad para mensajes\n- Crea una pila para historial de comandos\n- Desarrolla un mapa hash para contactos\n- Gestiona diferentes tipos de mensajes y prioridades\n\n**Tipos de mensajes:**\n- Emergencia (Prioridad 1), Operacional (Prioridad 2), Informativo (Prioridad 3)\n- Cada mensaje tiene: ID, remitente, contenido, timestamp\n\n? ¡La comunicación eficiente salva vidas en el espacio!',NULL,4,0,4,400,0,'console.log(\"?️ === CENTRO DE COMANDO DE COMUNICACIONES ===\");\n\n// TODO: Implementar Cola de Prioridad\nclass ColaPrioridad {\n    constructor() {\n        this.elementos = [];\n    }\n\n    encolar(elemento, prioridad) {\n        const item = { elemento, prioridad };\n        let agregado = false;\n\n        // Insertar según prioridad (1 = mayor prioridad)\n        for (let i = 0; i < this.elementos.length; i++) {\n            if (item.prioridad < this.elementos[i].prioridad) {\n                this.elementos.splice(i, 0, item);\n                agregado = true;\n                break;\n            }\n        }\n\n        if (!agregado) {\n            this.elementos.push(item);\n        }\n\n        console.log(`? Mensaje encolado: ${elemento.id} (Prioridad ${prioridad})`);\n    }\n\n    desencolar() {\n        if (this.elementos.length === 0) {\n            console.log(\"? Cola vacía\");\n            return null;\n        }\n        const item = this.elementos.shift();\n        console.log(`? Procesando mensaje: ${item.elemento.id}`);\n        return item.elemento;\n    }\n\n    mostrarCola() {\n        console.log(\"? Estado actual de la cola:\");\n        this.elementos.forEach((item, index) => {\n            console.log(`  ${index + 1}. ${item.elemento.id} - ${item.elemento.tipo} (P${item.prioridad})`);\n        });\n    }\n}\n\n// TODO: Implementar Pila para historial\nclass PilaHistorial {\n    constructor() {\n        this.comandos = [];\n    }\n\n    apilar(comando) {\n        this.comandos.push({\n            comando: comando,\n            timestamp: new Date().toLocaleTimeString()\n        });\n        console.log(`? Comando guardado: ${comando}`);\n    }\n\n    desapilar() {\n        if (this.comandos.length === 0) {\n            console.log(\"? Historial vacío\");\n            return null;\n        }\n        const ultimo = this.comandos.pop();\n        console.log(`⏪ Deshaciendo: ${ultimo.comando}`);\n        return ultimo;\n    }\n\n    mostrarHistorial() {\n        console.log(\"? Historial de comandos:\");\n        this.comandos.slice(-5).forEach((item, index) => {\n            console.log(`  ${this.comandos.length - 5 + index + 1}. ${item.comando} (${item.timestamp})`);\n        });\n    }\n}\n\n// TODO: Implementar Mapa de contactos\nclass MapaContactos {\n    constructor() {\n        this.contactos = new Map();\n    }\n\n    agregar(id, nombre, sector, rango) {\n        this.contactos.set(id, { nombre, sector, rango });\n        console.log(`? Contacto agregado: ${nombre} (${id})`);\n    }\n\n    buscar(id) {\n        const contacto = this.contactos.get(id);\n        if (contacto) {\n            console.log(`? Encontrado: ${contacto.nombre} - ${contacto.sector} (${contacto.rango})`);\n            return contacto;\n        } else {\n            console.log(`❌ Contacto ${id} no encontrado`);\n            return null;\n        }\n    }\n\n    listarPorSector(sector) {\n        console.log(`? Contactos en ${sector}:`);\n        for (let [id, contacto] of this.contactos) {\n            if (contacto.sector === sector) {\n                console.log(`  ${contacto.nombre} (${id}) - ${contacto.rango}`);\n            }\n        }\n    }\n}\n\n// Inicializar sistemas\nconst colaMensajes = new ColaPrioridad();\nconst historial = new PilaHistorial();\nconst contactos = new MapaContactos();\n\n// Agregar contactos\ncontactos.agregar(\"CMD001\", \"Capitán Rodriguez\", \"Sector Alpha\", \"Comandante\");\ncontactos.agregar(\"ENG002\", \"Ingeniera Chen\", \"Sector Beta\", \"Ingeniero Jefe\");\ncontactos.agregar(\"SCI003\", \"Dr. Patel\", \"Sector Alpha\", \"Científico\");\n\n// Simular mensajes\nconst mensajes = [\n    { id: \"MSG001\", remitente: \"CMD001\", tipo: \"Informativo\", contenido: \"Reporte de estado\" },\n    { id: \"MSG002\", remitente: \"ENG002\", tipo: \"Emergencia\", contenido: \"Falla en reactor\" },\n    { id: \"MSG003\", remitente: \"SCI003\", tipo: \"Operacional\", contenido: \"Datos de escaneo\" }\n];\n\nconsole.log(\"\n? Procesando mensajes:\");\nmensajes.forEach(mensaje => {\n    let prioridad = mensaje.tipo === \"Emergencia\" ? 1 : mensaje.tipo === \"Operacional\" ? 2 : 3;\n    colaMensajes.encolar(mensaje, prioridad);\n});\n\ncolaMensajes.mostrarCola();\n\nconsole.log(\"\n⚡ Procesando mensajes por prioridad:\");\nwhile (colaMensajes.elementos.length > 0) {\n    const mensaje = colaMensajes.desencolar();\n    historial.apilar(`Procesado ${mensaje.id} de ${mensaje.remitente}`);\n}\n\nconsole.log(\"\n? Historial reciente:\");\nhistorial.mostrarHistorial();\n\nconsole.log(\"\n? Búsqueda de contactos:\");\ncontactos.buscar(\"ENG002\");\ncontactos.listarPorSector(\"Sector Alpha\");','?️ === CENTRO DE COMANDO DE COMUNICACIONES ===\n? Contacto agregado: Capitán Rodriguez (CMD001)\n? Contacto agregado: Ingeniera Chen (ENG002)\n? Contacto agregado: Dr. Patel (SCI003)\n\n? Procesando mensajes:\n? Mensaje encolado: MSG001 (Prioridad 3)\n? Mensaje encolado: MSG002 (Prioridad 1)\n? Mensaje encolado: MSG003 (Prioridad 2)\n? Estado actual de la cola:\n  1. MSG002 - Emergencia (P1)\n  2. MSG003 - Operacional (P2)\n  3. MSG001 - Informativo (P3)\n\n⚡ Procesando mensajes por prioridad:\n? Procesando mensaje: MSG002\n? Comando guardado: Procesado MSG002 de ENG002\n? Procesando mensaje: MSG003\n? Comando guardado: Procesado MSG003 de SCI003\n? Procesando mensaje: MSG001\n? Comando guardado: Procesado MSG001 de CMD001\n\n? Historial reciente:\n? Historial de comandos:\n  1. Procesado MSG002 de ENG002 (10:30:15)\n  2. Procesado MSG003 de SCI003 (10:30:15)\n  3. Procesado MSG001 de CMD001 (10:30:15)\n\n? Búsqueda de contactos:\n? Encontrado: Ingeniera Chen - Sector Beta (Ingeniero Jefe)\n? Contactos en Sector Alpha:\n  Capitán Rodriguez (CMD001) - Comandante\n  Dr. Patel (SCI003) - Científico','Árbol Binario de Sistemas Estelares'),(30,10,3,'? ÁRBOL AVL DE NAVEGACIÓN GALÁCTICA ?\n\nImplementa un árbol AVL auto-balanceado para el sistema de navegación galáctica de AstroCode. El árbol debe mantener coordenadas estelares ordenadas, realizar rotaciones automáticas para mantener el balance, y proporcionar búsquedas ultra-rápidas de rutas entre sistemas estelares para optimizar los viajes interplanetarios.',NULL,5,0,5,900,0,'console.log(\"? === ÁRBOL AVL DE NAVEGACIÓN GALÁCTICA ===\\n\");\n\n// TODO: Implementar nodo del árbol AVL\nclass NodoEstelar {\n    constructor(coordenada, nombre) {\n        this.coordenada = coordenada; // Coordenada galáctica\n        this.nombre = nombre;\n        this.altura = 1;\n        this.izquierdo = null;\n        this.derecho = null;\n    }\n}\n\n// TODO: Implementar árbol AVL completo\nclass ArbolNavegacion {\n    constructor() {\n        this.raiz = null;\n        this.rotaciones = 0;\n    }\n    \n    // TODO: Insertar con auto-balanceo\n    insertar(coordenada, nombre) {\n        this.raiz = this._insertar(this.raiz, coordenada, nombre);\n    }\n    \n    _insertar(nodo, coordenada, nombre) {\n        // Inserción BST normal\n        // Actualizar altura\n        // Obtener factor de balance\n        // Realizar rotaciones si es necesario\n    }\n    \n    // TODO: Implementar rotaciones\n    rotarDerecha(y) {\n        // Implementar rotación derecha\n    }\n    \n    rotarIzquierda(x) {\n        // Implementar rotación izquierda\n    }\n    \n    // TODO: Calcular altura\n    obtenerAltura(nodo) {\n        // Retornar altura del nodo\n    }\n    \n    // TODO: Calcular factor de balance\n    obtenerBalance(nodo) {\n        // Retornar factor de balance\n    }\n    \n    // TODO: Búsqueda optimizada\n    buscar(coordenada) {\n        return this._buscar(this.raiz, coordenada);\n    }\n    \n    _buscar(nodo, coordenada) {\n        // Implementar búsqueda BST\n    }\n    \n    // TODO: Encontrar ruta entre dos puntos\n    encontrarRuta(origen, destino) {\n        // Implementar búsqueda de ruta\n    }\n    \n    // TODO: Recorrido en orden\n    recorridoEnOrden() {\n        let resultado = [];\n        this._enOrden(this.raiz, resultado);\n        return resultado;\n    }\n    \n    _enOrden(nodo, resultado) {\n        // Implementar recorrido en orden\n    }\n    \n    // Obtener estadísticas del árbol\n    obtenerEstadisticas() {\n        return {\n            altura: this.obtenerAltura(this.raiz),\n            rotaciones: this.rotaciones,\n            nodos: this._contarNodos(this.raiz),\n            balanceado: this._esBalanceado(this.raiz)\n        };\n    }\n    \n    _contarNodos(nodo) {\n        // Contar nodos recursivamente\n    }\n    \n    _esBalanceado(nodo) {\n        // Verificar si el árbol está balanceado\n    }\n}\n\n// Sistemas estelares para insertar\nlet sistemasEstelares = [\n    { coordenada: 50, nombre: \"Sol\" },\n    { coordenada: 25, nombre: \"Proxima Centauri\" },\n    { coordenada: 75, nombre: \"Sirius\" },\n    { coordenada: 10, nombre: \"Wolf 359\" },\n    { coordenada: 60, nombre: \"Vega\" },\n    { coordenada: 30, nombre: \"Altair\" },\n    { coordenada: 80, nombre: \"Arcturus\" },\n    { coordenada: 15, nombre: \"Barnard\" },\n    { coordenada: 90, nombre: \"Capella\" }\n];\n\nconsole.log(\"? Construyendo mapa de navegación galáctica:\");\n\n// TODO: Crear árbol y insertar sistemas\nlet navegador = new ArbolNavegacion();\n\nsistemas Estelares.forEach((sistema, index) => {\n    navegador.insertar(sistema.coordenada, sistema.nombre);\n    console.log(`${index + 1}. Insertando ${sistema.nombre} (${sistema.coordenada})`);\n    \n    // Mostrar estadísticas después de cada inserción\n    let stats = navegador.obtenerEstadisticas();\n    console.log(`   ? Altura: ${stats.altura}, Rotaciones: ${stats.rotaciones}`);\n});\n\nconsole.log(\"\\n? Sistemas ordenados por coordenada:\");\n// TODO: Mostrar recorrido en orden\n\nconsole.log(\"\\n? Pruebas de búsqueda:\");\n// TODO: Realizar búsquedas de ejemplo\n\nconsole.log(\"\\n? Estadísticas finales del árbol:\");\n// TODO: Mostrar estadísticas completas\n\nconsole.log(\"\\n? Sistema de navegación galáctica listo\");','? === ÁRBOL AVL DE NAVEGACIÓN GALÁCTICA ===\n\n? Construyendo mapa de navegación galáctica:\n1. Insertando Sol (50)\n   ? Altura: 1, Rotaciones: 0\n2. Insertando Proxima Centauri (25)\n   ? Altura: 2, Rotaciones: 0\n3. Insertando Sirius (75)\n   ? Altura: 2, Rotaciones: 0\n4. Insertando Wolf 359 (10)\n   ? Altura: 3, Rotaciones: 1\n5. Insertando Vega (60)\n   ? Altura: 3, Rotaciones: 1\n6. Insertando Altair (30)\n   ? Altura: 3, Rotaciones: 1\n7. Insertando Arcturus (80)\n   ? Altura: 3, Rotaciones: 1\n8. Insertando Barnard (15)\n   ? Altura: 4, Rotaciones: 2\n9. Insertando Capella (90)\n   ? Altura: 4, Rotaciones: 2\n\n? Sistemas ordenados por coordenada:\nWolf 359 (10) → Barnard (15) → Proxima Centauri (25) → Altair (30) → Sol (50) → Vega (60) → Sirius (75) → Arcturus (80) → Capella (90)\n\n? Pruebas de búsqueda:\n✅ Sol encontrado en coordenada 50\n✅ Vega encontrado en coordenada 60\n❌ Alpha Centauri no encontrado\n\n? Estadísticas finales del árbol:\n? Altura total: 4\n? Rotaciones realizadas: 2\n⭐ Sistemas registrados: 9\n⚖️ Árbol balanceado: ✅\n\n? Sistema de navegación galáctica listo','Grafo de Redes Galácticas'),(31,11,1,'? BÚSQUEDA BINARIA EN CATÁLOGO ESTELAR ?\n\nImplementa el algoritmo de búsqueda binaria para localizar rápidamente estrellas en el catálogo astronómico de AstroCode. El sistema debe buscar estrellas por magnitud en un array ordenado y comparar la eficiencia con búsqueda lineal, mostrando el número de comparaciones realizadas y el tiempo de ejecución para diferentes tamaños de catálogo.',NULL,4,0,3,500,0,'console.log(\"? === BÚSQUEDA BINARIA EN CATÁLOGO ESTELAR ===\\n\");\n\n// Catálogo de estrellas ordenado por magnitud\nlet catalogoEstrellas = [\n    { nombre: \"Sirius\", magnitud: -1.46 },\n    { nombre: \"Canopus\", magnitud: -0.74 },\n    { nombre: \"Arcturus\", magnitud: -0.05 },\n    { nombre: \"Vega\", magnitud: 0.03 },\n    { nombre: \"Capella\", magnitud: 0.08 },\n    { nombre: \"Rigel\", magnitud: 0.13 },\n    { nombre: \"Procyon\", magnitud: 0.34 },\n    { nombre: \"Betelgeuse\", magnitud: 0.50 },\n    { nombre: \"Aldebaran\", magnitud: 0.85 },\n    { nombre: \"Spica\", magnitud: 1.04 }\n];\n\n// TODO: Implementar búsqueda binaria\nfunction busquedaBinaria(catalogo, magnitudBuscada) {\n    let inicio = 0;\n    let fin = catalogo.length - 1;\n    let comparaciones = 0;\n    \n    while (/* condición del bucle */) {\n        comparaciones++;\n        let medio = Math.floor((inicio + fin) / 2);\n        \n        // TODO: Implementar lógica de búsqueda\n        if (/* estrella encontrada */) {\n            return { estrella: catalogo[medio], comparaciones, encontrada: true };\n        } else if (/* buscar en mitad izquierda */) {\n            // Ajustar fin\n        } else {\n            // Ajustar inicio\n        }\n    }\n    \n    return { estrella: null, comparaciones, encontrada: false };\n}\n\n// TODO: Implementar búsqueda lineal para comparación\nfunction busquedaLineal(catalogo, magnitudBuscada) {\n    let comparaciones = 0;\n    \n    for (let i = 0; i < catalogo.length; i++) {\n        comparaciones++;\n        // TODO: Implementar búsqueda lineal\n        if (/* estrella encontrada */) {\n            return { estrella: catalogo[i], comparaciones, encontrada: true };\n        }\n    }\n    \n    return { estrella: null, comparaciones, encontrada: false };\n}\n\n// TODO: Función para medir tiempo de ejecución\nfunction medirTiempo(funcion, ...args) {\n    let inicio = performance.now();\n    let resultado = funcion(...args);\n    let fin = performance.now();\n    resultado.tiempo = (fin - inicio).toFixed(4);\n    return resultado;\n}\n\nconsole.log(\"? Catálogo estelar cargado:\");\ncatalogoEstrellas.forEach((estrella, index) => {\n    console.log(`${index + 1}. ${estrella.nombre}: ${estrella.magnitud}`);\n});\n\n// Magnitudes a buscar\nlet magnitudesBuscar = [-1.46, 0.03, 1.04, 2.5];\n\nconsole.log(\"\\n? Comparando algoritmos de búsqueda:\");\n\nmagnitudesBuscar.forEach(magnitud => {\n    console.log(`\\n? Buscando estrella con magnitud ${magnitud}:`);\n    \n    // TODO: Ejecutar búsqueda binaria\n    let resultadoBinario = medirTiempo(busquedaBinaria, catalogoEstrellas, magnitud);\n    \n    // TODO: Ejecutar búsqueda lineal\n    let resultadoLineal = medirTiempo(busquedaLineal, catalogoEstrellas, magnitud);\n    \n    // Mostrar resultados\n    if (resultadoBinario.encontrada) {\n        console.log(`✅ Encontrada: ${resultadoBinario.estrella.nombre}`);\n    } else {\n        console.log(`❌ No encontrada`);\n    }\n    \n    console.log(`? Búsqueda Binaria: ${resultadoBinario.comparaciones} comparaciones, ${resultadoBinario.tiempo}ms`);\n    console.log(`? Búsqueda Lineal: ${resultadoLineal.comparaciones} comparaciones, ${resultadoLineal.tiempo}ms`);\n    \n    if (resultadoBinario.encontrada) {\n        let eficiencia = ((resultadoLineal.comparaciones - resultadoBinario.comparaciones) / resultadoLineal.comparaciones * 100).toFixed(1);\n        console.log(`⚡ Eficiencia: ${eficiencia}% menos comparaciones`);\n    }\n});\n\nconsole.log(\"\\n? Análisis de búsqueda completado\");','? === BÚSQUEDA BINARIA EN CATÁLOGO ESTELAR ===\n\n? Catálogo estelar cargado:\n1. Sirius: -1.46\n2. Canopus: -0.74\n3. Arcturus: -0.05\n4. Vega: 0.03\n5. Capella: 0.08\n6. Rigel: 0.13\n7. Procyon: 0.34\n8. Betelgeuse: 0.50\n9. Aldebaran: 0.85\n10. Spica: 1.04\n\n? Comparando algoritmos de búsqueda:\n\n? Buscando estrella con magnitud -1.46:\n✅ Encontrada: Sirius\n? Búsqueda Binaria: 4 comparaciones, 0.0123ms\n? Búsqueda Lineal: 1 comparaciones, 0.0089ms\n⚡ Eficiencia: -300.0% menos comparaciones\n\n? Buscando estrella con magnitud 0.03:\n✅ Encontrada: Vega\n? Búsqueda Binaria: 2 comparaciones, 0.0098ms\n? Búsqueda Lineal: 4 comparaciones, 0.0156ms\n⚡ Eficiencia: 50.0% menos comparaciones\n\n? Buscando estrella con magnitud 1.04:\n✅ Encontrada: Spica\n? Búsqueda Binaria: 4 comparaciones, 0.0134ms\n? Búsqueda Lineal: 10 comparaciones, 0.0234ms\n⚡ Eficiencia: 60.0% menos comparaciones\n\n? Buscando estrella con magnitud 2.5:\n❌ No encontrada\n? Búsqueda Binaria: 4 comparaciones, 0.0112ms\n? Búsqueda Lineal: 10 comparaciones, 0.0198ms\n\n? Análisis de búsqueda completado','Búsqueda de Vida Extraterrestre'),(32,11,2,'Crea una implementación del algoritmo de Dijkstra para encontrar el camino más corto en un grafo ponderado.',NULL,4,0,5,500,0,NULL,NULL,'Algoritmo de Pathfinding Espacial'),(33,11,3,'Implementa un algoritmo de machine learning básico (regresión lineal) desde cero sin usar librerías externas.',NULL,5,0,5,500,0,NULL,NULL,'Algoritmo de Machine Learning Cósmico'),(34,12,1,'Resuelve el problema de Fibonacci usando programación dinámica con memoización. Compara con la versión recursiva naive.',NULL,4,0,3,600,0,NULL,NULL,'Optimización de Combustible'),(35,12,2,'Implementa la solución al problema de la mochila (knapsack) usando programación dinámica con optimización de espacio.',NULL,4,0,5,600,0,NULL,NULL,'Problema de la Mochila Espacial'),(36,12,3,'Resuelve el problema de la subsecuencia común más larga (LCS) entre múltiples cadenas usando programación dinámica 3D.',NULL,5,0,5,600,0,NULL,NULL,'Alineación de ADN Alienígena'),(37,13,1,'Implementa los algoritmos de recorrido DFS y BFS para un grafo representado con lista de adyacencia.',NULL,4,0,4,700,0,NULL,NULL,''),(38,13,2,'Crea un algoritmo para detectar ciclos en un grafo dirigido y otro para encontrar componentes fuertemente conexas.',NULL,4,0,5,700,0,NULL,NULL,''),(39,13,3,'Implementa el algoritmo de Ford-Fulkerson para encontrar el flujo máximo en una red de flujo.',NULL,5,0,5,700,0,NULL,NULL,''),(40,14,1,'Optimiza un algoritmo de búsqueda lineal implementando técnicas de early termination y cache-friendly access patterns.',NULL,4,0,4,800,0,NULL,NULL,''),(41,14,2,'Implementa un algoritmo genético para resolver el problema de optimización de funciones multimodales.',NULL,5,0,5,800,0,NULL,NULL,''),(42,14,3,'Crea un optimizador de consultas SQL básico que pueda reordenar joins y seleccionar índices óptimos.',NULL,5,0,5,800,0,NULL,NULL,''),(43,15,1,'Implementa una búsqueda A* simple para encontrar el camino más corto en una cuadrícula 2D con obstáculos.',NULL,4,0,4,900,0,NULL,NULL,''),(44,15,2,'Crea un motor de búsqueda de texto que implemente algoritmos de matching de patrones como KMP y Rabin-Karp.',NULL,5,0,5,900,0,NULL,NULL,''),(45,15,3,'Implementa un sistema de búsqueda distribuida que pueda indexar y buscar en múltiples nodos de manera eficiente.',NULL,5,0,5,900,0,NULL,NULL,'');
/*!40000 ALTER TABLE `tareas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tareas_usuarios`
--

DROP TABLE IF EXISTS `tareas_usuarios`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tareas_usuarios` (
  `usuario_id` bigint NOT NULL,
  `tarea_id` bigint NOT NULL,
  `completado_el` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `tiempo_completado` time DEFAULT NULL,
  `puntos_base` int DEFAULT NULL,
  `puntos_bonus` int DEFAULT NULL,
  `puntos_totales` int DEFAULT NULL,
  PRIMARY KEY (`usuario_id`,`tarea_id`),
  KEY `tarea_id` (`tarea_id`),
  CONSTRAINT `tareas_usuarios_ibfk_1` FOREIGN KEY (`usuario_id`) REFERENCES `usuarios` (`id`),
  CONSTRAINT `tareas_usuarios_ibfk_2` FOREIGN KEY (`tarea_id`) REFERENCES `tareas` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tareas_usuarios`
--

LOCK TABLES `tareas_usuarios` WRITE;
/*!40000 ALTER TABLE `tareas_usuarios` DISABLE KEYS */;
/*!40000 ALTER TABLE `tareas_usuarios` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tiempos_finalizacion`
--

DROP TABLE IF EXISTS `tiempos_finalizacion`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tiempos_finalizacion` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `umbral` time NOT NULL,
  `puntos_bonus` int NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tiempos_finalizacion`
--

LOCK TABLES `tiempos_finalizacion` WRITE;
/*!40000 ALTER TABLE `tiempos_finalizacion` DISABLE KEYS */;
INSERT INTO `tiempos_finalizacion` VALUES (1,'00:02:00',100),(2,'00:05:00',75),(3,'00:10:00',50),(4,'00:15:00',25),(5,'00:30:00',10);
/*!40000 ALTER TABLE `tiempos_finalizacion` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `usuarios`
--

DROP TABLE IF EXISTS `usuarios`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `usuarios` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nombre_usuario` varchar(255) NOT NULL,
  `correo_electronico` varchar(255) NOT NULL,
  `contrasena_hash` text NOT NULL,
  `nombre_completo` varchar(255) DEFAULT NULL,
  `puntos` int DEFAULT '0',
  `creado_el` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `nombre_usuario` (`nombre_usuario`),
  UNIQUE KEY `correo_electronico` (`correo_electronico`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `usuarios`
--

LOCK TABLES `usuarios` WRITE;
/*!40000 ALTER TABLE `usuarios` DISABLE KEYS */;
INSERT INTO `usuarios` VALUES (1,'testuser','test@example.com','$2b$10$pXTcHSWaIMH0vAyF/RrE1uJRNntWoXjYoQQMwzlK1TdFBJNLdkqrK','Usuario de Prueba',120,'2025-06-19 15:28:21'),(2,'michu','michu@gmail.com','$2b$12$v6tYh7cC06jk4iwMPli9ReNTY2SkMc2osr4A4n4z7HZXu9y63z0Am','Miguel Mier',1000,'2025-06-19 15:54:47'),(3,'marinita','marina@gmail.com','$2b$12$ATweMvWUBsN3sv4RWYu.Ku3SMnjvJs9WodYVLXDJ4ZDDUkl.MKRVi','Marina Izquierdo',9999,'2025-06-19 17:47:37'),(4,'merins','m@a.com','$2b$12$.E7UBjM2ul893sq9D0mADOPhkI0oLvdlwkrz1LHWep5Eha8F7JHDW','Marinita',0,'2025-06-19 17:48:40');
/*!40000 ALTER TABLE `usuarios` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-06-29 20:21:28
