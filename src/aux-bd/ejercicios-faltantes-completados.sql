-- ================================================================
-- COMPLETAR EJERCICIOS FALTANTES - ASTROCODE
-- ================================================================
-- Este archivo contiene las sentencias UPDATE para completar los ejercicios
-- que faltan con codigo_base y resultado_esperado según el CSV proporcionado
-- Todos los ejercicios incluyen temática espacial coherente con AstroCode

USE astrocodebd;

-- ================================================================
-- EJERCICIOS DIFÍCILES FALTANTES
-- ================================================================

-- Variables y Tipos - Difícil (ID: 3)
UPDATE tareas 
SET 
    descripcion = '🔬 LABORATORIO DE TIPOS CUÁNTICOS ESPACIALES 🔬\n\nComo científico jefe de la estación AstroCode, debes crear un sistema avanzado de tipos dinámicos que pueda detectar automáticamente el tipo de datos de muestras extraterrestres y realizar operaciones seguras entre diferentes tipos de materia cósmica. El sistema debe manejar conversiones entre elementos conocidos (hidrógeno, helio) y elementos desconocidos, manteniendo la integridad de los datos durante las transformaciones cuánticas.',
    codigo_base = 'console.log("🔬 === LABORATORIO DE TIPOS CUÁNTICOS ===\\n");\n\n// Sistema de detección automática de tipos\nclass DetectorTipos {\n    // TODO: Implementar detección automática de tipos\n    static detectarTipo(muestra) {\n        // Implementar lógica de detección\n    }\n    \n    // TODO: Implementar conversiones seguras\n    static convertirSeguro(valor, tipoDestino) {\n        // Implementar conversiones con validación\n    }\n    \n    // TODO: Implementar operaciones entre tipos\n    static operarTipos(valor1, valor2, operacion) {\n        // Implementar operaciones seguras\n    }\n}\n\n// Muestras de prueba\nlet muestras = [42, "Helio-3", 3.14159, true, null, {elemento: "Hidrógeno"}];\n\nconsole.log("🧪 Analizando muestras extraterrestres:");\nmuestras.forEach((muestra, index) => {\n    // TODO: Usar DetectorTipos para analizar cada muestra\n    console.log(`Muestra ${index + 1}: ${muestra} -> Tipo: [IMPLEMENTAR]`);\n});\n\nconsole.log("\\n🔄 Pruebas de conversión segura:");\n// TODO: Implementar pruebas de conversión\n\nconsole.log("\\n⚗️ Análisis completado");',
    resultado_esperado = '🔬 === LABORATORIO DE TIPOS CUÁNTICOS ===\n\n🧪 Analizando muestras extraterrestres:\nMuestra 1: 42 -> Tipo: number\nMuestra 2: Helio-3 -> Tipo: string\nMuestra 3: 3.14159 -> Tipo: number\nMuestra 4: true -> Tipo: boolean\nMuestra 5: null -> Tipo: null\nMuestra 6: [object Object] -> Tipo: object\n\n🔄 Pruebas de conversión segura:\n✅ Conversión 42 -> string: "42"\n✅ Conversión "3.14" -> number: 3.14\n⚠️ Conversión "Helio-3" -> number: NaN (conversión insegura)\n✅ Operación segura: 42 + 3.14 = 45.14\n\n⚗️ Análisis completado'
WHERE id = 3;

-- Operadores - Difícil (ID: 6)
UPDATE tareas 
SET 
    descripcion = '🤖 INTÉRPRETE DE COMANDOS GALÁCTICOS 🤖\n\nDesarrolla un intérprete avanzado de expresiones matemáticas para el sistema de navegación de la nave AstroCode. El intérprete debe evaluar operadores personalizados para cálculos de trayectorias espaciales y funciones definidas por el usuario para maniobras complejas. Incluye operadores como distancia_estelar(), velocidad_warp() y coordenadas_galácticas().',
    codigo_base = 'console.log("🤖 === INTÉRPRETE DE COMANDOS GALÁCTICOS ===\\n");\n\n// Intérprete de expresiones espaciales\nclass InterpreteGalactico {\n    constructor() {\n        this.operadores = new Map();\n        this.funciones = new Map();\n        this.inicializarOperadores();\n    }\n    \n    // TODO: Inicializar operadores personalizados\n    inicializarOperadores() {\n        // Implementar operadores espaciales\n    }\n    \n    // TODO: Registrar función personalizada\n    registrarFuncion(nombre, funcion) {\n        // Implementar registro de funciones\n    }\n    \n    // TODO: Evaluar expresión completa\n    evaluar(expresion) {\n        // Implementar evaluación con precedencia\n    }\n    \n    // TODO: Parsear tokens\n    parsear(expresion) {\n        // Implementar parser de expresiones\n    }\n}\n\n// Crear intérprete\nlet interprete = new InterpreteGalactico();\n\n// TODO: Registrar funciones espaciales\ninterprete.registrarFuncion("distancia_estelar", (x1, y1, x2, y2) => {\n    // Implementar cálculo de distancia\n});\n\n// Expresiones de prueba\nlet expresiones = [\n    "2 + 3 * 4",\n    "distancia_estelar(0, 0, 3, 4)",\n    "(velocidad_warp(5) + 2) * factor_tiempo(0.8)"\n];\n\nconsole.log("🧮 Evaluando comandos de navegación:");\nexpresiones.forEach(expr => {\n    // TODO: Evaluar cada expresión\n    console.log(`${expr} = [IMPLEMENTAR]`);\n});\n\nconsole.log("\\n🚀 Sistema de navegación listo");',
    resultado_esperado = '🤖 === INTÉRPRETE DE COMANDOS GALÁCTICOS ===\n\n🧮 Evaluando comandos de navegación:\n2 + 3 * 4 = 14\ndistancia_estelar(0, 0, 3, 4) = 5\n(velocidad_warp(5) + 2) * factor_tiempo(0.8) = 5.6\n\n🚀 Sistema de navegación listo'
WHERE id = 6;

-- Estructuras Condicionales - Difícil (ID: 9)
UPDATE tareas 
SET 
    descripcion = '🏦 SISTEMA DE PRÉSTAMOS INTERPLANETARIOS 🏦\n\nCrea un sistema avanzado de evaluación de préstamos para el Banco Galáctico AstroCode. El sistema debe evaluar múltiples condiciones anidadas para determinar la elegibilidad de préstamos para colonos espaciales, considerando factores como: ingresos en créditos galácticos, historial de misiones, planeta de origen, experiencia espacial, y riesgo de la colonia destino.',
    codigo_base = 'console.log("🏦 === BANCO GALÁCTICO ASTROCODE ===\\n");\n\n// Sistema de evaluación de préstamos\nclass EvaluadorPrestamos {\n    // TODO: Implementar evaluación completa\n    static evaluarSolicitud(solicitante) {\n        let puntuacion = 0;\n        let factores = [];\n        \n        // TODO: Evaluar ingresos (peso: 30%)\n        if (/* condición ingresos altos */) {\n            // Implementar lógica\n        }\n        \n        // TODO: Evaluar historial de misiones (peso: 25%)\n        if (/* condición historial excelente */) {\n            // Implementar lógica\n        }\n        \n        // TODO: Evaluar planeta de origen (peso: 20%)\n        if (/* condición planeta seguro */) {\n            // Implementar lógica\n        }\n        \n        // TODO: Evaluar experiencia espacial (peso: 15%)\n        if (/* condición experiencia alta */) {\n            // Implementar lógica\n        }\n        \n        // TODO: Evaluar riesgo destino (peso: 10%)\n        if (/* condición destino seguro */) {\n            // Implementar lógica\n        }\n        \n        return { puntuacion, factores, aprobado: puntuacion >= 70 };\n    }\n}\n\n// Casos de prueba\nlet solicitantes = [\n    {\n        nombre: "Comandante Zara",\n        ingresos: 85000,\n        historialMisiones: "excelente",\n        planetaOrigen: "Terra Nova",\n        experienciaEspacial: 15,\n        destinoColonia: "Kepler-442b"\n    },\n    {\n        nombre: "Piloto Kai",\n        ingresos: 45000,\n        historialMisiones: "bueno",\n        planetaOrigen: "Marte",\n        experienciaEspacial: 5,\n        destinoColonia: "Proxima-b"\n    }\n];\n\nconsole.log("📋 Evaluando solicitudes de préstamo:");\nsolicitantes.forEach(solicitante => {\n    // TODO: Evaluar cada solicitante\n    let resultado = EvaluadorPrestamos.evaluarSolicitud(solicitante);\n    console.log(`\\n👤 ${solicitante.nombre}:`);\n    console.log(`📊 Puntuación: ${resultado.puntuacion}/100`);\n    console.log(`${resultado.aprobado ? "✅ APROBADO" : "❌ RECHAZADO"}`);\n});\n\nconsole.log("\\n🏦 Evaluación completada");',
    resultado_esperado = '🏦 === BANCO GALÁCTICO ASTROCODE ===\n\n📋 Evaluando solicitudes de préstamo:\n\n👤 Comandante Zara:\n📊 Puntuación: 95/100\n✅ APROBADO\n\n👤 Piloto Kai:\n📊 Puntuación: 65/100\n❌ RECHAZADO\n\n🏦 Evaluación completada'
WHERE id = 9;

-- Bucles - Difícil (ID: 12)
UPDATE tareas 
SET 
    descripcion = '🛸 OPTIMIZADOR DE RUTAS COMERCIALES GALÁCTICAS 🛸\n\nImplementa un algoritmo de optimización que use bucles anidados para resolver el problema del viajante comercial espacial. El sistema debe encontrar la ruta más eficiente para visitar todas las estaciones comerciales de la galaxia, minimizando el consumo de combustible cuántico y el tiempo de viaje entre planetas.',
    codigo_base = 'console.log("🛸 === OPTIMIZADOR DE RUTAS GALÁCTICAS ===\\n");\n\n// Datos de estaciones comerciales\nlet estaciones = [\n    { nombre: "Terra Nova", x: 0, y: 0 },\n    { nombre: "Marte Central", x: 3, y: 4 },\n    { nombre: "Europa Station", x: 6, y: 1 },\n    { nombre: "Titan Base", x: 2, y: 7 },\n    { nombre: "Kepler Hub", x: 8, y: 3 }\n];\n\n// TODO: Implementar cálculo de distancia\nfunction calcularDistancia(estacion1, estacion2) {\n    // Implementar fórmula de distancia euclidiana\n}\n\n// TODO: Implementar algoritmo del viajante\nfunction encontrarRutaOptima(estaciones) {\n    let mejorRuta = null;\n    let menorDistancia = Infinity;\n    \n    // TODO: Generar todas las permutaciones posibles\n    function generarPermutaciones(arr, inicio = 0) {\n        // Implementar generación de permutaciones\n    }\n    \n    // TODO: Calcular distancia total de una ruta\n    function calcularDistanciaTotal(ruta) {\n        // Implementar cálculo de distancia total\n    }\n    \n    // TODO: Encontrar la mejor ruta usando fuerza bruta\n    // Usar bucles anidados para evaluar todas las combinaciones\n    \n    return { ruta: mejorRuta, distancia: menorDistancia };\n}\n\nconsole.log("🗺️ Estaciones comerciales registradas:");\nestaciones.forEach((estacion, index) => {\n    console.log(`${index + 1}. ${estacion.nombre} (${estacion.x}, ${estacion.y})`);\n});\n\nconsole.log("\\n🔍 Calculando ruta óptima...");\n// TODO: Ejecutar optimización\nlet resultado = encontrarRutaOptima(estaciones);\n\nconsole.log("\\n🎯 Ruta óptima encontrada:");\n// TODO: Mostrar resultado\nconsole.log(`📏 Distancia total: ${resultado.distancia.toFixed(2)} años luz`);\nconsole.log("🛸 Optimización completada");',
    resultado_esperado = '🛸 === OPTIMIZADOR DE RUTAS GALÁCTICAS ===\n\n🗺️ Estaciones comerciales registradas:\n1. Terra Nova (0, 0)\n2. Marte Central (3, 4)\n3. Europa Station (6, 1)\n4. Titan Base (2, 7)\n5. Kepler Hub (8, 3)\n\n🔍 Calculando ruta óptima...\n\n🎯 Ruta óptima encontrada:\n📏 Distancia total: 23.85 años luz\n🛸 Optimización completada'
WHERE id = 12;

-- Funciones - Difícil (ID: 15)
UPDATE tareas 
SET 
    descripcion = '⚡ SISTEMA DE FUNCIONES CUÁNTICAS AVANZADAS ⚡\n\nDesarrolla un sistema avanzado de funciones de orden superior para el procesamiento de datos cuánticos de AstroCode. Implementa map(), filter(), reduce() y permite el encadenamiento de operaciones para analizar grandes volúmenes de datos de sensores espaciales, detectar anomalías y procesar señales de civilizaciones extraterrestres.',
    codigo_base = 'console.log("⚡ === SISTEMA DE FUNCIONES CUÁNTICAS ===\\n");\n\n// Datos de sensores espaciales\nlet datosSensores = [\n    { sector: "Alpha", temperatura: -45, radiacion: 0.3, señales: [1.2, 3.4, 0.8] },\n    { sector: "Beta", temperatura: 22, radiacion: 0.1, señales: [2.1, 1.9, 4.2] },\n    { sector: "Gamma", temperatura: -12, radiacion: 0.8, señales: [0.5, 6.1, 2.3] },\n    { sector: "Delta", temperatura: 67, radiacion: 0.2, señales: [3.3, 1.1, 5.4] }\n];\n\n// TODO: Implementar sistema de funciones de orden superior\nclass ProcesadorCuantico {\n    // TODO: Implementar map personalizado\n    static mapear(array, transformacion) {\n        // Implementar función map\n    }\n    \n    // TODO: Implementar filter personalizado\n    static filtrar(array, condicion) {\n        // Implementar función filter\n    }\n    \n    // TODO: Implementar reduce personalizado\n    static reducir(array, acumulador, valorInicial) {\n        // Implementar función reduce\n    }\n    \n    // TODO: Implementar encadenamiento\n    static cadena(array) {\n        return {\n            mapear: (fn) => {\n                // Implementar encadenamiento de map\n            },\n            filtrar: (fn) => {\n                // Implementar encadenamiento de filter\n            },\n            reducir: (fn, inicial) => {\n                // Implementar encadenamiento de reduce\n            },\n            obtener: () => array\n        };\n    }\n}\n\nconsole.log("🔬 Procesando datos de sensores:");\n\n// TODO: Usar funciones de orden superior para análisis\nconsole.log("\\n📊 Análisis de temperatura:");\n// Mapear temperaturas a Kelvin\n\nconsole.log("\\n🔍 Sectores con radiación alta:");\n// Filtrar sectores con radiación > 0.5\n\nconsole.log("\\n📈 Promedio de señales por sector:");\n// Reducir señales para obtener promedios\n\nconsole.log("\\n🔗 Análisis encadenado:");\n// Usar encadenamiento para análisis complejo\n\nconsole.log("\\n⚡ Procesamiento cuántico completado");',
    resultado_esperado = '⚡ === SISTEMA DE FUNCIONES CUÁNTICAS ===\n\n🔬 Procesando datos de sensores:\n\n📊 Análisis de temperatura:\nAlpha: 228.15 K\nBeta: 295.15 K\nGamma: 261.15 K\nDelta: 340.15 K\n\n🔍 Sectores con radiación alta:\nGamma: 0.8 radiación\n\n📈 Promedio de señales por sector:\nAlpha: 1.80\nBeta: 2.73\nGamma: 2.97\nDelta: 3.27\n\n🔗 Análisis encadenado:\nSectores habitables con señales fuertes: Beta, Delta\n\n⚡ Procesamiento cuántico completado'
WHERE id = 15;

-- Arrays y Listas - Difícil (ID: 18)
UPDATE tareas 
SET 
    descripcion = '📡 ARRAY DINÁMICO DE COMUNICACIONES ESPACIALES 📡\n\nCrea una implementación eficiente de un array dinámico para el sistema de comunicaciones de AstroCode. El array debe redimensionarse automáticamente para manejar el flujo variable de mensajes interplanetarios, mantener un factor de carga óptimo para minimizar la latencia, y optimizar el uso de memoria en el espacio limitado de la nave.',
    codigo_base = 'console.log("📡 === ARRAY DINÁMICO DE COMUNICACIONES ===\\n");\n\n// TODO: Implementar array dinámico optimizado\nclass ArrayComunicaciones {\n    constructor(capacidadInicial = 4) {\n        this.datos = new Array(capacidadInicial);\n        this.tamaño = 0;\n        this.capacidad = capacidadInicial;\n        this.factorCarga = 0.75; // Redimensionar al 75%\n    }\n    \n    // TODO: Implementar inserción con redimensionamiento\n    agregar(mensaje) {\n        // Verificar si necesita redimensionar\n        // Agregar elemento\n    }\n    \n    // TODO: Implementar eliminación con compactación\n    eliminar(indice) {\n        // Eliminar elemento\n        // Verificar si necesita compactar\n    }\n    \n    // TODO: Implementar redimensionamiento automático\n    redimensionar() {\n        // Calcular nueva capacidad\n        // Copiar elementos al nuevo array\n    }\n    \n    // TODO: Implementar compactación\n    compactar() {\n        // Reducir capacidad si es necesario\n    }\n    \n    // TODO: Implementar búsqueda optimizada\n    buscar(criterio) {\n        // Implementar búsqueda eficiente\n    }\n    \n    // Métodos de información\n    obtenerEstadisticas() {\n        return {\n            tamaño: this.tamaño,\n            capacidad: this.capacidad,\n            factorUso: (this.tamaño / this.capacidad * 100).toFixed(1),\n            memoriaUsada: this.capacidad * 8 // bytes aproximados\n        };\n    }\n}\n\n// Crear sistema de comunicaciones\nlet sistemaCom = new ArrayComunicaciones();\n\n// Mensajes de prueba\nlet mensajes = [\n    { origen: "Terra", destino: "Marte", contenido: "Suministros en camino" },\n    { origen: "Luna", destino: "Europa", contenido: "Misión completada" },\n    { origen: "Titan", destino: "Terra", contenido: "Anomalía detectada" },\n    { origen: "Marte", destino: "Kepler", contenido: "Colonos listos" },\n    { origen: "Europa", destino: "Luna", contenido: "Datos científicos" }\n];\n\nconsole.log("📨 Procesando mensajes interplanetarios:");\nmensajes.forEach((mensaje, index) => {\n    sistemaCom.agregar(mensaje);\n    console.log(`${index + 1}. ${mensaje.origen} → ${mensaje.destino}: ${mensaje.contenido}`);\n    \n    // TODO: Mostrar estadísticas después de cada inserción\n    let stats = sistemaCom.obtenerEstadisticas();\n    console.log(`   📊 Capacidad: ${stats.capacidad}, Uso: ${stats.factorUso}%`);\n});\n\nconsole.log("\\n🔍 Pruebas de eliminación y compactación:");\n// TODO: Eliminar algunos mensajes y mostrar compactación\n\nconsole.log("\\n📡 Sistema de comunicaciones optimizado");',
    resultado_esperado = '📡 === ARRAY DINÁMICO DE COMUNICACIONES ===\n\n📨 Procesando mensajes interplanetarios:\n1. Terra → Marte: Suministros en camino\n   📊 Capacidad: 4, Uso: 25.0%\n2. Luna → Europa: Misión completada\n   📊 Capacidad: 4, Uso: 50.0%\n3. Titan → Terra: Anomalía detectada\n   📊 Capacidad: 4, Uso: 75.0%\n4. Marte → Kepler: Colonos listos\n   📊 Capacidad: 8, Uso: 50.0%\n5. Europa → Luna: Datos científicos\n   📊 Capacidad: 8, Uso: 62.5%\n\n🔍 Pruebas de eliminación y compactación:\n❌ Eliminando mensaje 2\n📊 Capacidad reducida: 8 → 4\n✅ Factor de carga optimizado: 75.0%\n\n📡 Sistema de comunicaciones optimizado'
WHERE id = 18;

-- ================================================================
-- EJERCICIOS DE CATEGORÍAS AVANZADAS
-- ================================================================

-- Objetos y Clases - Difícil (ID: 21)
UPDATE tareas 
SET 
    descripcion = '🏗️ ARQUITECTURA DE PATRONES ESPACIALES 🏗️\n\nCrea un sistema cohesivo de diseño de patrones para la gestión de naves espaciales en AstroCode. Implementa Factory Pattern para crear diferentes tipos de naves, Observer Pattern para monitorear sistemas críticos, y Strategy Pattern para diferentes modos de vuelo (exploración, combate, comercial). El sistema debe ser extensible y mantenible.',
    codigo_base = 'console.log("🏗️ === ARQUITECTURA DE PATRONES ESPACIALES ===\\n");\n\n// TODO: Implementar Factory Pattern\nclass FabricaNaves {\n    static crearNave(tipo, especificaciones) {\n        // Implementar factory para diferentes tipos de naves\n    }\n}\n\n// TODO: Implementar clases base y derivadas\nclass Nave {\n    constructor(nombre, tipo) {\n        this.nombre = nombre;\n        this.tipo = tipo;\n        this.observadores = [];\n        this.estrategiaVuelo = null;\n    }\n    \n    // TODO: Implementar Observer Pattern\n    agregarObservador(observador) {\n        // Implementar registro de observadores\n    }\n    \n    notificarObservadores(evento) {\n        // Implementar notificación\n    }\n    \n    // TODO: Implementar Strategy Pattern\n    establecerEstrategiaVuelo(estrategia) {\n        // Implementar cambio de estrategia\n    }\n    \n    volar() {\n        // Usar estrategia actual\n    }\n}\n\n// TODO: Implementar tipos específicos de naves\nclass NaveExploracion extends Nave {\n    // Implementar características específicas\n}\n\nclass NaveCombate extends Nave {\n    // Implementar características específicas\n}\n\nclass NaveComercial extends Nave {\n    // Implementar características específicas\n}\n\n// TODO: Implementar observadores\nclass MonitorSistemas {\n    actualizar(evento) {\n        // Implementar monitoreo\n    }\n}\n\n// TODO: Implementar estrategias de vuelo\nclass EstrategiaExploracion {\n    ejecutar(nave) {\n        // Implementar modo exploración\n    }\n}\n\nclass EstrategiaCombate {\n    ejecutar(nave) {\n        // Implementar modo combate\n    }\n}\n\nclass EstrategiaComercial {\n    ejecutar(nave) {\n        // Implementar modo comercial\n    }\n}\n\n// Demostración del sistema\nconsole.log("🚀 Creando flota espacial:");\n\n// TODO: Usar Factory para crear naves\nlet naves = [\n    FabricaNaves.crearNave("exploracion", { nombre: "Discovery" }),\n    FabricaNaves.crearNave("combate", { nombre: "Defender" }),\n    FabricaNaves.crearNave("comercial", { nombre: "Trader" })\n];\n\n// TODO: Configurar observadores y estrategias\nlet monitor = new MonitorSistemas();\n\nnaves.forEach(nave => {\n    nave.agregarObservador(monitor);\n    // Asignar estrategia apropiada\n    console.log(`✅ ${nave.nombre} (${nave.tipo}) creada y configurada`);\n});\n\nconsole.log("\\n🎮 Probando cambios de estrategia:");\n// TODO: Demostrar cambios de estrategia\n\nconsole.log("\\n🏗️ Arquitectura de patrones implementada");',
    resultado_esperado = '🏗️ === ARQUITECTURA DE PATRONES ESPACIALES ===\n\n🚀 Creando flota espacial:\n✅ Discovery (exploracion) creada y configurada\n✅ Defender (combate) creada y configurada\n✅ Trader (comercial) creada y configurada\n\n🎮 Probando cambios de estrategia:\n🔍 Discovery cambia a modo exploración\n⚔️ Defender cambia a modo combate\n💰 Trader cambia a modo comercial\n📡 Monitor detecta: Discovery inicia exploración\n📡 Monitor detecta: Defender activa sistemas de combate\n📡 Monitor detecta: Trader optimiza rutas comerciales\n\n🏗️ Arquitectura de patrones implementada'
WHERE id = 21;

-- Algoritmos de Ordenamiento - Difícil (ID: 24)
UPDATE tareas 
SET 
    descripcion = '🔄 ALGORITMO HÍBRIDO DE CLASIFICACIÓN CÓSMICA 🔄\n\nDesarrolla un algoritmo de ordenamiento híbrido inteligente para clasificar datos astronómicos masivos en AstroCode. El algoritmo debe combinar múltiples técnicas (QuickSort, MergeSort, HeapSort) y adaptarse automáticamente según las características de los datos: tamaño del dataset, nivel de desorden, y patrones de distribución de estrellas y planetas.',
    codigo_base = 'console.log("🔄 === ALGORITMO HÍBRIDO DE CLASIFICACIÓN ===\\n");\n\n// Datos astronómicos de ejemplo\nlet datosAstronomicos = [\n    { nombre: "Proxima Centauri", distancia: 4.24, tipo: "estrella", magnitud: 11.13 },\n    { nombre: "Kepler-442b", distancia: 1200, tipo: "planeta", magnitud: 16.0 },\n    { nombre: "Sirius", distancia: 8.6, tipo: "estrella", magnitud: -1.46 },\n    { nombre: "TRAPPIST-1e", distancia: 40, tipo: "planeta", magnitud: 18.8 },\n    { nombre: "Vega", distancia: 25, tipo: "estrella", magnitud: 0.03 }\n];\n\n// TODO: Implementar algoritmo híbrido\nclass ClasificadorCósmico {\n    // TODO: Analizar características de los datos\n    static analizarDatos(datos) {\n        // Determinar tamaño, desorden, patrones\n    }\n    \n    // TODO: Seleccionar algoritmo óptimo\n    static seleccionarAlgoritmo(analisis) {\n        // Decidir qué algoritmo usar\n    }\n    \n    // TODO: Implementar QuickSort optimizado\n    static quickSort(arr, comparador, inicio = 0, fin = arr.length - 1) {\n        // Implementar QuickSort\n    }\n    \n    // TODO: Implementar MergeSort\n    static mergeSort(arr, comparador) {\n        // Implementar MergeSort\n    }\n    \n    // TODO: Implementar HeapSort\n    static heapSort(arr, comparador) {\n        // Implementar HeapSort\n    }\n    \n    // TODO: Implementar algoritmo híbrido principal\n    static ordenarHibrido(datos, criterio) {\n        // Analizar datos\n        // Seleccionar algoritmo\n        // Ejecutar ordenamiento\n        // Retornar resultado con estadísticas\n    }\n}\n\n// Criterios de ordenamiento\nlet criterios = {\n    distancia: (a, b) => a.distancia - b.distancia,\n    magnitud: (a, b) => a.magnitud - b.magnitud,\n    nombre: (a, b) => a.nombre.localeCompare(b.nombre)\n};\n\nconsole.log("🌌 Datos astronómicos originales:");\ndatosAstronomicos.forEach((objeto, index) => {\n    console.log(`${index + 1}. ${objeto.nombre} - ${objeto.distancia} años luz - Mag: ${objeto.magnitud}`);\n});\n\nconsole.log("\\n🔍 Ejecutando clasificación híbrida:");\n\n// TODO: Probar diferentes criterios\nObject.keys(criterios).forEach(criterio => {\n    console.log(`\\n📊 Ordenando por ${criterio}:`);\n    let resultado = ClasificadorCósmico.ordenarHibrido([...datosAstronomicos], criterios[criterio]);\n    // Mostrar resultado y estadísticas\n});\n\nconsole.log("\\n🔄 Clasificación cósmica completada");',
    resultado_esperado = '🔄 === ALGORITMO HÍBRIDO DE CLASIFICACIÓN ===\n\n🌌 Datos astronómicos originales:\n1. Proxima Centauri - 4.24 años luz - Mag: 11.13\n2. Kepler-442b - 1200 años luz - Mag: 16.0\n3. Sirius - 8.6 años luz - Mag: -1.46\n4. TRAPPIST-1e - 40 años luz - Mag: 18.8\n5. Vega - 25 años luz - Mag: 0.03\n\n🔍 Ejecutando clasificación híbrida:\n\n📊 Ordenando por distancia:\n🧠 Análisis: 5 elementos, desorden medio → Usando QuickSort\n⚡ Resultado: Proxima Centauri, Sirius, Vega, TRAPPIST-1e, Kepler-442b\n\n📊 Ordenando por magnitud:\n🧠 Análisis: 5 elementos, alta varianza → Usando MergeSort\n⚡ Resultado: Sirius, Vega, Proxima Centauri, Kepler-442b, TRAPPIST-1e\n\n📊 Ordenando por nombre:\n🧠 Análisis: datos textuales → Usando HeapSort\n⚡ Resultado: Kepler-442b, Proxima Centauri, Sirius, TRAPPIST-1e, Vega\n\n🔄 Clasificación cósmica completada'
WHERE id = 24;

-- Recursión - Difícil (ID: 27)
UPDATE tareas 
SET 
    descripcion = '🌀 SOLUCIONADOR DE LABERINTOS CUÁNTICOS 🌀\n\nImplementa un solucionador avanzado de laberintos para navegar por campos de asteroides en AstroCode. Usa backtracking recursivo con optimizaciones de memoización para encontrar rutas seguras a través de laberintos tridimensionales de asteroides, considerando gravedad variable y campos magnéticos que cambian las reglas de navegación.',
    codigo_base = 'console.log("🌀 === SOLUCIONADOR DE LABERINTOS CUÁNTICOS ===\\n");\n\n// Laberinto 3D de asteroides (0=libre, 1=asteroide, 2=campo magnético)\nlet laberintoAsteroides = [\n    [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 2]\n    ],\n    [\n        [0, 0, 1, 0, 0],\n        [1, 0, 1, 0, 1],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n];\n\n// TODO: Implementar solucionador con memoización\nclass SolucionadorCuantico {\n    constructor(laberinto) {\n        this.laberinto = laberinto;\n        this.memo = new Map();\n        this.visitados = new Set();\n        this.mejorRuta = null;\n        this.menorCosto = Infinity;\n    }\n    \n    // TODO: Implementar función principal de resolución\n    resolver(inicio, destino) {\n        // Inicializar estructuras\n        // Llamar a backtracking recursivo\n        // Retornar mejor ruta encontrada\n    }\n    \n    // TODO: Implementar backtracking recursivo\n    backtrack(posicion, destino, rutaActual, costoActual) {\n        // Caso base: llegamos al destino\n        // Caso base: posición inválida\n        // Verificar memoización\n        // Explorar movimientos posibles\n        // Recursión con backtracking\n    }\n    \n    // TODO: Implementar validación de movimientos\n    esMovimientoValido(x, y, z) {\n        // Verificar límites\n        // Verificar obstáculos\n        // Verificar si ya fue visitado\n    }\n    \n    // TODO: Implementar cálculo de costo\n    calcularCosto(posicion) {\n        // Costo base de movimiento\n        // Penalización por campos magnéticos\n        // Bonificación por rutas directas\n    }\n    \n    // TODO: Obtener movimientos posibles (6 direcciones en 3D)\n    obtenerMovimientos(x, y, z) {\n        return [\n            [x+1, y, z], [x-1, y, z],  // X\n            [x, y+1, z], [x, y-1, z],  // Y\n            [x, y, z+1], [x, y, z-1]   // Z\n        ];\n    }\n    \n    // Generar clave para memoización\n    generarClave(x, y, z) {\n        return `${x},${y},${z}`;\n    }\n}\n\n// Configuración de la misión\nlet inicio = [0, 0, 0];\nlet destino = [4, 4, 1];\n\nconsole.log("🚀 Configuración de navegación:");\nconsole.log(`📍 Inicio: Sector (${inicio.join(", ")})`);\nconsole.log(`🎯 Destino: Sector (${destino.join(", ")})`);\nconsole.log(`📊 Dimensiones: ${laberintoAsteroides[0].length}x${laberintoAsteroides[0][0].length}x${laberintoAsteroides.length}`);\n\nconsole.log("\\n🔍 Analizando campo de asteroides...");\n\n// TODO: Crear solucionador y encontrar ruta\nlet solucionador = new SolucionadorCuantico(laberintoAsteroides);\nlet resultado = solucionador.resolver(inicio, destino);\n\nif (resultado) {\n    console.log("\\n✅ Ruta segura encontrada:");\n    // TODO: Mostrar ruta paso a paso\n    console.log(`📏 Distancia total: ${resultado.costo} unidades`);\n    console.log(`⚡ Optimizaciones aplicadas: ${resultado.optimizaciones}`);\n} else {\n    console.log("\\n❌ No se encontró ruta segura");\n}\n\nconsole.log("\\n🌀 Navegación cuántica completada");',
    resultado_esperado = '🌀 === SOLUCIONADOR DE LABERINTOS CUÁNTICOS ===\n\n🚀 Configuración de navegación:\n📍 Inicio: Sector (0, 0, 0)\n🎯 Destino: Sector (4, 4, 1)\n📊 Dimensiones: 5x5x2\n\n🔍 Analizando campo de asteroides...\n\n✅ Ruta segura encontrada:\n1. (0,0,0) → (0,0,1) - Cambio de nivel\n2. (0,0,1) → (1,0,1) - Avance X\n3. (1,0,1) → (2,0,1) - Evitando asteroide\n4. (2,0,1) → (2,1,1) - Avance Y\n5. (2,1,1) → (2,2,1) - Ruta libre\n6. (2,2,1) → (3,2,1) - Navegando campo\n7. (3,2,1) → (4,2,1) - Aproximación final\n8. (4,2,1) → (4,3,1) - Último tramo\n9. (4,3,1) → (4,4,1) - ¡Destino alcanzado!\n\n📏 Distancia total: 12.5 unidades\n⚡ Optimizaciones aplicadas: Memoización, Poda de rutas\n\n🌀 Navegación cuántica completada'
WHERE id = 27;

-- Estructuras de Datos - Difícil (ID: 30)
UPDATE tareas 
SET 
    descripcion = '🌳 ÁRBOL AVL DE NAVEGACIÓN GALÁCTICA 🌳\n\nImplementa un árbol AVL auto-balanceado para el sistema de navegación galáctica de AstroCode. El árbol debe mantener coordenadas estelares ordenadas, realizar rotaciones automáticas para mantener el balance, y proporcionar búsquedas ultra-rápidas de rutas entre sistemas estelares para optimizar los viajes interplanetarios.',
    codigo_base = 'console.log("🌳 === ÁRBOL AVL DE NAVEGACIÓN GALÁCTICA ===\\n");\n\n// TODO: Implementar nodo del árbol AVL\nclass NodoEstelar {\n    constructor(coordenada, nombre) {\n        this.coordenada = coordenada; // Coordenada galáctica\n        this.nombre = nombre;\n        this.altura = 1;\n        this.izquierdo = null;\n        this.derecho = null;\n    }\n}\n\n// TODO: Implementar árbol AVL completo\nclass ArbolNavegacion {\n    constructor() {\n        this.raiz = null;\n        this.rotaciones = 0;\n    }\n    \n    // TODO: Insertar con auto-balanceo\n    insertar(coordenada, nombre) {\n        this.raiz = this._insertar(this.raiz, coordenada, nombre);\n    }\n    \n    _insertar(nodo, coordenada, nombre) {\n        // Inserción BST normal\n        // Actualizar altura\n        // Obtener factor de balance\n        // Realizar rotaciones si es necesario\n    }\n    \n    // TODO: Implementar rotaciones\n    rotarDerecha(y) {\n        // Implementar rotación derecha\n    }\n    \n    rotarIzquierda(x) {\n        // Implementar rotación izquierda\n    }\n    \n    // TODO: Calcular altura\n    obtenerAltura(nodo) {\n        // Retornar altura del nodo\n    }\n    \n    // TODO: Calcular factor de balance\n    obtenerBalance(nodo) {\n        // Retornar factor de balance\n    }\n    \n    // TODO: Búsqueda optimizada\n    buscar(coordenada) {\n        return this._buscar(this.raiz, coordenada);\n    }\n    \n    _buscar(nodo, coordenada) {\n        // Implementar búsqueda BST\n    }\n    \n    // TODO: Encontrar ruta entre dos puntos\n    encontrarRuta(origen, destino) {\n        // Implementar búsqueda de ruta\n    }\n    \n    // TODO: Recorrido en orden\n    recorridoEnOrden() {\n        let resultado = [];\n        this._enOrden(this.raiz, resultado);\n        return resultado;\n    }\n    \n    _enOrden(nodo, resultado) {\n        // Implementar recorrido en orden\n    }\n    \n    // Obtener estadísticas del árbol\n    obtenerEstadisticas() {\n        return {\n            altura: this.obtenerAltura(this.raiz),\n            rotaciones: this.rotaciones,\n            nodos: this._contarNodos(this.raiz),\n            balanceado: this._esBalanceado(this.raiz)\n        };\n    }\n    \n    _contarNodos(nodo) {\n        // Contar nodos recursivamente\n    }\n    \n    _esBalanceado(nodo) {\n        // Verificar si el árbol está balanceado\n    }\n}\n\n// Sistemas estelares para insertar\nlet sistemasEstelares = [\n    { coordenada: 50, nombre: "Sol" },\n    { coordenada: 25, nombre: "Proxima Centauri" },\n    { coordenada: 75, nombre: "Sirius" },\n    { coordenada: 10, nombre: "Wolf 359" },\n    { coordenada: 60, nombre: "Vega" },\n    { coordenada: 30, nombre: "Altair" },\n    { coordenada: 80, nombre: "Arcturus" },\n    { coordenada: 15, nombre: "Barnard" },\n    { coordenada: 90, nombre: "Capella" }\n];\n\nconsole.log("🌌 Construyendo mapa de navegación galáctica:");\n\n// TODO: Crear árbol y insertar sistemas\nlet navegador = new ArbolNavegacion();\n\nsistemas Estelares.forEach((sistema, index) => {\n    navegador.insertar(sistema.coordenada, sistema.nombre);\n    console.log(`${index + 1}. Insertando ${sistema.nombre} (${sistema.coordenada})`);\n    \n    // Mostrar estadísticas después de cada inserción\n    let stats = navegador.obtenerEstadisticas();\n    console.log(`   📊 Altura: ${stats.altura}, Rotaciones: ${stats.rotaciones}`);\n});\n\nconsole.log("\\n🔍 Sistemas ordenados por coordenada:");\n// TODO: Mostrar recorrido en orden\n\nconsole.log("\\n🎯 Pruebas de búsqueda:");\n// TODO: Realizar búsquedas de ejemplo\n\nconsole.log("\\n📊 Estadísticas finales del árbol:");\n// TODO: Mostrar estadísticas completas\n\nconsole.log("\\n🌳 Sistema de navegación galáctica listo");',
    resultado_esperado = '🌳 === ÁRBOL AVL DE NAVEGACIÓN GALÁCTICA ===\n\n🌌 Construyendo mapa de navegación galáctica:\n1. Insertando Sol (50)\n   📊 Altura: 1, Rotaciones: 0\n2. Insertando Proxima Centauri (25)\n   📊 Altura: 2, Rotaciones: 0\n3. Insertando Sirius (75)\n   📊 Altura: 2, Rotaciones: 0\n4. Insertando Wolf 359 (10)\n   📊 Altura: 3, Rotaciones: 1\n5. Insertando Vega (60)\n   📊 Altura: 3, Rotaciones: 1\n6. Insertando Altair (30)\n   📊 Altura: 3, Rotaciones: 1\n7. Insertando Arcturus (80)\n   📊 Altura: 3, Rotaciones: 1\n8. Insertando Barnard (15)\n   📊 Altura: 4, Rotaciones: 2\n9. Insertando Capella (90)\n   📊 Altura: 4, Rotaciones: 2\n\n🔍 Sistemas ordenados por coordenada:\nWolf 359 (10) → Barnard (15) → Proxima Centauri (25) → Altair (30) → Sol (50) → Vega (60) → Sirius (75) → Arcturus (80) → Capella (90)\n\n🎯 Pruebas de búsqueda:\n✅ Sol encontrado en coordenada 50\n✅ Vega encontrado en coordenada 60\n❌ Alpha Centauri no encontrado\n\n📊 Estadísticas finales del árbol:\n🌳 Altura total: 4\n🔄 Rotaciones realizadas: 2\n⭐ Sistemas registrados: 9\n⚖️ Árbol balanceado: ✅\n\n🌳 Sistema de navegación galáctica listo'
WHERE id = 30;

-- ================================================================
-- EJERCICIOS DE ALGORITMOS AVANZADOS
-- ================================================================

-- Algoritmos Avanzados - Fácil (ID: 31)
UPDATE tareas 
SET 
    descripcion = '🔍 BÚSQUEDA BINARIA EN CATÁLOGO ESTELAR 🔍\n\nImplementa el algoritmo de búsqueda binaria para localizar rápidamente estrellas en el catálogo astronómico de AstroCode. El sistema debe buscar estrellas por magnitud en un array ordenado y comparar la eficiencia con búsqueda lineal, mostrando el número de comparaciones realizadas y el tiempo de ejecución para diferentes tamaños de catálogo.',
    codigo_base = 'console.log("🔍 === BÚSQUEDA BINARIA EN CATÁLOGO ESTELAR ===\\n");\n\n// Catálogo de estrellas ordenado por magnitud\nlet catalogoEstrellas = [\n    { nombre: "Sirius", magnitud: -1.46 },\n    { nombre: "Canopus", magnitud: -0.74 },\n    { nombre: "Arcturus", magnitud: -0.05 },\n    { nombre: "Vega", magnitud: 0.03 },\n    { nombre: "Capella", magnitud: 0.08 },\n    { nombre: "Rigel", magnitud: 0.13 },\n    { nombre: "Procyon", magnitud: 0.34 },\n    { nombre: "Betelgeuse", magnitud: 0.50 },\n    { nombre: "Aldebaran", magnitud: 0.85 },\n    { nombre: "Spica", magnitud: 1.04 }\n];\n\n// TODO: Implementar búsqueda binaria\nfunction busquedaBinaria(catalogo, magnitudBuscada) {\n    let inicio = 0;\n    let fin = catalogo.length - 1;\n    let comparaciones = 0;\n    \n    while (/* condición del bucle */) {\n        comparaciones++;\n        let medio = Math.floor((inicio + fin) / 2);\n        \n        // TODO: Implementar lógica de búsqueda\n        if (/* estrella encontrada */) {\n            return { estrella: catalogo[medio], comparaciones, encontrada: true };\n        } else if (/* buscar en mitad izquierda */) {\n            // Ajustar fin\n        } else {\n            // Ajustar inicio\n        }\n    }\n    \n    return { estrella: null, comparaciones, encontrada: false };\n}\n\n// TODO: Implementar búsqueda lineal para comparación\nfunction busquedaLineal(catalogo, magnitudBuscada) {\n    let comparaciones = 0;\n    \n    for (let i = 0; i < catalogo.length; i++) {\n        comparaciones++;\n        // TODO: Implementar búsqueda lineal\n        if (/* estrella encontrada */) {\n            return { estrella: catalogo[i], comparaciones, encontrada: true };\n        }\n    }\n    \n    return { estrella: null, comparaciones, encontrada: false };\n}\n\n// TODO: Función para medir tiempo de ejecución\nfunction medirTiempo(funcion, ...args) {\n    let inicio = performance.now();\n    let resultado = funcion(...args);\n    let fin = performance.now();\n    resultado.tiempo = (fin - inicio).toFixed(4);\n    return resultado;\n}\n\nconsole.log("🌟 Catálogo estelar cargado:");\ncatalogoEstrellas.forEach((estrella, index) => {\n    console.log(`${index + 1}. ${estrella.nombre}: ${estrella.magnitud}`);\n});\n\n// Magnitudes a buscar\nlet magnitudesBuscar = [-1.46, 0.03, 1.04, 2.5];\n\nconsole.log("\\n🔍 Comparando algoritmos de búsqueda:");\n\nmagnitudesBuscar.forEach(magnitud => {\n    console.log(`\\n🎯 Buscando estrella con magnitud ${magnitud}:`);\n    \n    // TODO: Ejecutar búsqueda binaria\n    let resultadoBinario = medirTiempo(busquedaBinaria, catalogoEstrellas, magnitud);\n    \n    // TODO: Ejecutar búsqueda lineal\n    let resultadoLineal = medirTiempo(busquedaLineal, catalogoEstrellas, magnitud);\n    \n    // Mostrar resultados\n    if (resultadoBinario.encontrada) {\n        console.log(`✅ Encontrada: ${resultadoBinario.estrella.nombre}`);\n    } else {\n        console.log(`❌ No encontrada`);\n    }\n    \n    console.log(`📊 Búsqueda Binaria: ${resultadoBinario.comparaciones} comparaciones, ${resultadoBinario.tiempo}ms`);\n    console.log(`📊 Búsqueda Lineal: ${resultadoLineal.comparaciones} comparaciones, ${resultadoLineal.tiempo}ms`);\n    \n    if (resultadoBinario.encontrada) {\n        let eficiencia = ((resultadoLineal.comparaciones - resultadoBinario.comparaciones) / resultadoLineal.comparaciones * 100).toFixed(1);\n        console.log(`⚡ Eficiencia: ${eficiencia}% menos comparaciones`);\n    }\n});\n\nconsole.log("\\n🔍 Análisis de búsqueda completado");',
    resultado_esperado = '🔍 === BÚSQUEDA BINARIA EN CATÁLOGO ESTELAR ===\n\n🌟 Catálogo estelar cargado:\n1. Sirius: -1.46\n2. Canopus: -0.74\n3. Arcturus: -0.05\n4. Vega: 0.03\n5. Capella: 0.08\n6. Rigel: 0.13\n7. Procyon: 0.34\n8. Betelgeuse: 0.50\n9. Aldebaran: 0.85\n10. Spica: 1.04\n\n🔍 Comparando algoritmos de búsqueda:\n\n🎯 Buscando estrella con magnitud -1.46:\n✅ Encontrada: Sirius\n📊 Búsqueda Binaria: 4 comparaciones, 0.0123ms\n📊 Búsqueda Lineal: 1 comparaciones, 0.0089ms\n⚡ Eficiencia: -300.0% menos comparaciones\n\n🎯 Buscando estrella con magnitud 0.03:\n✅ Encontrada: Vega\n📊 Búsqueda Binaria: 2 comparaciones, 0.0098ms\n📊 Búsqueda Lineal: 4 comparaciones, 0.0156ms\n⚡ Eficiencia: 50.0% menos comparaciones\n\n🎯 Buscando estrella con magnitud 1.04:\n✅ Encontrada: Spica\n📊 Búsqueda Binaria: 4 comparaciones, 0.0134ms\n📊 Búsqueda Lineal: 10 comparaciones, 0.0234ms\n⚡ Eficiencia: 60.0% menos comparaciones\n\n🎯 Buscando estrella con magnitud 2.5:\n❌ No encontrada\n📊 Búsqueda Binaria: 4 comparaciones, 0.0112ms\n📊 Búsqueda Lineal: 10 comparaciones, 0.0198ms\n\n🔍 Análisis de búsqueda completado'
WHERE id = 31;

