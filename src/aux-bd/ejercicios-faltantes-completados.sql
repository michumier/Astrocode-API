-- ================================================================
-- COMPLETAR EJERCICIOS FALTANTES - ASTROCODE
-- ================================================================
-- Este archivo contiene las sentencias UPDATE para completar los ejercicios
-- que faltan con codigo_base y resultado_esperado segÃºn el CSV proporcionado
-- Todos los ejercicios incluyen temÃ¡tica espacial coherente con AstroCode

USE astrocodebd;

-- ================================================================
-- EJERCICIOS DIFÃCILES FALTANTES
-- ================================================================

-- Variables y Tipos - DifÃ­cil (ID: 3)
UPDATE tareas 
SET 
    descripcion = 'ğŸ”¬ LABORATORIO DE TIPOS CUÃNTICOS ESPACIALES ğŸ”¬\n\nComo cientÃ­fico jefe de la estaciÃ³n AstroCode, debes crear un sistema avanzado de tipos dinÃ¡micos que pueda detectar automÃ¡ticamente el tipo de datos de muestras extraterrestres y realizar operaciones seguras entre diferentes tipos de materia cÃ³smica. El sistema debe manejar conversiones entre elementos conocidos (hidrÃ³geno, helio) y elementos desconocidos, manteniendo la integridad de los datos durante las transformaciones cuÃ¡nticas.',
    codigo_base = 'console.log("ğŸ”¬ === LABORATORIO DE TIPOS CUÃNTICOS ===\\n");\n\n// Sistema de detecciÃ³n automÃ¡tica de tipos\nclass DetectorTipos {\n    // TODO: Implementar detecciÃ³n automÃ¡tica de tipos\n    static detectarTipo(muestra) {\n        // Implementar lÃ³gica de detecciÃ³n\n    }\n    \n    // TODO: Implementar conversiones seguras\n    static convertirSeguro(valor, tipoDestino) {\n        // Implementar conversiones con validaciÃ³n\n    }\n    \n    // TODO: Implementar operaciones entre tipos\n    static operarTipos(valor1, valor2, operacion) {\n        // Implementar operaciones seguras\n    }\n}\n\n// Muestras de prueba\nlet muestras = [42, "Helio-3", 3.14159, true, null, {elemento: "HidrÃ³geno"}];\n\nconsole.log("ğŸ§ª Analizando muestras extraterrestres:");\nmuestras.forEach((muestra, index) => {\n    // TODO: Usar DetectorTipos para analizar cada muestra\n    console.log(`Muestra ${index + 1}: ${muestra} -> Tipo: [IMPLEMENTAR]`);\n});\n\nconsole.log("\\nğŸ”„ Pruebas de conversiÃ³n segura:");\n// TODO: Implementar pruebas de conversiÃ³n\n\nconsole.log("\\nâš—ï¸ AnÃ¡lisis completado");',
    resultado_esperado = 'ğŸ”¬ === LABORATORIO DE TIPOS CUÃNTICOS ===\n\nğŸ§ª Analizando muestras extraterrestres:\nMuestra 1: 42 -> Tipo: number\nMuestra 2: Helio-3 -> Tipo: string\nMuestra 3: 3.14159 -> Tipo: number\nMuestra 4: true -> Tipo: boolean\nMuestra 5: null -> Tipo: null\nMuestra 6: [object Object] -> Tipo: object\n\nğŸ”„ Pruebas de conversiÃ³n segura:\nâœ… ConversiÃ³n 42 -> string: "42"\nâœ… ConversiÃ³n "3.14" -> number: 3.14\nâš ï¸ ConversiÃ³n "Helio-3" -> number: NaN (conversiÃ³n insegura)\nâœ… OperaciÃ³n segura: 42 + 3.14 = 45.14\n\nâš—ï¸ AnÃ¡lisis completado'
WHERE id = 3;

-- Operadores - DifÃ­cil (ID: 6)
UPDATE tareas 
SET 
    descripcion = 'ğŸ¤– INTÃ‰RPRETE DE COMANDOS GALÃCTICOS ğŸ¤–\n\nDesarrolla un intÃ©rprete avanzado de expresiones matemÃ¡ticas para el sistema de navegaciÃ³n de la nave AstroCode. El intÃ©rprete debe evaluar operadores personalizados para cÃ¡lculos de trayectorias espaciales y funciones definidas por el usuario para maniobras complejas. Incluye operadores como distancia_estelar(), velocidad_warp() y coordenadas_galÃ¡cticas().',
    codigo_base = 'console.log("ğŸ¤– === INTÃ‰RPRETE DE COMANDOS GALÃCTICOS ===\\n");\n\n// IntÃ©rprete de expresiones espaciales\nclass InterpreteGalactico {\n    constructor() {\n        this.operadores = new Map();\n        this.funciones = new Map();\n        this.inicializarOperadores();\n    }\n    \n    // TODO: Inicializar operadores personalizados\n    inicializarOperadores() {\n        // Implementar operadores espaciales\n    }\n    \n    // TODO: Registrar funciÃ³n personalizada\n    registrarFuncion(nombre, funcion) {\n        // Implementar registro de funciones\n    }\n    \n    // TODO: Evaluar expresiÃ³n completa\n    evaluar(expresion) {\n        // Implementar evaluaciÃ³n con precedencia\n    }\n    \n    // TODO: Parsear tokens\n    parsear(expresion) {\n        // Implementar parser de expresiones\n    }\n}\n\n// Crear intÃ©rprete\nlet interprete = new InterpreteGalactico();\n\n// TODO: Registrar funciones espaciales\ninterprete.registrarFuncion("distancia_estelar", (x1, y1, x2, y2) => {\n    // Implementar cÃ¡lculo de distancia\n});\n\n// Expresiones de prueba\nlet expresiones = [\n    "2 + 3 * 4",\n    "distancia_estelar(0, 0, 3, 4)",\n    "(velocidad_warp(5) + 2) * factor_tiempo(0.8)"\n];\n\nconsole.log("ğŸ§® Evaluando comandos de navegaciÃ³n:");\nexpresiones.forEach(expr => {\n    // TODO: Evaluar cada expresiÃ³n\n    console.log(`${expr} = [IMPLEMENTAR]`);\n});\n\nconsole.log("\\nğŸš€ Sistema de navegaciÃ³n listo");',
    resultado_esperado = 'ğŸ¤– === INTÃ‰RPRETE DE COMANDOS GALÃCTICOS ===\n\nğŸ§® Evaluando comandos de navegaciÃ³n:\n2 + 3 * 4 = 14\ndistancia_estelar(0, 0, 3, 4) = 5\n(velocidad_warp(5) + 2) * factor_tiempo(0.8) = 5.6\n\nğŸš€ Sistema de navegaciÃ³n listo'
WHERE id = 6;

-- Estructuras Condicionales - DifÃ­cil (ID: 9)
UPDATE tareas 
SET 
    descripcion = 'ğŸ¦ SISTEMA DE PRÃ‰STAMOS INTERPLANETARIOS ğŸ¦\n\nCrea un sistema avanzado de evaluaciÃ³n de prÃ©stamos para el Banco GalÃ¡ctico AstroCode. El sistema debe evaluar mÃºltiples condiciones anidadas para determinar la elegibilidad de prÃ©stamos para colonos espaciales, considerando factores como: ingresos en crÃ©ditos galÃ¡cticos, historial de misiones, planeta de origen, experiencia espacial, y riesgo de la colonia destino.',
    codigo_base = 'console.log("ğŸ¦ === BANCO GALÃCTICO ASTROCODE ===\\n");\n\n// Sistema de evaluaciÃ³n de prÃ©stamos\nclass EvaluadorPrestamos {\n    // TODO: Implementar evaluaciÃ³n completa\n    static evaluarSolicitud(solicitante) {\n        let puntuacion = 0;\n        let factores = [];\n        \n        // TODO: Evaluar ingresos (peso: 30%)\n        if (/* condiciÃ³n ingresos altos */) {\n            // Implementar lÃ³gica\n        }\n        \n        // TODO: Evaluar historial de misiones (peso: 25%)\n        if (/* condiciÃ³n historial excelente */) {\n            // Implementar lÃ³gica\n        }\n        \n        // TODO: Evaluar planeta de origen (peso: 20%)\n        if (/* condiciÃ³n planeta seguro */) {\n            // Implementar lÃ³gica\n        }\n        \n        // TODO: Evaluar experiencia espacial (peso: 15%)\n        if (/* condiciÃ³n experiencia alta */) {\n            // Implementar lÃ³gica\n        }\n        \n        // TODO: Evaluar riesgo destino (peso: 10%)\n        if (/* condiciÃ³n destino seguro */) {\n            // Implementar lÃ³gica\n        }\n        \n        return { puntuacion, factores, aprobado: puntuacion >= 70 };\n    }\n}\n\n// Casos de prueba\nlet solicitantes = [\n    {\n        nombre: "Comandante Zara",\n        ingresos: 85000,\n        historialMisiones: "excelente",\n        planetaOrigen: "Terra Nova",\n        experienciaEspacial: 15,\n        destinoColonia: "Kepler-442b"\n    },\n    {\n        nombre: "Piloto Kai",\n        ingresos: 45000,\n        historialMisiones: "bueno",\n        planetaOrigen: "Marte",\n        experienciaEspacial: 5,\n        destinoColonia: "Proxima-b"\n    }\n];\n\nconsole.log("ğŸ“‹ Evaluando solicitudes de prÃ©stamo:");\nsolicitantes.forEach(solicitante => {\n    // TODO: Evaluar cada solicitante\n    let resultado = EvaluadorPrestamos.evaluarSolicitud(solicitante);\n    console.log(`\\nğŸ‘¤ ${solicitante.nombre}:`);\n    console.log(`ğŸ“Š PuntuaciÃ³n: ${resultado.puntuacion}/100`);\n    console.log(`${resultado.aprobado ? "âœ… APROBADO" : "âŒ RECHAZADO"}`);\n});\n\nconsole.log("\\nğŸ¦ EvaluaciÃ³n completada");',
    resultado_esperado = 'ğŸ¦ === BANCO GALÃCTICO ASTROCODE ===\n\nğŸ“‹ Evaluando solicitudes de prÃ©stamo:\n\nğŸ‘¤ Comandante Zara:\nğŸ“Š PuntuaciÃ³n: 95/100\nâœ… APROBADO\n\nğŸ‘¤ Piloto Kai:\nğŸ“Š PuntuaciÃ³n: 65/100\nâŒ RECHAZADO\n\nğŸ¦ EvaluaciÃ³n completada'
WHERE id = 9;

-- Bucles - DifÃ­cil (ID: 12)
UPDATE tareas 
SET 
    descripcion = 'ğŸ›¸ OPTIMIZADOR DE RUTAS COMERCIALES GALÃCTICAS ğŸ›¸\n\nImplementa un algoritmo de optimizaciÃ³n que use bucles anidados para resolver el problema del viajante comercial espacial. El sistema debe encontrar la ruta mÃ¡s eficiente para visitar todas las estaciones comerciales de la galaxia, minimizando el consumo de combustible cuÃ¡ntico y el tiempo de viaje entre planetas.',
    codigo_base = 'console.log("ğŸ›¸ === OPTIMIZADOR DE RUTAS GALÃCTICAS ===\\n");\n\n// Datos de estaciones comerciales\nlet estaciones = [\n    { nombre: "Terra Nova", x: 0, y: 0 },\n    { nombre: "Marte Central", x: 3, y: 4 },\n    { nombre: "Europa Station", x: 6, y: 1 },\n    { nombre: "Titan Base", x: 2, y: 7 },\n    { nombre: "Kepler Hub", x: 8, y: 3 }\n];\n\n// TODO: Implementar cÃ¡lculo de distancia\nfunction calcularDistancia(estacion1, estacion2) {\n    // Implementar fÃ³rmula de distancia euclidiana\n}\n\n// TODO: Implementar algoritmo del viajante\nfunction encontrarRutaOptima(estaciones) {\n    let mejorRuta = null;\n    let menorDistancia = Infinity;\n    \n    // TODO: Generar todas las permutaciones posibles\n    function generarPermutaciones(arr, inicio = 0) {\n        // Implementar generaciÃ³n de permutaciones\n    }\n    \n    // TODO: Calcular distancia total de una ruta\n    function calcularDistanciaTotal(ruta) {\n        // Implementar cÃ¡lculo de distancia total\n    }\n    \n    // TODO: Encontrar la mejor ruta usando fuerza bruta\n    // Usar bucles anidados para evaluar todas las combinaciones\n    \n    return { ruta: mejorRuta, distancia: menorDistancia };\n}\n\nconsole.log("ğŸ—ºï¸ Estaciones comerciales registradas:");\nestaciones.forEach((estacion, index) => {\n    console.log(`${index + 1}. ${estacion.nombre} (${estacion.x}, ${estacion.y})`);\n});\n\nconsole.log("\\nğŸ” Calculando ruta Ã³ptima...");\n// TODO: Ejecutar optimizaciÃ³n\nlet resultado = encontrarRutaOptima(estaciones);\n\nconsole.log("\\nğŸ¯ Ruta Ã³ptima encontrada:");\n// TODO: Mostrar resultado\nconsole.log(`ğŸ“ Distancia total: ${resultado.distancia.toFixed(2)} aÃ±os luz`);\nconsole.log("ğŸ›¸ OptimizaciÃ³n completada");',
    resultado_esperado = 'ğŸ›¸ === OPTIMIZADOR DE RUTAS GALÃCTICAS ===\n\nğŸ—ºï¸ Estaciones comerciales registradas:\n1. Terra Nova (0, 0)\n2. Marte Central (3, 4)\n3. Europa Station (6, 1)\n4. Titan Base (2, 7)\n5. Kepler Hub (8, 3)\n\nğŸ” Calculando ruta Ã³ptima...\n\nğŸ¯ Ruta Ã³ptima encontrada:\nğŸ“ Distancia total: 23.85 aÃ±os luz\nğŸ›¸ OptimizaciÃ³n completada'
WHERE id = 12;

-- Funciones - DifÃ­cil (ID: 15)
UPDATE tareas 
SET 
    descripcion = 'âš¡ SISTEMA DE FUNCIONES CUÃNTICAS AVANZADAS âš¡\n\nDesarrolla un sistema avanzado de funciones de orden superior para el procesamiento de datos cuÃ¡nticos de AstroCode. Implementa map(), filter(), reduce() y permite el encadenamiento de operaciones para analizar grandes volÃºmenes de datos de sensores espaciales, detectar anomalÃ­as y procesar seÃ±ales de civilizaciones extraterrestres.',
    codigo_base = 'console.log("âš¡ === SISTEMA DE FUNCIONES CUÃNTICAS ===\\n");\n\n// Datos de sensores espaciales\nlet datosSensores = [\n    { sector: "Alpha", temperatura: -45, radiacion: 0.3, seÃ±ales: [1.2, 3.4, 0.8] },\n    { sector: "Beta", temperatura: 22, radiacion: 0.1, seÃ±ales: [2.1, 1.9, 4.2] },\n    { sector: "Gamma", temperatura: -12, radiacion: 0.8, seÃ±ales: [0.5, 6.1, 2.3] },\n    { sector: "Delta", temperatura: 67, radiacion: 0.2, seÃ±ales: [3.3, 1.1, 5.4] }\n];\n\n// TODO: Implementar sistema de funciones de orden superior\nclass ProcesadorCuantico {\n    // TODO: Implementar map personalizado\n    static mapear(array, transformacion) {\n        // Implementar funciÃ³n map\n    }\n    \n    // TODO: Implementar filter personalizado\n    static filtrar(array, condicion) {\n        // Implementar funciÃ³n filter\n    }\n    \n    // TODO: Implementar reduce personalizado\n    static reducir(array, acumulador, valorInicial) {\n        // Implementar funciÃ³n reduce\n    }\n    \n    // TODO: Implementar encadenamiento\n    static cadena(array) {\n        return {\n            mapear: (fn) => {\n                // Implementar encadenamiento de map\n            },\n            filtrar: (fn) => {\n                // Implementar encadenamiento de filter\n            },\n            reducir: (fn, inicial) => {\n                // Implementar encadenamiento de reduce\n            },\n            obtener: () => array\n        };\n    }\n}\n\nconsole.log("ğŸ”¬ Procesando datos de sensores:");\n\n// TODO: Usar funciones de orden superior para anÃ¡lisis\nconsole.log("\\nğŸ“Š AnÃ¡lisis de temperatura:");\n// Mapear temperaturas a Kelvin\n\nconsole.log("\\nğŸ” Sectores con radiaciÃ³n alta:");\n// Filtrar sectores con radiaciÃ³n > 0.5\n\nconsole.log("\\nğŸ“ˆ Promedio de seÃ±ales por sector:");\n// Reducir seÃ±ales para obtener promedios\n\nconsole.log("\\nğŸ”— AnÃ¡lisis encadenado:");\n// Usar encadenamiento para anÃ¡lisis complejo\n\nconsole.log("\\nâš¡ Procesamiento cuÃ¡ntico completado");',
    resultado_esperado = 'âš¡ === SISTEMA DE FUNCIONES CUÃNTICAS ===\n\nğŸ”¬ Procesando datos de sensores:\n\nğŸ“Š AnÃ¡lisis de temperatura:\nAlpha: 228.15 K\nBeta: 295.15 K\nGamma: 261.15 K\nDelta: 340.15 K\n\nğŸ” Sectores con radiaciÃ³n alta:\nGamma: 0.8 radiaciÃ³n\n\nğŸ“ˆ Promedio de seÃ±ales por sector:\nAlpha: 1.80\nBeta: 2.73\nGamma: 2.97\nDelta: 3.27\n\nğŸ”— AnÃ¡lisis encadenado:\nSectores habitables con seÃ±ales fuertes: Beta, Delta\n\nâš¡ Procesamiento cuÃ¡ntico completado'
WHERE id = 15;

-- Arrays y Listas - DifÃ­cil (ID: 18)
UPDATE tareas 
SET 
    descripcion = 'ğŸ“¡ ARRAY DINÃMICO DE COMUNICACIONES ESPACIALES ğŸ“¡\n\nCrea una implementaciÃ³n eficiente de un array dinÃ¡mico para el sistema de comunicaciones de AstroCode. El array debe redimensionarse automÃ¡ticamente para manejar el flujo variable de mensajes interplanetarios, mantener un factor de carga Ã³ptimo para minimizar la latencia, y optimizar el uso de memoria en el espacio limitado de la nave.',
    codigo_base = 'console.log("ğŸ“¡ === ARRAY DINÃMICO DE COMUNICACIONES ===\\n");\n\n// TODO: Implementar array dinÃ¡mico optimizado\nclass ArrayComunicaciones {\n    constructor(capacidadInicial = 4) {\n        this.datos = new Array(capacidadInicial);\n        this.tamaÃ±o = 0;\n        this.capacidad = capacidadInicial;\n        this.factorCarga = 0.75; // Redimensionar al 75%\n    }\n    \n    // TODO: Implementar inserciÃ³n con redimensionamiento\n    agregar(mensaje) {\n        // Verificar si necesita redimensionar\n        // Agregar elemento\n    }\n    \n    // TODO: Implementar eliminaciÃ³n con compactaciÃ³n\n    eliminar(indice) {\n        // Eliminar elemento\n        // Verificar si necesita compactar\n    }\n    \n    // TODO: Implementar redimensionamiento automÃ¡tico\n    redimensionar() {\n        // Calcular nueva capacidad\n        // Copiar elementos al nuevo array\n    }\n    \n    // TODO: Implementar compactaciÃ³n\n    compactar() {\n        // Reducir capacidad si es necesario\n    }\n    \n    // TODO: Implementar bÃºsqueda optimizada\n    buscar(criterio) {\n        // Implementar bÃºsqueda eficiente\n    }\n    \n    // MÃ©todos de informaciÃ³n\n    obtenerEstadisticas() {\n        return {\n            tamaÃ±o: this.tamaÃ±o,\n            capacidad: this.capacidad,\n            factorUso: (this.tamaÃ±o / this.capacidad * 100).toFixed(1),\n            memoriaUsada: this.capacidad * 8 // bytes aproximados\n        };\n    }\n}\n\n// Crear sistema de comunicaciones\nlet sistemaCom = new ArrayComunicaciones();\n\n// Mensajes de prueba\nlet mensajes = [\n    { origen: "Terra", destino: "Marte", contenido: "Suministros en camino" },\n    { origen: "Luna", destino: "Europa", contenido: "MisiÃ³n completada" },\n    { origen: "Titan", destino: "Terra", contenido: "AnomalÃ­a detectada" },\n    { origen: "Marte", destino: "Kepler", contenido: "Colonos listos" },\n    { origen: "Europa", destino: "Luna", contenido: "Datos cientÃ­ficos" }\n];\n\nconsole.log("ğŸ“¨ Procesando mensajes interplanetarios:");\nmensajes.forEach((mensaje, index) => {\n    sistemaCom.agregar(mensaje);\n    console.log(`${index + 1}. ${mensaje.origen} â†’ ${mensaje.destino}: ${mensaje.contenido}`);\n    \n    // TODO: Mostrar estadÃ­sticas despuÃ©s de cada inserciÃ³n\n    let stats = sistemaCom.obtenerEstadisticas();\n    console.log(`   ğŸ“Š Capacidad: ${stats.capacidad}, Uso: ${stats.factorUso}%`);\n});\n\nconsole.log("\\nğŸ” Pruebas de eliminaciÃ³n y compactaciÃ³n:");\n// TODO: Eliminar algunos mensajes y mostrar compactaciÃ³n\n\nconsole.log("\\nğŸ“¡ Sistema de comunicaciones optimizado");',
    resultado_esperado = 'ğŸ“¡ === ARRAY DINÃMICO DE COMUNICACIONES ===\n\nğŸ“¨ Procesando mensajes interplanetarios:\n1. Terra â†’ Marte: Suministros en camino\n   ğŸ“Š Capacidad: 4, Uso: 25.0%\n2. Luna â†’ Europa: MisiÃ³n completada\n   ğŸ“Š Capacidad: 4, Uso: 50.0%\n3. Titan â†’ Terra: AnomalÃ­a detectada\n   ğŸ“Š Capacidad: 4, Uso: 75.0%\n4. Marte â†’ Kepler: Colonos listos\n   ğŸ“Š Capacidad: 8, Uso: 50.0%\n5. Europa â†’ Luna: Datos cientÃ­ficos\n   ğŸ“Š Capacidad: 8, Uso: 62.5%\n\nğŸ” Pruebas de eliminaciÃ³n y compactaciÃ³n:\nâŒ Eliminando mensaje 2\nğŸ“Š Capacidad reducida: 8 â†’ 4\nâœ… Factor de carga optimizado: 75.0%\n\nğŸ“¡ Sistema de comunicaciones optimizado'
WHERE id = 18;

-- ================================================================
-- EJERCICIOS DE CATEGORÃAS AVANZADAS
-- ================================================================

-- Objetos y Clases - DifÃ­cil (ID: 21)
UPDATE tareas 
SET 
    descripcion = 'ğŸ—ï¸ ARQUITECTURA DE PATRONES ESPACIALES ğŸ—ï¸\n\nCrea un sistema cohesivo de diseÃ±o de patrones para la gestiÃ³n de naves espaciales en AstroCode. Implementa Factory Pattern para crear diferentes tipos de naves, Observer Pattern para monitorear sistemas crÃ­ticos, y Strategy Pattern para diferentes modos de vuelo (exploraciÃ³n, combate, comercial). El sistema debe ser extensible y mantenible.',
    codigo_base = 'console.log("ğŸ—ï¸ === ARQUITECTURA DE PATRONES ESPACIALES ===\\n");\n\n// TODO: Implementar Factory Pattern\nclass FabricaNaves {\n    static crearNave(tipo, especificaciones) {\n        // Implementar factory para diferentes tipos de naves\n    }\n}\n\n// TODO: Implementar clases base y derivadas\nclass Nave {\n    constructor(nombre, tipo) {\n        this.nombre = nombre;\n        this.tipo = tipo;\n        this.observadores = [];\n        this.estrategiaVuelo = null;\n    }\n    \n    // TODO: Implementar Observer Pattern\n    agregarObservador(observador) {\n        // Implementar registro de observadores\n    }\n    \n    notificarObservadores(evento) {\n        // Implementar notificaciÃ³n\n    }\n    \n    // TODO: Implementar Strategy Pattern\n    establecerEstrategiaVuelo(estrategia) {\n        // Implementar cambio de estrategia\n    }\n    \n    volar() {\n        // Usar estrategia actual\n    }\n}\n\n// TODO: Implementar tipos especÃ­ficos de naves\nclass NaveExploracion extends Nave {\n    // Implementar caracterÃ­sticas especÃ­ficas\n}\n\nclass NaveCombate extends Nave {\n    // Implementar caracterÃ­sticas especÃ­ficas\n}\n\nclass NaveComercial extends Nave {\n    // Implementar caracterÃ­sticas especÃ­ficas\n}\n\n// TODO: Implementar observadores\nclass MonitorSistemas {\n    actualizar(evento) {\n        // Implementar monitoreo\n    }\n}\n\n// TODO: Implementar estrategias de vuelo\nclass EstrategiaExploracion {\n    ejecutar(nave) {\n        // Implementar modo exploraciÃ³n\n    }\n}\n\nclass EstrategiaCombate {\n    ejecutar(nave) {\n        // Implementar modo combate\n    }\n}\n\nclass EstrategiaComercial {\n    ejecutar(nave) {\n        // Implementar modo comercial\n    }\n}\n\n// DemostraciÃ³n del sistema\nconsole.log("ğŸš€ Creando flota espacial:");\n\n// TODO: Usar Factory para crear naves\nlet naves = [\n    FabricaNaves.crearNave("exploracion", { nombre: "Discovery" }),\n    FabricaNaves.crearNave("combate", { nombre: "Defender" }),\n    FabricaNaves.crearNave("comercial", { nombre: "Trader" })\n];\n\n// TODO: Configurar observadores y estrategias\nlet monitor = new MonitorSistemas();\n\nnaves.forEach(nave => {\n    nave.agregarObservador(monitor);\n    // Asignar estrategia apropiada\n    console.log(`âœ… ${nave.nombre} (${nave.tipo}) creada y configurada`);\n});\n\nconsole.log("\\nğŸ® Probando cambios de estrategia:");\n// TODO: Demostrar cambios de estrategia\n\nconsole.log("\\nğŸ—ï¸ Arquitectura de patrones implementada");',
    resultado_esperado = 'ğŸ—ï¸ === ARQUITECTURA DE PATRONES ESPACIALES ===\n\nğŸš€ Creando flota espacial:\nâœ… Discovery (exploracion) creada y configurada\nâœ… Defender (combate) creada y configurada\nâœ… Trader (comercial) creada y configurada\n\nğŸ® Probando cambios de estrategia:\nğŸ” Discovery cambia a modo exploraciÃ³n\nâš”ï¸ Defender cambia a modo combate\nğŸ’° Trader cambia a modo comercial\nğŸ“¡ Monitor detecta: Discovery inicia exploraciÃ³n\nğŸ“¡ Monitor detecta: Defender activa sistemas de combate\nğŸ“¡ Monitor detecta: Trader optimiza rutas comerciales\n\nğŸ—ï¸ Arquitectura de patrones implementada'
WHERE id = 21;

-- Algoritmos de Ordenamiento - DifÃ­cil (ID: 24)
UPDATE tareas 
SET 
    descripcion = 'ğŸ”„ ALGORITMO HÃBRIDO DE CLASIFICACIÃ“N CÃ“SMICA ğŸ”„\n\nDesarrolla un algoritmo de ordenamiento hÃ­brido inteligente para clasificar datos astronÃ³micos masivos en AstroCode. El algoritmo debe combinar mÃºltiples tÃ©cnicas (QuickSort, MergeSort, HeapSort) y adaptarse automÃ¡ticamente segÃºn las caracterÃ­sticas de los datos: tamaÃ±o del dataset, nivel de desorden, y patrones de distribuciÃ³n de estrellas y planetas.',
    codigo_base = 'console.log("ğŸ”„ === ALGORITMO HÃBRIDO DE CLASIFICACIÃ“N ===\\n");\n\n// Datos astronÃ³micos de ejemplo\nlet datosAstronomicos = [\n    { nombre: "Proxima Centauri", distancia: 4.24, tipo: "estrella", magnitud: 11.13 },\n    { nombre: "Kepler-442b", distancia: 1200, tipo: "planeta", magnitud: 16.0 },\n    { nombre: "Sirius", distancia: 8.6, tipo: "estrella", magnitud: -1.46 },\n    { nombre: "TRAPPIST-1e", distancia: 40, tipo: "planeta", magnitud: 18.8 },\n    { nombre: "Vega", distancia: 25, tipo: "estrella", magnitud: 0.03 }\n];\n\n// TODO: Implementar algoritmo hÃ­brido\nclass ClasificadorCÃ³smico {\n    // TODO: Analizar caracterÃ­sticas de los datos\n    static analizarDatos(datos) {\n        // Determinar tamaÃ±o, desorden, patrones\n    }\n    \n    // TODO: Seleccionar algoritmo Ã³ptimo\n    static seleccionarAlgoritmo(analisis) {\n        // Decidir quÃ© algoritmo usar\n    }\n    \n    // TODO: Implementar QuickSort optimizado\n    static quickSort(arr, comparador, inicio = 0, fin = arr.length - 1) {\n        // Implementar QuickSort\n    }\n    \n    // TODO: Implementar MergeSort\n    static mergeSort(arr, comparador) {\n        // Implementar MergeSort\n    }\n    \n    // TODO: Implementar HeapSort\n    static heapSort(arr, comparador) {\n        // Implementar HeapSort\n    }\n    \n    // TODO: Implementar algoritmo hÃ­brido principal\n    static ordenarHibrido(datos, criterio) {\n        // Analizar datos\n        // Seleccionar algoritmo\n        // Ejecutar ordenamiento\n        // Retornar resultado con estadÃ­sticas\n    }\n}\n\n// Criterios de ordenamiento\nlet criterios = {\n    distancia: (a, b) => a.distancia - b.distancia,\n    magnitud: (a, b) => a.magnitud - b.magnitud,\n    nombre: (a, b) => a.nombre.localeCompare(b.nombre)\n};\n\nconsole.log("ğŸŒŒ Datos astronÃ³micos originales:");\ndatosAstronomicos.forEach((objeto, index) => {\n    console.log(`${index + 1}. ${objeto.nombre} - ${objeto.distancia} aÃ±os luz - Mag: ${objeto.magnitud}`);\n});\n\nconsole.log("\\nğŸ” Ejecutando clasificaciÃ³n hÃ­brida:");\n\n// TODO: Probar diferentes criterios\nObject.keys(criterios).forEach(criterio => {\n    console.log(`\\nğŸ“Š Ordenando por ${criterio}:`);\n    let resultado = ClasificadorCÃ³smico.ordenarHibrido([...datosAstronomicos], criterios[criterio]);\n    // Mostrar resultado y estadÃ­sticas\n});\n\nconsole.log("\\nğŸ”„ ClasificaciÃ³n cÃ³smica completada");',
    resultado_esperado = 'ğŸ”„ === ALGORITMO HÃBRIDO DE CLASIFICACIÃ“N ===\n\nğŸŒŒ Datos astronÃ³micos originales:\n1. Proxima Centauri - 4.24 aÃ±os luz - Mag: 11.13\n2. Kepler-442b - 1200 aÃ±os luz - Mag: 16.0\n3. Sirius - 8.6 aÃ±os luz - Mag: -1.46\n4. TRAPPIST-1e - 40 aÃ±os luz - Mag: 18.8\n5. Vega - 25 aÃ±os luz - Mag: 0.03\n\nğŸ” Ejecutando clasificaciÃ³n hÃ­brida:\n\nğŸ“Š Ordenando por distancia:\nğŸ§  AnÃ¡lisis: 5 elementos, desorden medio â†’ Usando QuickSort\nâš¡ Resultado: Proxima Centauri, Sirius, Vega, TRAPPIST-1e, Kepler-442b\n\nğŸ“Š Ordenando por magnitud:\nğŸ§  AnÃ¡lisis: 5 elementos, alta varianza â†’ Usando MergeSort\nâš¡ Resultado: Sirius, Vega, Proxima Centauri, Kepler-442b, TRAPPIST-1e\n\nğŸ“Š Ordenando por nombre:\nğŸ§  AnÃ¡lisis: datos textuales â†’ Usando HeapSort\nâš¡ Resultado: Kepler-442b, Proxima Centauri, Sirius, TRAPPIST-1e, Vega\n\nğŸ”„ ClasificaciÃ³n cÃ³smica completada'
WHERE id = 24;

-- RecursiÃ³n - DifÃ­cil (ID: 27)
UPDATE tareas 
SET 
    descripcion = 'ğŸŒ€ SOLUCIONADOR DE LABERINTOS CUÃNTICOS ğŸŒ€\n\nImplementa un solucionador avanzado de laberintos para navegar por campos de asteroides en AstroCode. Usa backtracking recursivo con optimizaciones de memoizaciÃ³n para encontrar rutas seguras a travÃ©s de laberintos tridimensionales de asteroides, considerando gravedad variable y campos magnÃ©ticos que cambian las reglas de navegaciÃ³n.',
    codigo_base = 'console.log("ğŸŒ€ === SOLUCIONADOR DE LABERINTOS CUÃNTICOS ===\\n");\n\n// Laberinto 3D de asteroides (0=libre, 1=asteroide, 2=campo magnÃ©tico)\nlet laberintoAsteroides = [\n    [\n        [0, 1, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0],\n        [1, 1, 0, 0, 0],\n        [0, 0, 0, 1, 2]\n    ],\n    [\n        [0, 0, 1, 0, 0],\n        [1, 0, 1, 0, 1],\n        [0, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n];\n\n// TODO: Implementar solucionador con memoizaciÃ³n\nclass SolucionadorCuantico {\n    constructor(laberinto) {\n        this.laberinto = laberinto;\n        this.memo = new Map();\n        this.visitados = new Set();\n        this.mejorRuta = null;\n        this.menorCosto = Infinity;\n    }\n    \n    // TODO: Implementar funciÃ³n principal de resoluciÃ³n\n    resolver(inicio, destino) {\n        // Inicializar estructuras\n        // Llamar a backtracking recursivo\n        // Retornar mejor ruta encontrada\n    }\n    \n    // TODO: Implementar backtracking recursivo\n    backtrack(posicion, destino, rutaActual, costoActual) {\n        // Caso base: llegamos al destino\n        // Caso base: posiciÃ³n invÃ¡lida\n        // Verificar memoizaciÃ³n\n        // Explorar movimientos posibles\n        // RecursiÃ³n con backtracking\n    }\n    \n    // TODO: Implementar validaciÃ³n de movimientos\n    esMovimientoValido(x, y, z) {\n        // Verificar lÃ­mites\n        // Verificar obstÃ¡culos\n        // Verificar si ya fue visitado\n    }\n    \n    // TODO: Implementar cÃ¡lculo de costo\n    calcularCosto(posicion) {\n        // Costo base de movimiento\n        // PenalizaciÃ³n por campos magnÃ©ticos\n        // BonificaciÃ³n por rutas directas\n    }\n    \n    // TODO: Obtener movimientos posibles (6 direcciones en 3D)\n    obtenerMovimientos(x, y, z) {\n        return [\n            [x+1, y, z], [x-1, y, z],  // X\n            [x, y+1, z], [x, y-1, z],  // Y\n            [x, y, z+1], [x, y, z-1]   // Z\n        ];\n    }\n    \n    // Generar clave para memoizaciÃ³n\n    generarClave(x, y, z) {\n        return `${x},${y},${z}`;\n    }\n}\n\n// ConfiguraciÃ³n de la misiÃ³n\nlet inicio = [0, 0, 0];\nlet destino = [4, 4, 1];\n\nconsole.log("ğŸš€ ConfiguraciÃ³n de navegaciÃ³n:");\nconsole.log(`ğŸ“ Inicio: Sector (${inicio.join(", ")})`);\nconsole.log(`ğŸ¯ Destino: Sector (${destino.join(", ")})`);\nconsole.log(`ğŸ“Š Dimensiones: ${laberintoAsteroides[0].length}x${laberintoAsteroides[0][0].length}x${laberintoAsteroides.length}`);\n\nconsole.log("\\nğŸ” Analizando campo de asteroides...");\n\n// TODO: Crear solucionador y encontrar ruta\nlet solucionador = new SolucionadorCuantico(laberintoAsteroides);\nlet resultado = solucionador.resolver(inicio, destino);\n\nif (resultado) {\n    console.log("\\nâœ… Ruta segura encontrada:");\n    // TODO: Mostrar ruta paso a paso\n    console.log(`ğŸ“ Distancia total: ${resultado.costo} unidades`);\n    console.log(`âš¡ Optimizaciones aplicadas: ${resultado.optimizaciones}`);\n} else {\n    console.log("\\nâŒ No se encontrÃ³ ruta segura");\n}\n\nconsole.log("\\nğŸŒ€ NavegaciÃ³n cuÃ¡ntica completada");',
    resultado_esperado = 'ğŸŒ€ === SOLUCIONADOR DE LABERINTOS CUÃNTICOS ===\n\nğŸš€ ConfiguraciÃ³n de navegaciÃ³n:\nğŸ“ Inicio: Sector (0, 0, 0)\nğŸ¯ Destino: Sector (4, 4, 1)\nğŸ“Š Dimensiones: 5x5x2\n\nğŸ” Analizando campo de asteroides...\n\nâœ… Ruta segura encontrada:\n1. (0,0,0) â†’ (0,0,1) - Cambio de nivel\n2. (0,0,1) â†’ (1,0,1) - Avance X\n3. (1,0,1) â†’ (2,0,1) - Evitando asteroide\n4. (2,0,1) â†’ (2,1,1) - Avance Y\n5. (2,1,1) â†’ (2,2,1) - Ruta libre\n6. (2,2,1) â†’ (3,2,1) - Navegando campo\n7. (3,2,1) â†’ (4,2,1) - AproximaciÃ³n final\n8. (4,2,1) â†’ (4,3,1) - Ãšltimo tramo\n9. (4,3,1) â†’ (4,4,1) - Â¡Destino alcanzado!\n\nğŸ“ Distancia total: 12.5 unidades\nâš¡ Optimizaciones aplicadas: MemoizaciÃ³n, Poda de rutas\n\nğŸŒ€ NavegaciÃ³n cuÃ¡ntica completada'
WHERE id = 27;

-- Estructuras de Datos - DifÃ­cil (ID: 30)
UPDATE tareas 
SET 
    descripcion = 'ğŸŒ³ ÃRBOL AVL DE NAVEGACIÃ“N GALÃCTICA ğŸŒ³\n\nImplementa un Ã¡rbol AVL auto-balanceado para el sistema de navegaciÃ³n galÃ¡ctica de AstroCode. El Ã¡rbol debe mantener coordenadas estelares ordenadas, realizar rotaciones automÃ¡ticas para mantener el balance, y proporcionar bÃºsquedas ultra-rÃ¡pidas de rutas entre sistemas estelares para optimizar los viajes interplanetarios.',
    codigo_base = 'console.log("ğŸŒ³ === ÃRBOL AVL DE NAVEGACIÃ“N GALÃCTICA ===\\n");\n\n// TODO: Implementar nodo del Ã¡rbol AVL\nclass NodoEstelar {\n    constructor(coordenada, nombre) {\n        this.coordenada = coordenada; // Coordenada galÃ¡ctica\n        this.nombre = nombre;\n        this.altura = 1;\n        this.izquierdo = null;\n        this.derecho = null;\n    }\n}\n\n// TODO: Implementar Ã¡rbol AVL completo\nclass ArbolNavegacion {\n    constructor() {\n        this.raiz = null;\n        this.rotaciones = 0;\n    }\n    \n    // TODO: Insertar con auto-balanceo\n    insertar(coordenada, nombre) {\n        this.raiz = this._insertar(this.raiz, coordenada, nombre);\n    }\n    \n    _insertar(nodo, coordenada, nombre) {\n        // InserciÃ³n BST normal\n        // Actualizar altura\n        // Obtener factor de balance\n        // Realizar rotaciones si es necesario\n    }\n    \n    // TODO: Implementar rotaciones\n    rotarDerecha(y) {\n        // Implementar rotaciÃ³n derecha\n    }\n    \n    rotarIzquierda(x) {\n        // Implementar rotaciÃ³n izquierda\n    }\n    \n    // TODO: Calcular altura\n    obtenerAltura(nodo) {\n        // Retornar altura del nodo\n    }\n    \n    // TODO: Calcular factor de balance\n    obtenerBalance(nodo) {\n        // Retornar factor de balance\n    }\n    \n    // TODO: BÃºsqueda optimizada\n    buscar(coordenada) {\n        return this._buscar(this.raiz, coordenada);\n    }\n    \n    _buscar(nodo, coordenada) {\n        // Implementar bÃºsqueda BST\n    }\n    \n    // TODO: Encontrar ruta entre dos puntos\n    encontrarRuta(origen, destino) {\n        // Implementar bÃºsqueda de ruta\n    }\n    \n    // TODO: Recorrido en orden\n    recorridoEnOrden() {\n        let resultado = [];\n        this._enOrden(this.raiz, resultado);\n        return resultado;\n    }\n    \n    _enOrden(nodo, resultado) {\n        // Implementar recorrido en orden\n    }\n    \n    // Obtener estadÃ­sticas del Ã¡rbol\n    obtenerEstadisticas() {\n        return {\n            altura: this.obtenerAltura(this.raiz),\n            rotaciones: this.rotaciones,\n            nodos: this._contarNodos(this.raiz),\n            balanceado: this._esBalanceado(this.raiz)\n        };\n    }\n    \n    _contarNodos(nodo) {\n        // Contar nodos recursivamente\n    }\n    \n    _esBalanceado(nodo) {\n        // Verificar si el Ã¡rbol estÃ¡ balanceado\n    }\n}\n\n// Sistemas estelares para insertar\nlet sistemasEstelares = [\n    { coordenada: 50, nombre: "Sol" },\n    { coordenada: 25, nombre: "Proxima Centauri" },\n    { coordenada: 75, nombre: "Sirius" },\n    { coordenada: 10, nombre: "Wolf 359" },\n    { coordenada: 60, nombre: "Vega" },\n    { coordenada: 30, nombre: "Altair" },\n    { coordenada: 80, nombre: "Arcturus" },\n    { coordenada: 15, nombre: "Barnard" },\n    { coordenada: 90, nombre: "Capella" }\n];\n\nconsole.log("ğŸŒŒ Construyendo mapa de navegaciÃ³n galÃ¡ctica:");\n\n// TODO: Crear Ã¡rbol y insertar sistemas\nlet navegador = new ArbolNavegacion();\n\nsistemas Estelares.forEach((sistema, index) => {\n    navegador.insertar(sistema.coordenada, sistema.nombre);\n    console.log(`${index + 1}. Insertando ${sistema.nombre} (${sistema.coordenada})`);\n    \n    // Mostrar estadÃ­sticas despuÃ©s de cada inserciÃ³n\n    let stats = navegador.obtenerEstadisticas();\n    console.log(`   ğŸ“Š Altura: ${stats.altura}, Rotaciones: ${stats.rotaciones}`);\n});\n\nconsole.log("\\nğŸ” Sistemas ordenados por coordenada:");\n// TODO: Mostrar recorrido en orden\n\nconsole.log("\\nğŸ¯ Pruebas de bÃºsqueda:");\n// TODO: Realizar bÃºsquedas de ejemplo\n\nconsole.log("\\nğŸ“Š EstadÃ­sticas finales del Ã¡rbol:");\n// TODO: Mostrar estadÃ­sticas completas\n\nconsole.log("\\nğŸŒ³ Sistema de navegaciÃ³n galÃ¡ctica listo");',
    resultado_esperado = 'ğŸŒ³ === ÃRBOL AVL DE NAVEGACIÃ“N GALÃCTICA ===\n\nğŸŒŒ Construyendo mapa de navegaciÃ³n galÃ¡ctica:\n1. Insertando Sol (50)\n   ğŸ“Š Altura: 1, Rotaciones: 0\n2. Insertando Proxima Centauri (25)\n   ğŸ“Š Altura: 2, Rotaciones: 0\n3. Insertando Sirius (75)\n   ğŸ“Š Altura: 2, Rotaciones: 0\n4. Insertando Wolf 359 (10)\n   ğŸ“Š Altura: 3, Rotaciones: 1\n5. Insertando Vega (60)\n   ğŸ“Š Altura: 3, Rotaciones: 1\n6. Insertando Altair (30)\n   ğŸ“Š Altura: 3, Rotaciones: 1\n7. Insertando Arcturus (80)\n   ğŸ“Š Altura: 3, Rotaciones: 1\n8. Insertando Barnard (15)\n   ğŸ“Š Altura: 4, Rotaciones: 2\n9. Insertando Capella (90)\n   ğŸ“Š Altura: 4, Rotaciones: 2\n\nğŸ” Sistemas ordenados por coordenada:\nWolf 359 (10) â†’ Barnard (15) â†’ Proxima Centauri (25) â†’ Altair (30) â†’ Sol (50) â†’ Vega (60) â†’ Sirius (75) â†’ Arcturus (80) â†’ Capella (90)\n\nğŸ¯ Pruebas de bÃºsqueda:\nâœ… Sol encontrado en coordenada 50\nâœ… Vega encontrado en coordenada 60\nâŒ Alpha Centauri no encontrado\n\nğŸ“Š EstadÃ­sticas finales del Ã¡rbol:\nğŸŒ³ Altura total: 4\nğŸ”„ Rotaciones realizadas: 2\nâ­ Sistemas registrados: 9\nâš–ï¸ Ãrbol balanceado: âœ…\n\nğŸŒ³ Sistema de navegaciÃ³n galÃ¡ctica listo'
WHERE id = 30;

-- ================================================================
-- EJERCICIOS DE ALGORITMOS AVANZADOS
-- ================================================================

-- Algoritmos Avanzados - FÃ¡cil (ID: 31)
UPDATE tareas 
SET 
    descripcion = 'ğŸ” BÃšSQUEDA BINARIA EN CATÃLOGO ESTELAR ğŸ”\n\nImplementa el algoritmo de bÃºsqueda binaria para localizar rÃ¡pidamente estrellas en el catÃ¡logo astronÃ³mico de AstroCode. El sistema debe buscar estrellas por magnitud en un array ordenado y comparar la eficiencia con bÃºsqueda lineal, mostrando el nÃºmero de comparaciones realizadas y el tiempo de ejecuciÃ³n para diferentes tamaÃ±os de catÃ¡logo.',
    codigo_base = 'console.log("ğŸ” === BÃšSQUEDA BINARIA EN CATÃLOGO ESTELAR ===\\n");\n\n// CatÃ¡logo de estrellas ordenado por magnitud\nlet catalogoEstrellas = [\n    { nombre: "Sirius", magnitud: -1.46 },\n    { nombre: "Canopus", magnitud: -0.74 },\n    { nombre: "Arcturus", magnitud: -0.05 },\n    { nombre: "Vega", magnitud: 0.03 },\n    { nombre: "Capella", magnitud: 0.08 },\n    { nombre: "Rigel", magnitud: 0.13 },\n    { nombre: "Procyon", magnitud: 0.34 },\n    { nombre: "Betelgeuse", magnitud: 0.50 },\n    { nombre: "Aldebaran", magnitud: 0.85 },\n    { nombre: "Spica", magnitud: 1.04 }\n];\n\n// TODO: Implementar bÃºsqueda binaria\nfunction busquedaBinaria(catalogo, magnitudBuscada) {\n    let inicio = 0;\n    let fin = catalogo.length - 1;\n    let comparaciones = 0;\n    \n    while (/* condiciÃ³n del bucle */) {\n        comparaciones++;\n        let medio = Math.floor((inicio + fin) / 2);\n        \n        // TODO: Implementar lÃ³gica de bÃºsqueda\n        if (/* estrella encontrada */) {\n            return { estrella: catalogo[medio], comparaciones, encontrada: true };\n        } else if (/* buscar en mitad izquierda */) {\n            // Ajustar fin\n        } else {\n            // Ajustar inicio\n        }\n    }\n    \n    return { estrella: null, comparaciones, encontrada: false };\n}\n\n// TODO: Implementar bÃºsqueda lineal para comparaciÃ³n\nfunction busquedaLineal(catalogo, magnitudBuscada) {\n    let comparaciones = 0;\n    \n    for (let i = 0; i < catalogo.length; i++) {\n        comparaciones++;\n        // TODO: Implementar bÃºsqueda lineal\n        if (/* estrella encontrada */) {\n            return { estrella: catalogo[i], comparaciones, encontrada: true };\n        }\n    }\n    \n    return { estrella: null, comparaciones, encontrada: false };\n}\n\n// TODO: FunciÃ³n para medir tiempo de ejecuciÃ³n\nfunction medirTiempo(funcion, ...args) {\n    let inicio = performance.now();\n    let resultado = funcion(...args);\n    let fin = performance.now();\n    resultado.tiempo = (fin - inicio).toFixed(4);\n    return resultado;\n}\n\nconsole.log("ğŸŒŸ CatÃ¡logo estelar cargado:");\ncatalogoEstrellas.forEach((estrella, index) => {\n    console.log(`${index + 1}. ${estrella.nombre}: ${estrella.magnitud}`);\n});\n\n// Magnitudes a buscar\nlet magnitudesBuscar = [-1.46, 0.03, 1.04, 2.5];\n\nconsole.log("\\nğŸ” Comparando algoritmos de bÃºsqueda:");\n\nmagnitudesBuscar.forEach(magnitud => {\n    console.log(`\\nğŸ¯ Buscando estrella con magnitud ${magnitud}:`);\n    \n    // TODO: Ejecutar bÃºsqueda binaria\n    let resultadoBinario = medirTiempo(busquedaBinaria, catalogoEstrellas, magnitud);\n    \n    // TODO: Ejecutar bÃºsqueda lineal\n    let resultadoLineal = medirTiempo(busquedaLineal, catalogoEstrellas, magnitud);\n    \n    // Mostrar resultados\n    if (resultadoBinario.encontrada) {\n        console.log(`âœ… Encontrada: ${resultadoBinario.estrella.nombre}`);\n    } else {\n        console.log(`âŒ No encontrada`);\n    }\n    \n    console.log(`ğŸ“Š BÃºsqueda Binaria: ${resultadoBinario.comparaciones} comparaciones, ${resultadoBinario.tiempo}ms`);\n    console.log(`ğŸ“Š BÃºsqueda Lineal: ${resultadoLineal.comparaciones} comparaciones, ${resultadoLineal.tiempo}ms`);\n    \n    if (resultadoBinario.encontrada) {\n        let eficiencia = ((resultadoLineal.comparaciones - resultadoBinario.comparaciones) / resultadoLineal.comparaciones * 100).toFixed(1);\n        console.log(`âš¡ Eficiencia: ${eficiencia}% menos comparaciones`);\n    }\n});\n\nconsole.log("\\nğŸ” AnÃ¡lisis de bÃºsqueda completado");',
    resultado_esperado = 'ğŸ” === BÃšSQUEDA BINARIA EN CATÃLOGO ESTELAR ===\n\nğŸŒŸ CatÃ¡logo estelar cargado:\n1. Sirius: -1.46\n2. Canopus: -0.74\n3. Arcturus: -0.05\n4. Vega: 0.03\n5. Capella: 0.08\n6. Rigel: 0.13\n7. Procyon: 0.34\n8. Betelgeuse: 0.50\n9. Aldebaran: 0.85\n10. Spica: 1.04\n\nğŸ” Comparando algoritmos de bÃºsqueda:\n\nğŸ¯ Buscando estrella con magnitud -1.46:\nâœ… Encontrada: Sirius\nğŸ“Š BÃºsqueda Binaria: 4 comparaciones, 0.0123ms\nğŸ“Š BÃºsqueda Lineal: 1 comparaciones, 0.0089ms\nâš¡ Eficiencia: -300.0% menos comparaciones\n\nğŸ¯ Buscando estrella con magnitud 0.03:\nâœ… Encontrada: Vega\nğŸ“Š BÃºsqueda Binaria: 2 comparaciones, 0.0098ms\nğŸ“Š BÃºsqueda Lineal: 4 comparaciones, 0.0156ms\nâš¡ Eficiencia: 50.0% menos comparaciones\n\nğŸ¯ Buscando estrella con magnitud 1.04:\nâœ… Encontrada: Spica\nğŸ“Š BÃºsqueda Binaria: 4 comparaciones, 0.0134ms\nğŸ“Š BÃºsqueda Lineal: 10 comparaciones, 0.0234ms\nâš¡ Eficiencia: 60.0% menos comparaciones\n\nğŸ¯ Buscando estrella con magnitud 2.5:\nâŒ No encontrada\nğŸ“Š BÃºsqueda Binaria: 4 comparaciones, 0.0112ms\nğŸ“Š BÃºsqueda Lineal: 10 comparaciones, 0.0198ms\n\nğŸ” AnÃ¡lisis de bÃºsqueda completado'
WHERE id = 31;

